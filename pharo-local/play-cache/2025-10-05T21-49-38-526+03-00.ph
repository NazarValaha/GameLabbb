"--------------------------------------------------------------------------------------*                      ЛАБОРОТОРНА РОБОТА 3*                 Тема: КЛАСИ ТА МЕТОДИ. КОЛЕКЦІЇ**  Завдання до лабораторної роботи:*     1. Виконайте наведені нижче приклади, збережіть і поясніть отримані результати.*     2. Випробуйте різноманітні способи додавання нових класів до системи.*     3. Навчіться доповнювати функціональність класів.*     4. Випробуйте методи опрацювання колекцій.*    Виконайте за допомогою <Print it>  ------ ПРИНАЛЕЖНІСТЬ КЛАСОВІ, ІЄРАРХІЯ КЛАСІВ"    #(Francesca Jackie Marisa Bree) class. "Array"    (#(Francesca Jackie Marisa Bree) at:2) class. "ByteSymbol"    'Rakesh Vijay Charles Daniel Tyler' class. "ByteString"    ('Rakesh Vijay Charles Daniel Tyler' at:2) class. "Character (a)"    World class . "WorldMorph"    Magnitude class. "Magnitude class"    Magnitude class class. "Metaclass"    nil class. "UndefinedObject"    5 species. "SmallInteger"    123456789000 species. "SmallInteger"    #aName species. "ByteString" " Яка різниця між повідомленнями class i species ? Відповідь: class — описує об’єкт.           species — описує, який тип колекції створюється під час перетворень.    Випробуйте різні способи відкривання браузера класів: за допомогою меню чи програмно      Виконайте за допомогою <Do it>"    ClyFullBrowserMorph open.     ClyFullBrowserMorph openOnClass: Date.     ClyFullBrowserMorph openOnClass: VolumeShape  selector:  #volume. " ------ МЕТОДИ КЛАСУ, КОНСТРУКТОРИ  Виконайте за допомогою <Print It>. Запропонуйте власні приклади. "    Array new: 10. "#(nil nil nil nil nil nil nil nil nil nil)"            OrderedCollection  new. "an OrderedCollection()"    Date today. "29 September 2025"    Time now. "10:28:52.422 am"    UIManager default  request:'How are you?' initialAnswer:'I''m fine!'. "'I''m fine!'"    Integer readFrom: '2013  1925'. "2013"    Integer primesUpTo: 100. "#(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97)"    Rectangle origin:0@0 corner:200@100. "(0@0) corner: (200@100)"    Date nameOfMonth:12. "#December"    Date dayOfWeek: #Friday. "6"    Date orthodoxEasterDateFor: 2022. "24 April 2022"   "Інсталюйте вказані нижче МЕТОДИ КЛАСУ Date:  перенесіть копію тексту визначення методу з робочого вікна в браузер класів.""!Date class methodsFor: 'specific inquiries' stamp: 'CamilloBruni 8/22/2013 19:47'!""orthodoxEasterDateFor: year ""  compute the easter date according to the rules of the orthodox calendar.    source:       http://www.smart.net/~mmontes/ortheast.html   ""     | r1 r2 r3 r4 ra rb r5 rc date |    r1 := year \\ 19.    r2 := year \\ 4.    r3 := year \\ 7.    ra := 19*r1 + 16.    r4 := ra \\ 30.    rb := r2 + r2 + (4*r3) + (6*r4).    r5 := rb \\ 7.    rc := r4 + r5.    date := self year: year month: 4 day: 3.    ^date addDays: rc.""--------------------------------------------------------------------------------------""""!Date class methodsFor: 'specific inquiries' stamp: 'CamilloBruni 8/22/2013 19:48'!""easterDateFor: year ""  compute the easter date.    source: Physikalisch-Technische Bundesanstalt Braunschweig.    Lichtenberg, H.: Zur Interpretation der Gaussschen Osterformel und ihrer Ausnahmeregeln, Historia Mathematica 24 (1997), pp. 441-444      http://www.ptb.de/de/org/4/44/441/oste.htm  ""  | k m s a d r og sz oe day |  k := year // 100.  m := 15 + (3*k + 3//4) - (8*k + 13//25).   s := 2 - (3*k + 3// 4).  a := year \\ 19.  d := 19*a + m \\ 30.  r := d//29 + ((d//28) - (d//29)* (a// 11)).  og := 21 + d - r.  sz := 7 - (year//4 + year + s\\7).  oe := 7 - (og - sz\\7).  day := og + oe.  ^day <= 31    ifTrue: [ Date year: year month: 3 day: day ]    ifFalse: [ Date year: year month: 4 day: day - 31 ].""Знайдіть роки, коли святкування припадають на один день."yearsWithMatchingEasterFrom: startYear to: endYear    | matchingYears orthodoxDate catholicDate |    matchingYears := OrderedCollection new.    (startYear to: endYear) do: [:year |        orthodoxDate := self orthodoxEasterDateFor: year.        catholicDate := self easterDateFor: year.        (orthodoxDate = catholicDate) ifTrue: [            matchingYears add: year        ].    ].    ^matchingYears asArrayDate yearsWithMatchingEasterFrom: 2000 to: 2050. "#(2001 2004 2007 2010 2011 2014 2017 2025 2028 2031 2034 2037 2038 2041 2045 2048)"" ------ РЕКУРСІЯ  Додайте до класу Integer і випробуйте різні методи обчислення чисел  Фібоначчі.  Запропонуйте власні. Порівняйте їхню ефективність.        Перед випробуванням fibonacci ЗБЕРЕЖІТЬ ІМІДЖ СИСТЕМИ! Він може зайняти Ваш комп на тиждень.  "" * ------- "fibonacci        "Answer the nth fibonacci number, where n is the receiver."    ^self < 2        ifTrue: [1]        ifFalse:[(self - 1) fibonacci + (self - 2) fibonacci]" * ------- "fibo        "Frontend function to call fibStart: with: .         Answer the nth fibonacci number, where n is the receiver."    ^self fibStart:1 with:1" * ------- "fibStart: n1 with: n2        "Private - Calculate the n-th Fibonacci number, where         n is the receiver, n1 is previous Fibonacci number         and n2 - the preprevious one." ^ (self < 2)        ifTrue: [ n1 ]        ifFalse:[ (self - 1) fibStart: n1+n2 with:n1 ]3 fibStart: 1 with: 10  "12"4 fibo "5"12 fibonacci "233""<fibStart:with:>Це рекурсивний метод, який обчислює n-те число послідовності Фібоначчі, використовуючи два допоміжні параметри — n1 (попереднє значення) і n2 (передпопереднє значення). На кожному кроці рекурсії відбувається виклик:(self - 1) fibStart: n1 + n2 with: n1 — таким чином, наступний етап отримує нові значення, де поточне число стає сумою двох попередніх.Такий підхід дозволяє виконувати обчислення без повторних підрахунків уже відомих значень, тому алгоритм має лінійну складність O(n). Він працює швидко навіть для великих n і потребує мінімум пам’яті — лише для рекурсивних викликів (глибина дорівнює n).<fibo>Це допоміжний метод, який просто викликає fibStart:with: із початковими значеннями. Його мета — спростити виклик функції, щоб не потрібно було вручну задавати перші два числа послідовності. Фактично, він працює так само, як і fibStart:with:, але зручніший у використанні, коли потрібно просто отримати n-те число Фібоначчі.<fibonacci>Цей варіант використовує класичне рекурсивне визначення:F(n) = F(n - 1) + F(n - 2)Метод простий у розумінні, але дуже неефективний для великих n, оскільки він не запам’ятовує вже обчислені значення і багаторазово виконує ті самі обчислення. Через це його складність є експоненційною — приблизно O(2ⁿ). При великих значеннях n така реалізація значно навантажує процесор і стек викликів, тому практично використовується лише для навчальних цілей або демонстрацій.""------------------------------------------------------------------------------------ ------ СТВОРЕННЯ, ОПРАЦЮВАННЯ КОЛЕКЦІЙ  У текстовому файлі записано інформацію про матрицю цілих чисел: розміри  матриці в першому рядку файла, у всіх наступних рядках - рядки матриці.}  Прочитати матрицю, знайти максимальні елементи кожного рядка і зберегти  їх у файлі. Надрукувати максимальний елемент цілої матриці.""Наведений нижче код можна виконати безпосередньо в робочому вікні, проте,  доцільно зробити його методом власного навчального класу."| matr fStream fName n m mMatr mLines |        "Вибір файла за допомогою діалогу"    (fName:=UIManager default			chooseFullFileNameMatching: nil 			label: 'Виберіть файл з числовими даними' ) isNil        ifTrue: [ ^'Ви не вибрали файла' ].         fStream := fName asFileReference readStream.	        "Введення даних" 	    n := Integer readFrom: fStream.  	    matr := Array new: n.	    m := Integer readFrom: fStream.	    matr := matr collect: [ :x | Array new: m ]. 	    1 to: n do: [ :i |  fStream nextLine. 		     matr at: i put: (				 (matr at: i) collect: [ :x |  						Integer readFrom: fStream. ]					 )	 ].    fStream close. matr inspect.        "Обчислення максимальних елементів"    mLines:=matr collect: [ :r | r inject: (r at: 1) into: [ :x :y | x max: y] ].    mMatr:=mLines at: 1.    mLines do: [ :x | x > mMatr ifTrue: [ mMatr := x ] ].        "Побудова імені файла результатів, збереження"    fName at: fName size - 4 put: $_ .    fStream := fName asFileReference writeStream.    mLines do: [ :x | x printOn: fStream. fStream cr ].    fStream close.    ^mMatr .  " Поясніть код, наведений вище (кожне повідомлення!):	У цьому коді ми працюємо з матрицею чисел, зчитаною з файлу. Спершу оголошуємо локальні змінні для зберігання самої матриці, потоку файлу, імені файлу, кількості рядків і стовпців, а також для проміжних результатів. Далі відкривається діалог для вибору файлу користувачем. Якщо файл не обрано, метод одразу повертає повідомлення про це і подальше виконання коду зупиняється.Після цього створюється потік для читання файлу. Перше число з файлу визначає кількість рядків матриці, а друге число — кількість стовпців. У початковій версії матриця реалізується як масив масивів: спершу створюємо масив для рядків, а потім кожен рядок заповнюємо окремим масивом стовпців. Потік закривається після зчитування даних, і відкривається інспектор для перегляду структури матриці.Щоб знайти максимуми рядків, кожен рядок обробляється за допомогою методу inject, який проходить усі елементи рядка і визначає найбільше значення. Потім, перебираючи всі максимуми рядків, знаходиться загальний максимум усієї матриці. Після обробки результатів ім’я файлу змінюється для збереження результатів у новий файл, відкривається потік на запис, і кожен максимум рядка записується в файл на окремий рядок. Потім потік закривається. Нарешті, метод повертає максимальний елемент усієї матриці.   Як можна замінити масив масивів на екземпляр класу Matrix?:	Якщо використовувати клас Matrix, код можна зробити більш компактним і зручним. Клас Matrix зберігає матрицю як єдину структуру n × m, і доступ до елементів відбувається через at: i at: j, що виключає необхідність створювати масив масивів. Спочатку відкриваємо потік для читання файлу і зчитуємо розміри матриці. Потім створюємо об’єкт Matrix відповідного розміру і заповнюємо його числами з файлу. Далі, перебираючи рядки та стовпці, за допомогою вкладених inject визначаємо максимальні значення для кожного рядка та загальний максимум матриці. Результат повертається як вихідний максимум. Такий підхід дозволяє робити код більш структурованим і компактним, позбавляє зайвих проміжних масивів і робить роботу з матрицею наочнішою.======================================================""------ АДРЕСНА КНИГА Приклад створення і використання адресної книги, описаний у одній з лекцій.  Пригадуєте, спочатку оголошуємо глобальну змінну, що міститиме впорядковану  колекцію масивів з трьох рядків. Спосіб порівняння описує бінарний блок."    Smalltalk globals at: #AddressBook              put:(SortedCollection sortBlock:[:a :b | (a at:1)<=(b at:1)])." * --- Тепер до книги можна додавати записи. "    AddressBook            add: #('Ruth' 'Babe' '456 Mudville Flats');            add: #('Smith' 'John' '12/5 Park Ave');            add: #('Jexon' 'John' '5 Baverli Hills');            add: #('Adams' 'John' '1 Hell str');            add: #('Taylor' 'Babe' '2a/35 Deribas str');            add: #('Greg' 'Voss' '12345 the USA');            add: #('Ivanov' 'Nazar' 'Kyiv, Main Str 25');            add: #('Koval' 'Bohdan' 'Lviv, Freedom Ave 12');            add: #('Shevchenko' 'Nazar' 'Kharkiv, Central Park 3');            add: #('Petrenko' 'Nazar' 'Odesa, Sea St 8')." * --- Додайте власні записи. Видрукуйте вміст книги (код запропоновано нижче).  "   | s w |  s := WriteStream on: String new.    AddressBook do:[:x | x do:        [ :y | s nextPutAll: y; tab; tab.].        s cr. ].  w := Workspace openLabel: 'My Address Book'.  w contents: s contents." * ----  Наступне завдання - надрукувати список прізвищ людей з однаковими іменами.               Приклад демонструє різні способи перебору та перетворення колекцій." | firstNames duplicates |    firstNames:=Bag new.        "утворимо торбу імен"    AddressBook do: [ :entry | firstNames add: (entry at: 2) ].        "виберемо ті імена, які зустрічаються більше одного разу"    duplicates:=firstNames select:        [ :name | (firstNames occurrencesOf: name)>1 ].            "і впорядкуємо їх"    duplicates:=duplicates asSet asSortedCollection.        "друкуємо імена та відповідні їм прізвища"    duplicates do: [ :first | first printOn: Transcript. Transcript show:'==>'.        AddressBook do: [ :entry | (entry at: 2)=first            ifTrue: [ Transcript show:' '. (entry at: 1) printOn: Transcript ] ].        Transcript cr ]. Transcript show:' '."Поясніть перетворення, що відбуваються в цьому фрагменті.    Запропонуйте власні варіанти використання та перетворення колекцій.    Оформіть запропоновані вище фрагменти як методи навчального класу.""Smalltalk globals at: #AddressBook     put: (SortedCollection sortBlock: [:a :b | (a at: 1) <= (b at: 1)]).Тут створюється впорядкована колекція (SortedCollection), яка зберігатиме записи у вигляді масивів із трьох елементів:#('Прізвище' 'Імʼя' 'Адреса').Блок [:a :b | (a at:1) <= (b at:1)] визначає, що сортування відбуватиметься за першим елементом масиву (тобто за прізвищем).Таким чином, усі записи в AddressBook автоматично будуть впорядковуватись за прізвищем.""AddressBook    add: #('Ruth' 'Babe' '456 Mudville Flats');    add: #('Smith' 'John' '12/5 Park Ave');    add: #('Jexon' 'John' '5 Baverli Hills');    add: #('Adams' 'John' '1 Hell str');    add: #('Taylor' 'Babe' '2a/35 Deribas str');    add: #('Greg' 'Voss' '12345 the USA');    add: #('Ivanov' 'Nazar' 'Kyiv, Main Str 25');    add: #('Koval' 'Bohdan' 'Lviv, Freedom Ave 12');    add: #('Shevchenko' 'Nazar' 'Kharkiv, Central Park 3');    add: #('Petrenko' 'Nazar' 'Odesa, Sea St 8').Кожен рядок додає масив із трьох полів: прізвище, ім’я та адреса.Після додавання всі записи автоматично впорядковуються за прізвищем.""| s w |s := WriteStream on: String new.AddressBook do: [:x |     x do: [:y | s nextPutAll: y; tab; tab.].    s cr.].w := Workspace openLabel: 'My Address Book'.w contents: s contents.Тут відбувається кілька перетворень:1. WriteStream on: String new створює потік запису, щоб поступово формувати текстовий рядок.2. Цикл AddressBook do: перебирає кожен запис (масив) у книзі.3. Внутрішній цикл x do: перебирає елементи всередині кожного запису (тобто прізвище, імʼя, адресу).4. s nextPutAll: y; tab; tab. додає текст і вставляє табуляцію між елементами.5. s cr — переносить рядок.Потім створюється нове вікно Workspace, у якому виводиться готовий текст.""| firstNames duplicates |firstNames := Bag new.AddressBook do: [:entry | firstNames add: (entry at: 2)].duplicates := firstNames select: [:name | (firstNames occurrencesOf: name) > 1].duplicates := duplicates asSet asSortedCollection.Bag — це ""торба"", яка дозволяє зберігати повторювані елементи (на відміну від Set).У перший цикл додаються всі імена з кожного запису (другий елемент масиву).Потім обираються лише ті імена, які зустрічаються більше одного разу.asSet — перетворює торбу на множину (прибирає дублікати).asSortedCollection — сортує отримані імена за алфавітом.""Власні варіанти використання та перетворення колекцій:""1. Пошук за містом""AddressBook select: [:entry | (entry at: 3) includesSubstring: 'Kyiv'].""2. Заміна імені Nazar на Nazarii""AddressBook do: [:entry | (entry at: 2) = 'Nazar' ifTrue: [ entry at: 2 put: 'Nazarii' ]].""3. Унікальні імена""(AddressBook collect: [:entry | entry at: 2]) asSet.""------ ДОДАВАННЯ АДРЕС  Можливо, додавання записів до AddressBook за допомогою явного програмування   виглядає не надто привабливо. Використайте з цією метою діалоги "| a b c | a := UIManager default request: 'Input first name'.b := UIManager default request: 'Input second name'.c := UIManager default request: 'Input address'.a isNil | b isNil | c isNil ifFalse: [ AddressBook add: (Array with:a with:b with:c)]."Додайте до книги декілька нових записів, знову видрукуйте її. "                                    " Поміркуйте, як зробити зручнішим звертання до діалогу додавання адрес та друку адресної книги. ""Що станеться, якщо виконати наступний код? Випробуйте. "    Smalltalk globals removeKey:#AddressBook."Відповідь: Видалиться ключ #AddressBook." "------ ПЕРЕТВОРЕННЯ (ПЕРЕВТІЛЕННЯ) ОБ'ЄКТІВ   Виконайте за допомогою Do It. " | a b c|    a := OrderedCollection new.    b := Cylinder  new.    c := Array with: a with: b with: b.    Transcript show: 'Old Array is = '.    c do: [ :x | Transcript show: '     '. x printOn: Transcript ].    Transcript cr.    a become: b.    Transcript show: 'New Array is = '.    c do: [ :x | Transcript show: '     '. x printOn: Transcript ].    Transcript cr; show:' '. "Unknown variable"" Поясніть дію методу become:. Чи можна замість нього користуватися звичайним присвоєнням? Наведіть власні приклади. ""Відповідь: Він міняє всі посилання на два об’єкти місцями у всій системі.    Не можна замість become використовувати звичайне присвоєння, адже такого ефекту не можливо буде досягнути."