OmEntry {
	#tags : {
		#timestamp : DateAndTime [ '2025-10-04T20:53:53.069+03:00' ],
		#self : OmReference [ '1' ]
	},
	#content : '"--------------------------------------------------------------------------------------\r*                      ЛАБОРОТОРНА РОБОТА 3\r*                 Тема: КЛАСИ ТА МЕТОДИ. КОЛЕКЦІЇ\r*\r*  Завдання до лабораторної роботи:\r*     1. Виконайте наведені нижче приклади, збережіть і поясніть отримані результати.\r*     2. Випробуйте різноманітні способи додавання нових класів до системи.\r*     3. Навчіться доповнювати функціональність класів.\r*     4. Випробуйте методи опрацювання колекцій.\r*\r\r    Виконайте за допомогою <Print it> \r\r ------ ПРИНАЛЕЖНІСТЬ КЛАСОВІ, ІЄРАРХІЯ КЛАСІВ\r"\r    #(Francesca Jackie Marisa Bree) class. "Array"\r    (#(Francesca Jackie Marisa Bree) at:2) class. "ByteSymbol"\r    \'Rakesh Vijay Charles Daniel Tyler\' class. "ByteString"\r    (\'Rakesh Vijay Charles Daniel Tyler\' at:2) class. "Character (a)"\r    World class . "WorldMorph"\r    Magnitude class. "Magnitude class"\r    Magnitude class class. "Metaclass"\r    nil class. "UndefinedObject"\r    5 species. "SmallInteger"\r    123456789000 species. "SmallInteger"\r    #aName species. "ByteString"\r " Яка різниця між повідомленнями class i species ? \r   Відповідь: \r\tclass – це «хто я є?»\r\tspecies – це «якого типу нові колекції я породжую?»\r\r    Випробуйте різні способи відкривання браузера класів: за допомогою меню чи програмно \r     Виконайте за допомогою <Do it>\r"\r    ClyFullBrowserMorph open. \r    ClyFullBrowserMorph openOnClass: Date. \r    ClyFullBrowserMorph openOnClass: VolumeShape  selector:  #volume. \r\r" ------ МЕТОДИ КЛАСУ, КОНСТРУКТОРИ\r  Виконайте за допомогою <Print It>. Запропонуйте власні приклади. "\r\r    Array new: 10. "#(nil nil nil nil nil nil nil nil nil nil)"        \r    OrderedCollection  new. "an OrderedCollection()"\r    Date today. "29 September 2025"\r    Time now. "10:28:52.422 am"\r    UIManager default  request:\'How are you?\' initialAnswer:\'I\'\'m fine!\'. "\'I\'\'m fine!\'"\r    Integer readFrom: \'2013  1925\'. "2013"\r    Integer primesUpTo: 100. "#(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97)"\r    Rectangle origin:0@0 corner:200@100. "(0@0) corner: (200@100)"\r    Date nameOfMonth:12. "#December"\r    Date dayOfWeek: #Friday. "6"\r    Date orthodoxEasterDateFor: 2022. "24 April 2022"\r\r"--- Мої приклади ---"\r\t3 factorial.  "<-- 6"\r\t(1 to: 5) sum.  "<-- 15"\r   \r"Інсталюйте вказані нижче МЕТОДИ КЛАСУ Date:\r  перенесіть копію тексту визначення методу з робочого вікна в браузер класів.\r\r\t\t*Інсталював необхідні методи*\r"\r\r"Знайдіть роки, коли святкування припадають на один день."\rstartYear := 1900.\rendYear := 2100.\rmatchingYears := OrderedCollection new.\r\r(startYear to: endYear) do: [:year |\r    | orthodoxDate westernDate |\r    orthodoxDate := Date orthodoxEasterDateFor: year.\r    westernDate := Date easterDateFor: year.\r    (orthodoxDate = westernDate) ifTrue: [\r        matchingYears add: year.\r    ].\r].\r\rmatchingYears " <-- an OrderedCollection(1906 1909 1912 1915 1916 1919 1922 1930 1933 1936\r \t\t\t\t\t 1939 1942 1943 1946 1950 1953 1957 1960 1963 1966 1974 1977 1980 1984 1987 \r\t\t\t\t\t 1990 2001 2004 2007 2010 2011 2014 2017 2025 2028 2031 2034 2037 2038 2041\r\t\t\t\t\t 2045 2048 2052 2055 2058 2061 2069 2071 2072 2075 2079 2082 2085 2091 2095 2096 2099)"\r\r\r" ------ РЕКУРСІЯ\r  Додайте до класу Integer і випробуйте різні методи обчислення чисел  Фібоначчі.\r  Запропонуйте власні. Порівняйте їхню ефективність.      \r  Перед випробуванням fibonacci ЗБЕРЕЖІТЬ ІМІДЖ СИСТЕМИ! Він може зайняти Ваш комп на тиждень.  "\r\r3 fibStart: 1 with: 10  "<-- 12"\r4 fibo "<-- 5"\r12 fibonacci "<-- 233"\r\r\r"\r==============\rВласні методи:\r==============\r\r- Метод 1:\rInteger >> factorial\r    ""Обчислення факторіалу числа""\r    ^ self <= 1 ifTrue: [1] ifFalse: [self * (self - 1) factorial].\r\r- Метод 2:\rInteger >> sumTo\r    ""Сума всіх чисел від 1 до self""\r    | sum i |\r    sum := 0.\r    1 to: self do: [:i | sum := sum + i].\r    ^ sum.\r"\r\r"\rПояснення: <fibStart:with:>\rРекурсивний метод, який обчислює n-те число Фібоначчі, використовуючи два акумулятори: n1 (попереднє) і n2 (пред-попереднє).\rРекурсія: (self - 1) fibStart: n1+n2 with: n1 → наступний крок отримує нове попереднє число як суму двох попередніх.\r\rДуже швидкий для будь-якого n, навіть великого. Не обчислює одні й ті ж значення повторно → O(n). \rПам’яті потрібно лише для стеку рекурсії (глибина n).\r\rПояснення: <fibo>\rПроста обгортка над <fibStart:with:.>\r\rПовністю така ж, як у fibStart:with:. Зручно викликати без ручного передавання початкових чисел.\r\rПояснення: <fibonacci>\rКласична рекурсія: F(n) = F(n-1) + F(n-2).\r\rДуже повільний для великих n. Обчислює одні й ті ж значення багато разів → експоненційна складність O(2ⁿ). \rМоже сильно навантажити процесор і стек викликів.\r"\r\r"------------------------------------------------------------------------------------\r ------ СТВОРЕННЯ, ОПРАЦЮВАННЯ КОЛЕКЦІЙ\r  У текстовому файлі записано інформацію про матрицю цілих чисел: розміри\r  матриці в першому рядку файла, у всіх наступних рядках - рядки матриці.}\r  Прочитати матрицю, знайти максимальні елементи кожного рядка і зберегти\r  їх у файлі. Надрукувати максимальний елемент цілої матриці."\r\r"Наведений нижче код можна виконати безпосередньо в робочому вікні,\r проте,  доцільно зробити його методом власного навчального класу."\r\r| matr fStream fName n m mMatr mLines |\r        "Вибір файла за допомогою діалогу"\r    (fName:=UIManager default\r\t\t\tchooseFullFileNameMatching: nil \r\t\t\tlabel: \'Виберіть файл з числовими даними\' ) isNil\r        ifTrue: [ ^\'Ви не вибрали файла\' ]. \r        fStream := fName asFileReference readStream.\r\t        "Введення даних"\r \t    n := Integer readFrom: fStream.  \r\t    matr := Array new: n.\r\t    m := Integer readFrom: fStream.\r\t    matr := matr collect: [ :x | Array new: m ]. \r\t    1 to: n do: [ :i |  fStream nextLine.\r \t\t     matr at: i put: (\r\t\t\t\t (matr at: i) collect: [ :x |  \r\t\t\t\t\t\tInteger readFrom: fStream. ]\r\t\t\t\t\t )\t ].\r    fStream close. matr inspect.\r        "Обчислення максимальних елементів"\r    mLines:=matr collect: [ :r | r inject: (r at: 1) into: [ :x :y | x max: y] ].\r    mMatr:=mLines at: 1.\r    mLines do: [ :x | x > mMatr ifTrue: [ mMatr := x ] ].\r        "Побудова імені файла результатів, збереження"\r    fName at: fName size - 4 put: $_ .\r    fStream := fName asFileReference writeStream.\r    mLines do: [ :x | x printOn: fStream. fStream cr ].\r    fStream close.\r    ^mMatr .  \r\r" Поясніть код, наведений вище (кожне повідомлення!):\r\r\t| matr fStream fName n m mMatr mLines | <-- Локальні змінні\r\r\tВідкриваємо діалог вибору файлу. Якщо користувач не вибрав файл – повертаємо повідомлення:\r\t(fName := UIManager default\r\t    chooseFullFileNameMatching: nil\r\t    label: \'Виберіть файл з числовими даними\') isNil\r\t    ifTrue: [ ^\'Ви не вибрали файла\' ].\r\r\tfStream := fName asFileReference readStream. <-- Відкриваємо потік для читання файлу\r\tn := Integer readFrom: fStream. <-- Читаємо перше число з файлу – кількість рядків матриці\r\tmatr := Array new: n. <-- Створюємо масив для рядків матриці:\r\tm := Integer readFrom: fStream. <-- Читаємо друге число з файлу – кількість стовпців матриці\r\tmatr := matr collect: [:x | Array new: m]. <-- Заповнюємо кожен рядок новим масивом стовпців (масив масивів)\r\r\tПроходимо по кожному рядку:\r\t - пропускаємо порожню або заголовочну лінію\r\t - читаємо числа рядка і записуємо у відповідний рядок матриці:\r\t1 to: n do: [:i |\r\t    fStream nextLine.\r\t    matr at: i put: (\r\t        (matr at: i) collect: [:x | Integer readFrom: fStream]\r\t    )].\r\r\tfStream close. <-- Закриваємо потік після читання\r\tmatr inspect. <-- Відкриваємо інспектор для перегляду матриці\r\r\tОбчислюємо максимум у кожному рядку:\r\t - inject: використовується для проходження елементів\r\t - функція x max: y повертає більший елемент\r\tmLines := matr collect: [:r | r inject: (r at: 1) into: [:x :y | x max: y]].\r\r\tЗнаходимо загальний максимум матриці:\r\t - проходимо по максимумам рядків і оновлюємо mMatr:\r\tmMatr := mLines at: 1.\r\tmLines do: [:x | x > mMatr ifTrue: [ mMatr := x ]].\r\r\tfName at: fName size - 4 put: $_. <-- Змінюємо розширення файлу для збереження результатів\r\tfStream := fName asFileReference writeStream. <-- Відкриваємо потік для запису у файл\r\tmLines do: [:x | x printOn: fStream. fStream cr]. <-- Записуємо максимуми рядків у файл, кожен на новий рядок\r\tfStream close. <-- Закриваємо файл після запису\r\t^ mMatr. <-- Повертаємо максимальний елемент всієї матриці\r\r   Як замінити масивмасивів на екземпляр класу Matrix?:\r\tMatrix замінює масив масивів, тобто ми маємо одну структуру n × m. До елементів доступ через at: i at: j.\r\tЦе дозволяє компактно читати дані з файлу, знаходити максимуми і записувати результати, не створюючи додаткових масивів рядків:\r\t\r\t| matr fStream n m mMatr |\r\r\tВідкриваємо файл та читаємо розміри:\r\tfStream := \'file.txt\' asFileReference readStream.\r\tn := Integer readFrom: fStream.\r\tm := Integer readFrom: fStream.\r\r\tСтворюємо і заповнюємо матрицю:\r\tmatr := Matrix rows: n columns: m.\r\t1 to: n do: [:i | 1 to: m do: [:j | matr at: i at: j put: Integer readFrom: fStream]].\r\tfStream close.\r\r\tЗнаходимо загальний максимум:\r\tmMatr := (1 to: n) inject: 0 into: [:maxRow :i | maxRow max: ((1 to: m) inject: 0 into: [:maxCol :j | maxCol max: (matr at: i at: j)])].\r\t^ mMatr.\r\r======================================================\r\r ------ АДРЕСНА КНИГА\r Приклад створення і використання адресної книги, описаний у одній з лекцій. \r Пригадуєте, спочатку оголошуємо глобальну змінну, що міститиме впорядковану \r колекцію масивів з трьох рядків. Спосіб порівняння описує бінарний блок.    "\r\r    Smalltalk globals at: #AddressBook\r              put:(SortedCollection sortBlock:[:a :b | (a at:1)<=(b at:1)]).\r\r" * --- Тепер до книги можна додавати записи. "\r\r    AddressBook\r            add: #(\'Ruth\' \'Babe\' \'456 Mudville Flats\');\r            add: #(\'Smith\' \'John\' \'12/5 Park Ave\');\r            add: #(\'Jexon\' \'John\' \'5 Baverli Hills\');\r            add: #(\'Adams\' \'John\' \'1 Hell str\');\r            add: #(\'Taylor\' \'Babe\' \'2a/35 Deribas str\');\r            add: #(\'Greg\' \'Voss\' \'12345 the USA\')."<-- #(\'Greg\' \'Voss\' \'12345 the USA\')"\r\r" * --- Додайте власні записи. Видрукуйте вміст книги (код запропоновано нижче)."\r   | s w |  s := WriteStream on: String new.\r\r    AddressBook do:[:x | x do:\r        [ :y | s nextPutAll: y; tab; tab.].\r        s cr. ]. "<-- a SortedCollection(#(\'Adams\' \'John\' \'1 Hell str\') \r\t\t\t\t\t  #(\'Greg\' \'Voss\' \'12345 the USA\') #(\'Jexon\' \'John\' \'5 Baverli Hills\') \r\t\t\t\t\t  #(\'Ruth\' \'Babe\' \'456 Mudville Flats\') #(\'Smith\' \'John\' \'12/5 Park Ave\') \r\t\t\t\t\t  #(\'Taylor\' \'Babe\' \'2a/35 Deribas str\'))"\r\r\tAddressBook\r    add: #(\'Brown\' \'Alice\' \'7 Cherry Lane\');\r    add: #(\'White\' \'Bob\' \'15 Oak Street\');\r    add: #(\'Green\' \'Clara\' \'9 Pine Avenue\').\r\r\t  \r\ts := WriteStream on: String new.\r\tAddressBook do: [ :x | x do: [ :y | s nextPutAll: y; tab; tab. ] ] \r\t\r\t" Я трохи начудив з додаванням записів, тому ось такий результат:\r\ta SortedCollection(#(\'Adams\' \'John\' \'1 Hell str\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Greg\' \'Voss\' \'12345 the USA\') #(\'Jexon\' \'John\' \'5 Baverli Hills\') #(\'Oleh\' \'Chyzhov\' \'MyAddress 23\') #(\'Oleh\' \'Chyzhov\' \'MyAddress 23\') #(\'Oleh\' \'Chyzhov\' \'ofjidjf\') #(\'Oleh\' \'Chyzhov\' \'frjgirgjir\') #(\'Ruth\' \'Babe\' \'456 Mudville Flats\') #(\'Smith\' \'John\' \'12/5 Park Ave\') #(\'Taylor\' \'Babe\' \'2a/35 Deribas str\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'oleh\' \'chyzhov\' \'myaddress 23\'))"\r\r\r  w := Workspace openLabel: \'My Address Book\'.\r  w contents: s contents.\r\r" * ----  Наступне завдання - надрукувати список прізвищ людей з однаковими іменами. \r              Приклад демонструє різні способи перебору та перетворення колекцій."\r\r | firstNames duplicates |\r    firstNames:=Bag new.        "утворимо торбу імен"\r    AddressBook do: [ :entry | firstNames add: (entry at: 2) ]. "<-- a SortedCollection(#(\'Adams\' \'John\' \'1 Hell str\') #(\'Greg\' \'Voss\' \'12345 the USA\') \r\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t#(\'Jexon\' \'John\' \'5 Baverli Hills\') #(\'Ruth\' \'Babe\' \'456 Mudville Flats\') #(\'Smith\' \'John\' \'12/5 Park Ave\')\r\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t#(\'Taylor\' \'Babe\' \'2a/35 Deribas str\'))"\r\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r        "виберемо ті імена, які зустрічаються більше одного разу"\r    duplicates:=firstNames select:\r        [ :name | (firstNames occurrencesOf: name)>1 ]. "<-- a Bag(\'John\' \'John\' \'John\' \'Babe\' \'Babe\')"\r            "і впорядкуємо їх"\r    duplicates:=duplicates asSet asSortedCollection. "<-- a SortedCollection(\'Babe\' \'John\')"\r        "друкуємо імена та відповідні їм прізвища"\r    duplicates do: [ :first | first printOn: Transcript. Transcript show:\'==>\'.\r        AddressBook do: [ :entry | (entry at: 2)=first\r            ifTrue: [ Transcript show:\' \'. (entry at: 1) printOn: Transcript ] ].\r        Transcript cr ]. Transcript show:\' \'.\r\r" Поясніть перетворення, що відбуваються в цьому фрагменті:\r\tBag — дозволяє зберігати елементи з повтореннями.\r\tselect: — фільтрує колекцію, залишаючи тільки елементи, що задовольняють умові (тут, occurrencesOf: > 1).\r\tasSet — видаляє дублікати після фільтрації.\r\tasSortedCollection — сортує результати для зручного виводу.\r\tdo: — ітерує колекцію і виконує дію (друк у Transcript).\r\r   Запропонуйте власні варіанти використання та перетворення колекцій. \r \r  Оформіть запропоновані вище фрагменти як методи навчального класу:\r\tObject subclass: #AddressBookUtils\r    \tinstanceVariableNames: \'\'\r    \tclassVariableNames: \'\'\r    \tpoolDictionaries: \'\'\r    \tcategory: \'Training-Examples\'.\r\r"\r\r\r" ------ ДОДАВАННЯ АДРЕС\r  Можливо, додавання записів до AddressBook за допомогою явного програмування \r  виглядає не надто привабливо. Використайте з цією метою діалоги "\r\r| a b c | \ra := UIManager default request: \'Input first name\'.\rb := UIManager default request: \'Input second name\'.\rc := UIManager default request: \'Input address\'.\ra isNil | b isNil | c isNil ifFalse: [ AddressBook add: (Array with:a with:b with:c)]. "<-- #(\'Oleh\' \'Chyzhov\' \'MyAddress 23\')"\r\r" Додайте до книги декілька нових записів, знову видрукуйте її. "\r"Через це в книзі так багато записів:"\r[\r    | a b c |\r    a := UIManager default request: \'Input first name\'.\r    a isNil ifTrue: [ ^self ].  "Cancel завершує цикл"\r\r    b := UIManager default request: \'Input second name\'.\r    b isNil ifTrue: [ ^self ].\r\r    c := UIManager default request: \'Input address\'.\r    c isNil ifTrue: [ ^self ].\r\r    AddressBook add: (Array with: a with: b with: c).\r] repeat.\r\r\ts := WriteStream on: String new.\r\tAddressBook do: [ :x | x do: [ :y | s nextPutAll: y; tab; tab. ] ] "<--  \r\ta SortedCollection(\r\t#(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') \r\t#(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') \r\t#(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'Adams\' \'John\' \'1 Hell str\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') \r\t#(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') \r\t#(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Greg\' \'Voss\' \'12345 the USA\') #(\'Jexon\' \'John\' \'5 Baverli Hills\') \r\t#(\'Oleh\' \'Chyzhov\' \'MyAddress 23\') #(\'Oleh\' \'Chyzhov\' \'MyAddress 23\') #(\'Oleh\' \'Chyzhov\' \'ofjidjf\') #(\'Oleh\' \'Chyzhov\' \'frjgirgjir\') #(\'Ruth\' \'Babe\' \'456 Mudville Flats\') \r\t#(\'Smith\' \'John\' \'12/5 Park Ave\') #(\'Taylor\' \'Babe\' \'2a/35 Deribas str\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'White\' \'Bob\' \'15 Oak Street\') \r\t#(\'White\' \'Bob\' \'15 Oak Street\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'oleh\' \'chyzhov\' \'myaddress 23\'))"\r\r" Поміркуйте, як зробити зручнішим звертання до діалогу додавання адрес та друку адресної книги. \rМожна винести логіку у клас: один метод відповідатиме за введення одного запису. Інший — за введення кількох записів. Ще інший — за друк книги"\r\r" Що станеться, якщо виконати наступний код? Випробуйте. "\r    Smalltalk globals removeKey:#AddressBook. "<-- з глобального словника Smalltalk globals буде видалено ключ #AddressBook і, відповідно, саму твою колекцію (адресну книгу)."\r\r "------ ПЕРЕТВОРЕННЯ (ПЕРЕВТІЛЕННЯ) ОБ\'ЄКТІВ\r   Виконайте за допомогою Do It. "\r\r | a b c|\r    a := OrderedCollection new.\r    b := Cylinder new.\r    c := Array with: a with: b with: b.\r    Transcript show: \'Old Array is = \'.\r    c do: [ :x | Transcript show: \'     \'. x printOn: Transcript ].\r    Transcript cr.\r    a become: b.\r    Transcript show: \'New Array is = \'.\r    c do: [ :x | Transcript show: \'     \'. x printOn: Transcript ].\r    Transcript cr; show:\' \'. "<-- Unknown variable"\r\r" Поясніть дію методу become:. Чи можна замість нього користуватися звичайним присвоєнням? Наведіть власні приклади. "\r\r" Метод become: міняє всі посилання на два об’єкти місцями у всій системі.  \r  Це відрізняється від простого присвоєння, яке змінює лише одну змінну.  \r  У прикладі масив c до become: містив [OrderedCollection, Cylinder, Cylinder],  \r  а після become: став [Cylinder, OrderedCollection, OrderedCollection].  \r  Звичайним присвоєнням такого ефекту не досягти. "\r\r\r\r\r\r\r\r'
}OmEntry {
	#tags : {
		#timestamp : DateAndTime [ '2025-10-04T21:01:15.39+03:00' ],
		#self : OmReference [ '2' ]
	},
	#content : '"--------------------------------------------------------------------------------------\r*                      ЛАБОРОТОРНА РОБОТА 3\r*                 Тема: КЛАСИ ТА МЕТОДИ. КОЛЕКЦІЇ\r*\r*  Завдання до лабораторної роботи:\r*     1. Виконайте наведені нижче приклади, збережіть і поясніть отримані результати.\r*     2. Випробуйте різноманітні способи додавання нових класів до системи.\r*     3. Навчіться доповнювати функціональність класів.\r*     4. Випробуйте методи опрацювання колекцій.\r*\r\r    Виконайте за допомогою <Print it> \r\r ------ ПРИНАЛЕЖНІСТЬ КЛАСОВІ, ІЄРАРХІЯ КЛАСІВ\r"\r    #(Francesca Jackie Marisa Bree) class. "Array"\r    (#(Francesca Jackie Marisa Bree) at:2) class. "ByteSymbol"\r    \'Rakesh Vijay Charles Daniel Tyler\' class. "ByteString"\r    (\'Rakesh Vijay Charles Daniel Tyler\' at:2) class. "Character (a)"\r    World class . "WorldMorph"\r    Magnitude class. "Magnitude class"\r    Magnitude class class. "Metaclass"\r    nil class. "UndefinedObject"\r    5 species. "SmallInteger"\r    123456789000 species. "SmallInteger"\r    #aName species. "ByteString"\r " Яка різниця між повідомленнями class i species ? \r   Відповідь: \r\tclass – це «хто я є?»\r\tspecies – це «якого типу нові колекції я породжую?»\r\r    Випробуйте різні способи відкривання браузера класів: за допомогою меню чи програмно \r     Виконайте за допомогою <Do it>\r"\r    ClyFullBrowserMorph open. \r    ClyFullBrowserMorph openOnClass: Date. \r    ClyFullBrowserMorph openOnClass: VolumeShape  selector:  #volume. \r\r" ------ МЕТОДИ КЛАСУ, КОНСТРУКТОРИ\r  Виконайте за допомогою <Print It>. Запропонуйте власні приклади. "\r\r    Array new: 10. "#(nil nil nil nil nil nil nil nil nil nil)"        \r    OrderedCollection  new. "an OrderedCollection()"\r    Date today. "29 September 2025"\r    Time now. "10:28:52.422 am"\r    UIManager default  request:\'How are you?\' initialAnswer:\'I\'\'m fine!\'. "\'I\'\'m fine!\'"\r    Integer readFrom: \'2013  1925\'. "2013"\r    Integer primesUpTo: 100. "#(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97)"\r    Rectangle origin:0@0 corner:200@100. "(0@0) corner: (200@100)"\r    Date nameOfMonth:12. "#December"\r    Date dayOfWeek: #Friday. "6"\r    Date orthodoxEasterDateFor: 2022. "24 April 2022"\r\r"--- Мої приклади ---"\r\t3 factorial.  "<-- 6"\r\t(1 to: 5) sum.  "<-- 15"\r   \r"Інсталюйте вказані нижче МЕТОДИ КЛАСУ Date:\r  перенесіть копію тексту визначення методу з робочого вікна в браузер класів.\r\r""!Date class methodsFor: \'specific inquiries\' stamp: \'CamilloBruni 8/22/2013 19:47\'!""\r\rorthodoxEasterDateFor: year\r ""  compute the easter date according to the rules of the orthodox calendar.\r    source:       http://www.smart.net/~mmontes/ortheast.html   ""\r     | r1 r2 r3 r4 ra rb r5 rc date |\r\r    r1 := year \\\\ 19.\r    r2 := year \\\\ 4.\r    r3 := year \\\\ 7.\r    ra := 19*r1 + 16.\r    r4 := ra \\\\ 30.\r    rb := r2 + r2 + (4*r3) + (6*r4).\r    r5 := rb \\\\ 7.\r    rc := r4 + r5.\r    date := self year: year month: 4 day: 3.\r    ^date addDays: rc.\r""--------------------------------------------------------------------------------------""\r""!Date class methodsFor: \'specific inquiries\' stamp: \'CamilloBruni 8/22/2013 19:48\'!""\r\reasterDateFor: year\r ""  compute the easter date.\r    source: Physikalisch-Technische Bundesanstalt Braunschweig.\r    Lichtenberg, H.: Zur Interpretation der Gaussschen Osterformel und ihrer Ausnahmeregeln, Historia Mathematica 24 (1997), pp. 441-444\r      http://www.ptb.de/de/org/4/44/441/oste.htm  ""\r\r  | k m s a d r og sz oe day |\r\r  k := year // 100.\r  m := 15 + (3*k + 3//4) - (8*k + 13//25).\r   s := 2 - (3*k + 3// 4).\r  a := year \\\\ 19.\r  d := 19*a + m \\\\ 30.\r  r := d//29 + ((d//28) - (d//29)* (a// 11)).\r\r  og := 21 + d - r.\r  sz := 7 - (year//4 + year + s\\\\7).\r  oe := 7 - (og - sz\\\\7).\r  day := og + oe.\r  ^day <= 31\r    ifTrue: [ Date year: year month: 3 day: day ]\r    ifFalse: [ Date year: year month: 4 day: day - 31 ].\r"\r\r"Знайдіть роки, коли святкування припадають на один день."\rstartYear := 1900.\rendYear := 2100.\rmatchingYears := OrderedCollection new.\r\r(startYear to: endYear) do: [:year |\r    | orthodoxDate westernDate |\r    orthodoxDate := Date orthodoxEasterDateFor: year.\r    westernDate := Date easterDateFor: year.\r    (orthodoxDate = westernDate) ifTrue: [\r        matchingYears add: year.\r    ].\r].\r\rmatchingYears " <-- an OrderedCollection(1906 1909 1912 1915 1916 1919 1922 1930 1933 1936\r \t\t\t\t\t 1939 1942 1943 1946 1950 1953 1957 1960 1963 1966 1974 1977 1980 1984 1987 \r\t\t\t\t\t 1990 2001 2004 2007 2010 2011 2014 2017 2025 2028 2031 2034 2037 2038 2041\r\t\t\t\t\t 2045 2048 2052 2055 2058 2061 2069 2071 2072 2075 2079 2082 2085 2091 2095 2096 2099)"\r\r\r" ------ РЕКУРСІЯ\r  Додайте до класу Integer і випробуйте різні методи обчислення чисел  Фібоначчі.\r  Запропонуйте власні. Порівняйте їхню ефективність.      \r  Перед випробуванням fibonacci ЗБЕРЕЖІТЬ ІМІДЖ СИСТЕМИ! Він може зайняти Ваш комп на тиждень.  "\r\r3 fibStart: 1 with: 10  "<-- 12"\r4 fibo "<-- 5"\r12 fibonacci "<-- 233"\r\r\r"\r==============\rВласні методи:\r==============\r\r- Метод 1:\rInteger >> factorial\r    ""Обчислення факторіалу числа""\r    ^ self <= 1 ifTrue: [1] ifFalse: [self * (self - 1) factorial].\r\r- Метод 2:\rInteger >> sumTo\r    ""Сума всіх чисел від 1 до self""\r    | sum i |\r    sum := 0.\r    1 to: self do: [:i | sum := sum + i].\r    ^ sum.\r"\r\r"\rПояснення: <fibStart:with:>\rРекурсивний метод, який обчислює n-те число Фібоначчі, використовуючи два акумулятори: n1 (попереднє) і n2 (пред-попереднє).\rРекурсія: (self - 1) fibStart: n1+n2 with: n1 → наступний крок отримує нове попереднє число як суму двох попередніх.\r\rДуже швидкий для будь-якого n, навіть великого. Не обчислює одні й ті ж значення повторно → O(n). \rПам’яті потрібно лише для стеку рекурсії (глибина n).\r\rПояснення: <fibo>\rПроста обгортка над <fibStart:with:.>\r\rПовністю така ж, як у fibStart:with:. Зручно викликати без ручного передавання початкових чисел.\r\rПояснення: <fibonacci>\rКласична рекурсія: F(n) = F(n-1) + F(n-2).\r\rДуже повільний для великих n. Обчислює одні й ті ж значення багато разів → експоненційна складність O(2ⁿ). \rМоже сильно навантажити процесор і стек викликів.\r"\r\r"------------------------------------------------------------------------------------\r ------ СТВОРЕННЯ, ОПРАЦЮВАННЯ КОЛЕКЦІЙ\r  У текстовому файлі записано інформацію про матрицю цілих чисел: розміри\r  матриці в першому рядку файла, у всіх наступних рядках - рядки матриці.}\r  Прочитати матрицю, знайти максимальні елементи кожного рядка і зберегти\r  їх у файлі. Надрукувати максимальний елемент цілої матриці."\r\r"Наведений нижче код можна виконати безпосередньо в робочому вікні,\r проте,  доцільно зробити його методом власного навчального класу."\r\r| matr fStream fName n m mMatr mLines |\r        "Вибір файла за допомогою діалогу"\r    (fName:=UIManager default\r\t\t\tchooseFullFileNameMatching: nil \r\t\t\tlabel: \'Виберіть файл з числовими даними\' ) isNil\r        ifTrue: [ ^\'Ви не вибрали файла\' ]. \r        fStream := fName asFileReference readStream.\r\t        "Введення даних"\r \t    n := Integer readFrom: fStream.  \r\t    matr := Array new: n.\r\t    m := Integer readFrom: fStream.\r\t    matr := matr collect: [ :x | Array new: m ]. \r\t    1 to: n do: [ :i |  fStream nextLine.\r \t\t     matr at: i put: (\r\t\t\t\t (matr at: i) collect: [ :x |  \r\t\t\t\t\t\tInteger readFrom: fStream. ]\r\t\t\t\t\t )\t ].\r    fStream close. matr inspect.\r        "Обчислення максимальних елементів"\r    mLines:=matr collect: [ :r | r inject: (r at: 1) into: [ :x :y | x max: y] ].\r    mMatr:=mLines at: 1.\r    mLines do: [ :x | x > mMatr ifTrue: [ mMatr := x ] ].\r        "Побудова імені файла результатів, збереження"\r    fName at: fName size - 4 put: $_ .\r    fStream := fName asFileReference writeStream.\r    mLines do: [ :x | x printOn: fStream. fStream cr ].\r    fStream close.\r    ^mMatr .  \r\r" Поясніть код, наведений вище (кожне повідомлення!):\r\r\t| matr fStream fName n m mMatr mLines | <-- Локальні змінні\r\r\tВідкриваємо діалог вибору файлу. Якщо користувач не вибрав файл – повертаємо повідомлення:\r\t(fName := UIManager default\r\t    chooseFullFileNameMatching: nil\r\t    label: \'Виберіть файл з числовими даними\') isNil\r\t    ifTrue: [ ^\'Ви не вибрали файла\' ].\r\r\tfStream := fName asFileReference readStream. <-- Відкриваємо потік для читання файлу\r\tn := Integer readFrom: fStream. <-- Читаємо перше число з файлу – кількість рядків матриці\r\tmatr := Array new: n. <-- Створюємо масив для рядків матриці:\r\tm := Integer readFrom: fStream. <-- Читаємо друге число з файлу – кількість стовпців матриці\r\tmatr := matr collect: [:x | Array new: m]. <-- Заповнюємо кожен рядок новим масивом стовпців (масив масивів)\r\r\tПроходимо по кожному рядку:\r\t - пропускаємо порожню або заголовочну лінію\r\t - читаємо числа рядка і записуємо у відповідний рядок матриці:\r\t1 to: n do: [:i |\r\t    fStream nextLine.\r\t    matr at: i put: (\r\t        (matr at: i) collect: [:x | Integer readFrom: fStream]\r\t    )].\r\r\tfStream close. <-- Закриваємо потік після читання\r\tmatr inspect. <-- Відкриваємо інспектор для перегляду матриці\r\r\tОбчислюємо максимум у кожному рядку:\r\t - inject: використовується для проходження елементів\r\t - функція x max: y повертає більший елемент\r\tmLines := matr collect: [:r | r inject: (r at: 1) into: [:x :y | x max: y]].\r\r\tЗнаходимо загальний максимум матриці:\r\t - проходимо по максимумам рядків і оновлюємо mMatr:\r\tmMatr := mLines at: 1.\r\tmLines do: [:x | x > mMatr ifTrue: [ mMatr := x ]].\r\r\tfName at: fName size - 4 put: $_. <-- Змінюємо розширення файлу для збереження результатів\r\tfStream := fName asFileReference writeStream. <-- Відкриваємо потік для запису у файл\r\tmLines do: [:x | x printOn: fStream. fStream cr]. <-- Записуємо максимуми рядків у файл, кожен на новий рядок\r\tfStream close. <-- Закриваємо файл після запису\r\t^ mMatr. <-- Повертаємо максимальний елемент всієї матриці\r\r   Як замінити масивмасивів на екземпляр класу Matrix?:\r\tMatrix замінює масив масивів, тобто ми маємо одну структуру n × m. До елементів доступ через at: i at: j.\r\tЦе дозволяє компактно читати дані з файлу, знаходити максимуми і записувати результати, не створюючи додаткових масивів рядків:\r\t\r\t| matr fStream n m mMatr |\r\r\tВідкриваємо файл та читаємо розміри:\r\tfStream := \'file.txt\' asFileReference readStream.\r\tn := Integer readFrom: fStream.\r\tm := Integer readFrom: fStream.\r\r\tСтворюємо і заповнюємо матрицю:\r\tmatr := Matrix rows: n columns: m.\r\t1 to: n do: [:i | 1 to: m do: [:j | matr at: i at: j put: Integer readFrom: fStream]].\r\tfStream close.\r\r\tЗнаходимо загальний максимум:\r\tmMatr := (1 to: n) inject: 0 into: [:maxRow :i | maxRow max: ((1 to: m) inject: 0 into: [:maxCol :j | maxCol max: (matr at: i at: j)])].\r\t^ mMatr.\r\r======================================================\r\r ------ АДРЕСНА КНИГА\r Приклад створення і використання адресної книги, описаний у одній з лекцій. \r Пригадуєте, спочатку оголошуємо глобальну змінну, що міститиме впорядковану \r колекцію масивів з трьох рядків. Спосіб порівняння описує бінарний блок.    "\r\r    Smalltalk globals at: #AddressBook\r              put:(SortedCollection sortBlock:[:a :b | (a at:1)<=(b at:1)]).\r\r" * --- Тепер до книги можна додавати записи. "\r\r    AddressBook\r            add: #(\'Ruth\' \'Babe\' \'456 Mudville Flats\');\r            add: #(\'Smith\' \'John\' \'12/5 Park Ave\');\r            add: #(\'Jexon\' \'John\' \'5 Baverli Hills\');\r            add: #(\'Adams\' \'John\' \'1 Hell str\');\r            add: #(\'Taylor\' \'Babe\' \'2a/35 Deribas str\');\r            add: #(\'Greg\' \'Voss\' \'12345 the USA\')."<-- #(\'Greg\' \'Voss\' \'12345 the USA\')"\r\r" * --- Додайте власні записи. Видрукуйте вміст книги (код запропоновано нижче)."\r   | s w |  s := WriteStream on: String new.\r\r    AddressBook do:[:x | x do:\r        [ :y | s nextPutAll: y; tab; tab.].\r        s cr. ]. "<-- a SortedCollection(#(\'Adams\' \'John\' \'1 Hell str\') \r\t\t\t\t\t  #(\'Greg\' \'Voss\' \'12345 the USA\') #(\'Jexon\' \'John\' \'5 Baverli Hills\') \r\t\t\t\t\t  #(\'Ruth\' \'Babe\' \'456 Mudville Flats\') #(\'Smith\' \'John\' \'12/5 Park Ave\') \r\t\t\t\t\t  #(\'Taylor\' \'Babe\' \'2a/35 Deribas str\'))"\r\r\tAddressBook\r    add: #(\'Brown\' \'Alice\' \'7 Cherry Lane\');\r    add: #(\'White\' \'Bob\' \'15 Oak Street\');\r    add: #(\'Green\' \'Clara\' \'9 Pine Avenue\').\r\r\t  \r\ts := WriteStream on: String new.\r\tAddressBook do: [ :x | x do: [ :y | s nextPutAll: y; tab; tab. ] ] \r\t\r\t" Я трохи начудив з додаванням записів, тому ось такий результат:\r\ta SortedCollection(#(\'Adams\' \'John\' \'1 Hell str\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Greg\' \'Voss\' \'12345 the USA\') #(\'Jexon\' \'John\' \'5 Baverli Hills\') #(\'Oleh\' \'Chyzhov\' \'MyAddress 23\') #(\'Oleh\' \'Chyzhov\' \'MyAddress 23\') #(\'Oleh\' \'Chyzhov\' \'ofjidjf\') #(\'Oleh\' \'Chyzhov\' \'frjgirgjir\') #(\'Ruth\' \'Babe\' \'456 Mudville Flats\') #(\'Smith\' \'John\' \'12/5 Park Ave\') #(\'Taylor\' \'Babe\' \'2a/35 Deribas str\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'oleh\' \'chyzhov\' \'myaddress 23\'))"\r\r\r  w := Workspace openLabel: \'My Address Book\'.\r  w contents: s contents.\r\r" * ----  Наступне завдання - надрукувати список прізвищ людей з однаковими іменами. \r              Приклад демонструє різні способи перебору та перетворення колекцій."\r\r | firstNames duplicates |\r    firstNames:=Bag new.        "утворимо торбу імен"\r    AddressBook do: [ :entry | firstNames add: (entry at: 2) ]. "<-- a SortedCollection(#(\'Adams\' \'John\' \'1 Hell str\') #(\'Greg\' \'Voss\' \'12345 the USA\') \r\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t#(\'Jexon\' \'John\' \'5 Baverli Hills\') #(\'Ruth\' \'Babe\' \'456 Mudville Flats\') #(\'Smith\' \'John\' \'12/5 Park Ave\')\r\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t#(\'Taylor\' \'Babe\' \'2a/35 Deribas str\'))"\r\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r        "виберемо ті імена, які зустрічаються більше одного разу"\r    duplicates:=firstNames select:\r        [ :name | (firstNames occurrencesOf: name)>1 ]. "<-- a Bag(\'John\' \'John\' \'John\' \'Babe\' \'Babe\')"\r            "і впорядкуємо їх"\r    duplicates:=duplicates asSet asSortedCollection. "<-- a SortedCollection(\'Babe\' \'John\')"\r        "друкуємо імена та відповідні їм прізвища"\r    duplicates do: [ :first | first printOn: Transcript. Transcript show:\'==>\'.\r        AddressBook do: [ :entry | (entry at: 2)=first\r            ifTrue: [ Transcript show:\' \'. (entry at: 1) printOn: Transcript ] ].\r        Transcript cr ]. Transcript show:\' \'.\r\r" Поясніть перетворення, що відбуваються в цьому фрагменті:\r\tBag — дозволяє зберігати елементи з повтореннями.\r\tselect: — фільтрує колекцію, залишаючи тільки елементи, що задовольняють умові (тут, occurrencesOf: > 1).\r\tasSet — видаляє дублікати після фільтрації.\r\tasSortedCollection — сортує результати для зручного виводу.\r\tdo: — ітерує колекцію і виконує дію (друк у Transcript).\r\r   Запропонуйте власні варіанти використання та перетворення колекцій. \r \r  Оформіть запропоновані вище фрагменти як методи навчального класу:\r\tObject subclass: #AddressBookUtils\r    \tinstanceVariableNames: \'\'\r    \tclassVariableNames: \'\'\r    \tpoolDictionaries: \'\'\r    \tcategory: \'Training-Examples\'.\r\r"\r\r\r" ------ ДОДАВАННЯ АДРЕС\r  Можливо, додавання записів до AddressBook за допомогою явного програмування \r  виглядає не надто привабливо. Використайте з цією метою діалоги "\r\r| a b c | \ra := UIManager default request: \'Input first name\'.\rb := UIManager default request: \'Input second name\'.\rc := UIManager default request: \'Input address\'.\ra isNil | b isNil | c isNil ifFalse: [ AddressBook add: (Array with:a with:b with:c)]. "<-- #(\'Oleh\' \'Chyzhov\' \'MyAddress 23\')"\r\r" Додайте до книги декілька нових записів, знову видрукуйте її. "\r"Через це в книзі так багато записів:"\r[\r    | a b c |\r    a := UIManager default request: \'Input first name\'.\r    a isNil ifTrue: [ ^self ].  "Cancel завершує цикл"\r\r    b := UIManager default request: \'Input second name\'.\r    b isNil ifTrue: [ ^self ].\r\r    c := UIManager default request: \'Input address\'.\r    c isNil ifTrue: [ ^self ].\r\r    AddressBook add: (Array with: a with: b with: c).\r] repeat.\r\r\ts := WriteStream on: String new.\r\tAddressBook do: [ :x | x do: [ :y | s nextPutAll: y; tab; tab. ] ] "<--  \r\ta SortedCollection(\r\t#(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') \r\t#(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') \r\t#(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'Adams\' \'John\' \'1 Hell str\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') \r\t#(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') \r\t#(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Greg\' \'Voss\' \'12345 the USA\') #(\'Jexon\' \'John\' \'5 Baverli Hills\') \r\t#(\'Oleh\' \'Chyzhov\' \'MyAddress 23\') #(\'Oleh\' \'Chyzhov\' \'MyAddress 23\') #(\'Oleh\' \'Chyzhov\' \'ofjidjf\') #(\'Oleh\' \'Chyzhov\' \'frjgirgjir\') #(\'Ruth\' \'Babe\' \'456 Mudville Flats\') \r\t#(\'Smith\' \'John\' \'12/5 Park Ave\') #(\'Taylor\' \'Babe\' \'2a/35 Deribas str\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'White\' \'Bob\' \'15 Oak Street\') \r\t#(\'White\' \'Bob\' \'15 Oak Street\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'oleh\' \'chyzhov\' \'myaddress 23\'))"\r\r" Поміркуйте, як зробити зручнішим звертання до діалогу додавання адрес та друку адресної книги. \rМожна винести логіку у клас: один метод відповідатиме за введення одного запису. Інший — за введення кількох записів. Ще інший — за друк книги"\r\r" Що станеться, якщо виконати наступний код? Випробуйте. "\r    Smalltalk globals removeKey:#AddressBook. "<-- з глобального словника Smalltalk globals буде видалено ключ #AddressBook і, відповідно, саму твою колекцію (адресну книгу)."\r\r "------ ПЕРЕТВОРЕННЯ (ПЕРЕВТІЛЕННЯ) ОБ\'ЄКТІВ\r   Виконайте за допомогою Do It. "\r\r | a b c|\r    a := OrderedCollection new.\r    b := Cylinder new.\r    c := Array with: a with: b with: b.\r    Transcript show: \'Old Array is = \'.\r    c do: [ :x | Transcript show: \'     \'. x printOn: Transcript ].\r    Transcript cr.\r    a become: b.\r    Transcript show: \'New Array is = \'.\r    c do: [ :x | Transcript show: \'     \'. x printOn: Transcript ].\r    Transcript cr; show:\' \'. "<-- Unknown variable"\r\r" Поясніть дію методу become:. Чи можна замість нього користуватися звичайним присвоєнням? Наведіть власні приклади. "\r\r" Метод become: міняє всі посилання на два об’єкти місцями у всій системі.  \r  Це відрізняється від простого присвоєння, яке змінює лише одну змінну.  \r  У прикладі масив c до become: містив [OrderedCollection, Cylinder, Cylinder],  \r  а після become: став [Cylinder, OrderedCollection, OrderedCollection].  \r  Звичайним присвоєнням такого ефекту не досягти. "\r\r\r\r\r\r\r\r'
}OmEntry {
	#tags : {
		#timestamp : DateAndTime [ '2025-10-04T21:07:09.913+03:00' ],
		#self : OmReference [ '3' ]
	},
	#content : '"--------------------------------------------------------------------------------------\r*                      ЛАБОРОТОРНА РОБОТА 3\r*                 Тема: КЛАСИ ТА МЕТОДИ. КОЛЕКЦІЇ\r*\r*  Завдання до лабораторної роботи:\r*     1. Виконайте наведені нижче приклади, збережіть і поясніть отримані результати.\r*     2. Випробуйте різноманітні способи додавання нових класів до системи.\r*     3. Навчіться доповнювати функціональність класів.\r*     4. Випробуйте методи опрацювання колекцій.\r*\r\r    Виконайте за допомогою <Print it> \r\r ------ ПРИНАЛЕЖНІСТЬ КЛАСОВІ, ІЄРАРХІЯ КЛАСІВ\r"\r    #(Francesca Jackie Marisa Bree) class. "Array"\r    (#(Francesca Jackie Marisa Bree) at:2) class. "ByteSymbol"\r    \'Rakesh Vijay Charles Daniel Tyler\' class. "ByteString"\r    (\'Rakesh Vijay Charles Daniel Tyler\' at:2) class. "Character (a)"\r    World class . "WorldMorph"\r    Magnitude class. "Magnitude class"\r    Magnitude class class. "Metaclass"\r    nil class. "UndefinedObject"\r    5 species. "SmallInteger"\r    123456789000 species. "SmallInteger"\r    #aName species. "ByteString"\r " Яка різниця між повідомленнями class i species ? \r   Відповідь: \r\tclass – це «хто я є?»\r\tspecies – це «якого типу нові колекції я породжую?»\r\r    Випробуйте різні способи відкривання браузера класів: за допомогою меню чи програмно \r     Виконайте за допомогою <Do it>\r"\r    ClyFullBrowserMorph open. \r    ClyFullBrowserMorph openOnClass: Date. \r    ClyFullBrowserMorph openOnClass: VolumeShape  selector:  #volume. \r\r" ------ МЕТОДИ КЛАСУ, КОНСТРУКТОРИ\r  Виконайте за допомогою <Print It>. Запропонуйте власні приклади. "\r\r    Array new: 10. "#(nil nil nil nil nil nil nil nil nil nil)"        \r    OrderedCollection  new. "an OrderedCollection()"\r    Date today. "29 September 2025"\r    Time now. "10:28:52.422 am"\r    UIManager default  request:\'How are you?\' initialAnswer:\'I\'\'m fine!\'. "\'I\'\'m fine!\'"\r    Integer readFrom: \'2013  1925\'. "2013"\r    Integer primesUpTo: 100. "#(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97)"\r    Rectangle origin:0@0 corner:200@100. "(0@0) corner: (200@100)"\r    Date nameOfMonth:12. "#December"\r    Date dayOfWeek: #Friday. "6"\r    Date orthodoxEasterDateFor: 2022. "24 April 2022"\r\r"--- Мої приклади ---"\r\t3 factorial.  "<-- 6"\r\t(1 to: 5) sum.  "<-- 15"\r   \r"Інсталюйте вказані нижче МЕТОДИ КЛАСУ Date:\r  перенесіть копію тексту визначення методу з робочого вікна в браузер класів.\r\r""!Date class methodsFor: \'specific inquiries\' stamp: \'CamilloBruni 8/22/2013 19:47\'!""\r\rorthodoxEasterDateFor: year\r ""  compute the easter date according to the rules of the orthodox calendar.\r    source:       http://www.smart.net/~mmontes/ortheast.html   ""\r     | r1 r2 r3 r4 ra rb r5 rc date |\r\r    r1 := year \\\\ 19.\r    r2 := year \\\\ 4.\r    r3 := year \\\\ 7.\r    ra := 19*r1 + 16.\r    r4 := ra \\\\ 30.\r    rb := r2 + r2 + (4*r3) + (6*r4).\r    r5 := rb \\\\ 7.\r    rc := r4 + r5.\r    date := self year: year month: 4 day: 3.\r    ^date addDays: rc.\r""--------------------------------------------------------------------------------------""\r""!Date class methodsFor: \'specific inquiries\' stamp: \'CamilloBruni 8/22/2013 19:48\'!""\r\reasterDateFor: year\r ""  compute the easter date.\r    source: Physikalisch-Technische Bundesanstalt Braunschweig.\r    Lichtenberg, H.: Zur Interpretation der Gaussschen Osterformel und ihrer Ausnahmeregeln, Historia Mathematica 24 (1997), pp. 441-444\r      http://www.ptb.de/de/org/4/44/441/oste.htm  ""\r\r  | k m s a d r og sz oe day |\r\r  k := year // 100.\r  m := 15 + (3*k + 3//4) - (8*k + 13//25).\r   s := 2 - (3*k + 3// 4).\r  a := year \\\\ 19.\r  d := 19*a + m \\\\ 30.\r  r := d//29 + ((d//28) - (d//29)* (a// 11)).\r\r  og := 21 + d - r.\r  sz := 7 - (year//4 + year + s\\\\7).\r  oe := 7 - (og - sz\\\\7).\r  day := og + oe.\r  ^day <= 31\r    ifTrue: [ Date year: year month: 3 day: day ]\r    ifFalse: [ Date year: year month: 4 day: day - 31 ].\r"\r\r"Знайдіть роки, коли святкування припадають на один день."\r\r\r" ------ РЕКУРСІЯ\r  Додайте до класу Integer і випробуйте різні методи обчислення чисел  Фібоначчі.\r  Запропонуйте власні. Порівняйте їхню ефективність.      \r  Перед випробуванням fibonacci ЗБЕРЕЖІТЬ ІМІДЖ СИСТЕМИ! Він може зайняти Ваш комп на тиждень.  "\r\r3 fibStart: 1 with: 10  "<-- 12"\r4 fibo "<-- 5"\r12 fibonacci "<-- 233"\r\r\r"\r==============\rВласні методи:\r==============\r\r- Метод 1:\rInteger >> factorial\r    ""Обчислення факторіалу числа""\r    ^ self <= 1 ifTrue: [1] ifFalse: [self * (self - 1) factorial].\r\r- Метод 2:\rInteger >> sumTo\r    ""Сума всіх чисел від 1 до self""\r    | sum i |\r    sum := 0.\r    1 to: self do: [:i | sum := sum + i].\r    ^ sum.\r"\r\r"\rПояснення: <fibStart:with:>\rРекурсивний метод, який обчислює n-те число Фібоначчі, використовуючи два акумулятори: n1 (попереднє) і n2 (пред-попереднє).\rРекурсія: (self - 1) fibStart: n1+n2 with: n1 → наступний крок отримує нове попереднє число як суму двох попередніх.\r\rДуже швидкий для будь-якого n, навіть великого. Не обчислює одні й ті ж значення повторно → O(n). \rПам’яті потрібно лише для стеку рекурсії (глибина n).\r\rПояснення: <fibo>\rПроста обгортка над <fibStart:with:.>\r\rПовністю така ж, як у fibStart:with:. Зручно викликати без ручного передавання початкових чисел.\r\rПояснення: <fibonacci>\rКласична рекурсія: F(n) = F(n-1) + F(n-2).\r\rДуже повільний для великих n. Обчислює одні й ті ж значення багато разів → експоненційна складність O(2ⁿ). \rМоже сильно навантажити процесор і стек викликів.\r"\r\r"------------------------------------------------------------------------------------\r ------ СТВОРЕННЯ, ОПРАЦЮВАННЯ КОЛЕКЦІЙ\r  У текстовому файлі записано інформацію про матрицю цілих чисел: розміри\r  матриці в першому рядку файла, у всіх наступних рядках - рядки матриці.}\r  Прочитати матрицю, знайти максимальні елементи кожного рядка і зберегти\r  їх у файлі. Надрукувати максимальний елемент цілої матриці."\r\r"Наведений нижче код можна виконати безпосередньо в робочому вікні,\r проте,  доцільно зробити його методом власного навчального класу."\r\r| matr fStream fName n m mMatr mLines |\r        "Вибір файла за допомогою діалогу"\r    (fName:=UIManager default\r\t\t\tchooseFullFileNameMatching: nil \r\t\t\tlabel: \'Виберіть файл з числовими даними\' ) isNil\r        ifTrue: [ ^\'Ви не вибрали файла\' ]. \r        fStream := fName asFileReference readStream.\r\t        "Введення даних"\r \t    n := Integer readFrom: fStream.  \r\t    matr := Array new: n.\r\t    m := Integer readFrom: fStream.\r\t    matr := matr collect: [ :x | Array new: m ]. \r\t    1 to: n do: [ :i |  fStream nextLine.\r \t\t     matr at: i put: (\r\t\t\t\t (matr at: i) collect: [ :x |  \r\t\t\t\t\t\tInteger readFrom: fStream. ]\r\t\t\t\t\t )\t ].\r    fStream close. matr inspect.\r        "Обчислення максимальних елементів"\r    mLines:=matr collect: [ :r | r inject: (r at: 1) into: [ :x :y | x max: y] ].\r    mMatr:=mLines at: 1.\r    mLines do: [ :x | x > mMatr ifTrue: [ mMatr := x ] ].\r        "Побудова імені файла результатів, збереження"\r    fName at: fName size - 4 put: $_ .\r    fStream := fName asFileReference writeStream.\r    mLines do: [ :x | x printOn: fStream. fStream cr ].\r    fStream close.\r    ^mMatr .  \r\r" Поясніть код, наведений вище (кожне повідомлення!):\r\r\t| matr fStream fName n m mMatr mLines | <-- Локальні змінні\r\r\tВідкриваємо діалог вибору файлу. Якщо користувач не вибрав файл – повертаємо повідомлення:\r\t(fName := UIManager default\r\t    chooseFullFileNameMatching: nil\r\t    label: \'Виберіть файл з числовими даними\') isNil\r\t    ifTrue: [ ^\'Ви не вибрали файла\' ].\r\r\tfStream := fName asFileReference readStream. <-- Відкриваємо потік для читання файлу\r\tn := Integer readFrom: fStream. <-- Читаємо перше число з файлу – кількість рядків матриці\r\tmatr := Array new: n. <-- Створюємо масив для рядків матриці:\r\tm := Integer readFrom: fStream. <-- Читаємо друге число з файлу – кількість стовпців матриці\r\tmatr := matr collect: [:x | Array new: m]. <-- Заповнюємо кожен рядок новим масивом стовпців (масив масивів)\r\r\tПроходимо по кожному рядку:\r\t - пропускаємо порожню або заголовочну лінію\r\t - читаємо числа рядка і записуємо у відповідний рядок матриці:\r\t1 to: n do: [:i |\r\t    fStream nextLine.\r\t    matr at: i put: (\r\t        (matr at: i) collect: [:x | Integer readFrom: fStream]\r\t    )].\r\r\tfStream close. <-- Закриваємо потік після читання\r\tmatr inspect. <-- Відкриваємо інспектор для перегляду матриці\r\r\tОбчислюємо максимум у кожному рядку:\r\t - inject: використовується для проходження елементів\r\t - функція x max: y повертає більший елемент\r\tmLines := matr collect: [:r | r inject: (r at: 1) into: [:x :y | x max: y]].\r\r\tЗнаходимо загальний максимум матриці:\r\t - проходимо по максимумам рядків і оновлюємо mMatr:\r\tmMatr := mLines at: 1.\r\tmLines do: [:x | x > mMatr ifTrue: [ mMatr := x ]].\r\r\tfName at: fName size - 4 put: $_. <-- Змінюємо розширення файлу для збереження результатів\r\tfStream := fName asFileReference writeStream. <-- Відкриваємо потік для запису у файл\r\tmLines do: [:x | x printOn: fStream. fStream cr]. <-- Записуємо максимуми рядків у файл, кожен на новий рядок\r\tfStream close. <-- Закриваємо файл після запису\r\t^ mMatr. <-- Повертаємо максимальний елемент всієї матриці\r\r   Як замінити масивмасивів на екземпляр класу Matrix?:\r\tMatrix замінює масив масивів, тобто ми маємо одну структуру n × m. До елементів доступ через at: i at: j.\r\tЦе дозволяє компактно читати дані з файлу, знаходити максимуми і записувати результати, не створюючи додаткових масивів рядків:\r\t\r\t| matr fStream n m mMatr |\r\r\tВідкриваємо файл та читаємо розміри:\r\tfStream := \'file.txt\' asFileReference readStream.\r\tn := Integer readFrom: fStream.\r\tm := Integer readFrom: fStream.\r\r\tСтворюємо і заповнюємо матрицю:\r\tmatr := Matrix rows: n columns: m.\r\t1 to: n do: [:i | 1 to: m do: [:j | matr at: i at: j put: Integer readFrom: fStream]].\r\tfStream close.\r\r\tЗнаходимо загальний максимум:\r\tmMatr := (1 to: n) inject: 0 into: [:maxRow :i | maxRow max: ((1 to: m) inject: 0 into: [:maxCol :j | maxCol max: (matr at: i at: j)])].\r\t^ mMatr.\r\r======================================================\r\r ------ АДРЕСНА КНИГА\r Приклад створення і використання адресної книги, описаний у одній з лекцій. \r Пригадуєте, спочатку оголошуємо глобальну змінну, що міститиме впорядковану \r колекцію масивів з трьох рядків. Спосіб порівняння описує бінарний блок.    "\r\r    Smalltalk globals at: #AddressBook\r              put:(SortedCollection sortBlock:[:a :b | (a at:1)<=(b at:1)]).\r\r" * --- Тепер до книги можна додавати записи. "\r\r    AddressBook\r            add: #(\'Ruth\' \'Babe\' \'456 Mudville Flats\');\r            add: #(\'Smith\' \'John\' \'12/5 Park Ave\');\r            add: #(\'Jexon\' \'John\' \'5 Baverli Hills\');\r            add: #(\'Adams\' \'John\' \'1 Hell str\');\r            add: #(\'Taylor\' \'Babe\' \'2a/35 Deribas str\');\r            add: #(\'Greg\' \'Voss\' \'12345 the USA\')."<-- #(\'Greg\' \'Voss\' \'12345 the USA\')"\r\r" * --- Додайте власні записи. Видрукуйте вміст книги (код запропоновано нижче)."\r   | s w |  s := WriteStream on: String new.\r\r    AddressBook do:[:x | x do:\r        [ :y | s nextPutAll: y; tab; tab.].\r        s cr. ]. "<-- a SortedCollection(#(\'Adams\' \'John\' \'1 Hell str\') \r\t\t\t\t\t  #(\'Greg\' \'Voss\' \'12345 the USA\') #(\'Jexon\' \'John\' \'5 Baverli Hills\') \r\t\t\t\t\t  #(\'Ruth\' \'Babe\' \'456 Mudville Flats\') #(\'Smith\' \'John\' \'12/5 Park Ave\') \r\t\t\t\t\t  #(\'Taylor\' \'Babe\' \'2a/35 Deribas str\'))"\r\r\tAddressBook\r    add: #(\'Brown\' \'Alice\' \'7 Cherry Lane\');\r    add: #(\'White\' \'Bob\' \'15 Oak Street\');\r    add: #(\'Green\' \'Clara\' \'9 Pine Avenue\').\r\r\t  \r\ts := WriteStream on: String new.\r\tAddressBook do: [ :x | x do: [ :y | s nextPutAll: y; tab; tab. ] ] \r\t\r\t" Я трохи начудив з додаванням записів, тому ось такий результат:\r\ta SortedCollection(#(\'Adams\' \'John\' \'1 Hell str\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Greg\' \'Voss\' \'12345 the USA\') #(\'Jexon\' \'John\' \'5 Baverli Hills\') #(\'Oleh\' \'Chyzhov\' \'MyAddress 23\') #(\'Oleh\' \'Chyzhov\' \'MyAddress 23\') #(\'Oleh\' \'Chyzhov\' \'ofjidjf\') #(\'Oleh\' \'Chyzhov\' \'frjgirgjir\') #(\'Ruth\' \'Babe\' \'456 Mudville Flats\') #(\'Smith\' \'John\' \'12/5 Park Ave\') #(\'Taylor\' \'Babe\' \'2a/35 Deribas str\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'oleh\' \'chyzhov\' \'myaddress 23\'))"\r\r\r  w := Workspace openLabel: \'My Address Book\'.\r  w contents: s contents.\r\r" * ----  Наступне завдання - надрукувати список прізвищ людей з однаковими іменами. \r              Приклад демонструє різні способи перебору та перетворення колекцій."\r\r | firstNames duplicates |\r    firstNames:=Bag new.        "утворимо торбу імен"\r    AddressBook do: [ :entry | firstNames add: (entry at: 2) ]. "<-- a SortedCollection(#(\'Adams\' \'John\' \'1 Hell str\') #(\'Greg\' \'Voss\' \'12345 the USA\') \r\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t#(\'Jexon\' \'John\' \'5 Baverli Hills\') #(\'Ruth\' \'Babe\' \'456 Mudville Flats\') #(\'Smith\' \'John\' \'12/5 Park Ave\')\r\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t#(\'Taylor\' \'Babe\' \'2a/35 Deribas str\'))"\r\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r        "виберемо ті імена, які зустрічаються більше одного разу"\r    duplicates:=firstNames select:\r        [ :name | (firstNames occurrencesOf: name)>1 ]. "<-- a Bag(\'John\' \'John\' \'John\' \'Babe\' \'Babe\')"\r            "і впорядкуємо їх"\r    duplicates:=duplicates asSet asSortedCollection. "<-- a SortedCollection(\'Babe\' \'John\')"\r        "друкуємо імена та відповідні їм прізвища"\r    duplicates do: [ :first | first printOn: Transcript. Transcript show:\'==>\'.\r        AddressBook do: [ :entry | (entry at: 2)=first\r            ifTrue: [ Transcript show:\' \'. (entry at: 1) printOn: Transcript ] ].\r        Transcript cr ]. Transcript show:\' \'.\r\r" Поясніть перетворення, що відбуваються в цьому фрагменті:\r\tBag — дозволяє зберігати елементи з повтореннями.\r\tselect: — фільтрує колекцію, залишаючи тільки елементи, що задовольняють умові (тут, occurrencesOf: > 1).\r\tasSet — видаляє дублікати після фільтрації.\r\tasSortedCollection — сортує результати для зручного виводу.\r\tdo: — ітерує колекцію і виконує дію (друк у Transcript).\r\r   Запропонуйте власні варіанти використання та перетворення колекцій. \r \r  Оформіть запропоновані вище фрагменти як методи навчального класу:\r\tObject subclass: #AddressBookUtils\r    \tinstanceVariableNames: \'\'\r    \tclassVariableNames: \'\'\r    \tpoolDictionaries: \'\'\r    \tcategory: \'Training-Examples\'.\r\r"\r\r\r" ------ ДОДАВАННЯ АДРЕС\r  Можливо, додавання записів до AddressBook за допомогою явного програмування \r  виглядає не надто привабливо. Використайте з цією метою діалоги "\r\r| a b c | \ra := UIManager default request: \'Input first name\'.\rb := UIManager default request: \'Input second name\'.\rc := UIManager default request: \'Input address\'.\ra isNil | b isNil | c isNil ifFalse: [ AddressBook add: (Array with:a with:b with:c)]. "<-- #(\'Oleh\' \'Chyzhov\' \'MyAddress 23\')"\r\r" Додайте до книги декілька нових записів, знову видрукуйте її. "\r"Через це в книзі так багато записів:"\r[\r    | a b c |\r    a := UIManager default request: \'Input first name\'.\r    a isNil ifTrue: [ ^self ].  "Cancel завершує цикл"\r\r    b := UIManager default request: \'Input second name\'.\r    b isNil ifTrue: [ ^self ].\r\r    c := UIManager default request: \'Input address\'.\r    c isNil ifTrue: [ ^self ].\r\r    AddressBook add: (Array with: a with: b with: c).\r] repeat.\r\r\ts := WriteStream on: String new.\r\tAddressBook do: [ :x | x do: [ :y | s nextPutAll: y; tab; tab. ] ] "<--  \r\ta SortedCollection(\r\t#(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') \r\t#(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') \r\t#(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'Adams\' \'John\' \'1 Hell str\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') \r\t#(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') \r\t#(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Greg\' \'Voss\' \'12345 the USA\') #(\'Jexon\' \'John\' \'5 Baverli Hills\') \r\t#(\'Oleh\' \'Chyzhov\' \'MyAddress 23\') #(\'Oleh\' \'Chyzhov\' \'MyAddress 23\') #(\'Oleh\' \'Chyzhov\' \'ofjidjf\') #(\'Oleh\' \'Chyzhov\' \'frjgirgjir\') #(\'Ruth\' \'Babe\' \'456 Mudville Flats\') \r\t#(\'Smith\' \'John\' \'12/5 Park Ave\') #(\'Taylor\' \'Babe\' \'2a/35 Deribas str\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'White\' \'Bob\' \'15 Oak Street\') \r\t#(\'White\' \'Bob\' \'15 Oak Street\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'oleh\' \'chyzhov\' \'myaddress 23\'))"\r\r" Поміркуйте, як зробити зручнішим звертання до діалогу додавання адрес та друку адресної книги. \rМожна винести логіку у клас: один метод відповідатиме за введення одного запису. Інший — за введення кількох записів. Ще інший — за друк книги"\r\r" Що станеться, якщо виконати наступний код? Випробуйте. "\r    Smalltalk globals removeKey:#AddressBook. "<-- з глобального словника Smalltalk globals буде видалено ключ #AddressBook і, відповідно, саму твою колекцію (адресну книгу)."\r\r "------ ПЕРЕТВОРЕННЯ (ПЕРЕВТІЛЕННЯ) ОБ\'ЄКТІВ\r   Виконайте за допомогою Do It. "\r\r | a b c|\r    a := OrderedCollection new.\r    b := Cylinder new.\r    c := Array with: a with: b with: b.\r    Transcript show: \'Old Array is = \'.\r    c do: [ :x | Transcript show: \'     \'. x printOn: Transcript ].\r    Transcript cr.\r    a become: b.\r    Transcript show: \'New Array is = \'.\r    c do: [ :x | Transcript show: \'     \'. x printOn: Transcript ].\r    Transcript cr; show:\' \'. "<-- Unknown variable"\r\r" Поясніть дію методу become:. Чи можна замість нього користуватися звичайним присвоєнням? Наведіть власні приклади. "\r\r" Метод become: міняє всі посилання на два об’єкти місцями у всій системі.  \r  Це відрізняється від простого присвоєння, яке змінює лише одну змінну.  \r  У прикладі масив c до become: містив [OrderedCollection, Cylinder, Cylinder],  \r  а після become: став [Cylinder, OrderedCollection, OrderedCollection].  \r  Звичайним присвоєнням такого ефекту не досягти. "\r\r\r\r\r\r\r\r'
}OmEntry {
	#tags : {
		#timestamp : DateAndTime [ '2025-10-04T21:12:53.984+03:00' ],
		#self : OmReference [ '4' ]
	},
	#content : '"--------------------------------------------------------------------------------------\r*                      ЛАБОРОТОРНА РОБОТА 3\r*                 Тема: КЛАСИ ТА МЕТОДИ. КОЛЕКЦІЇ\r*\r*  Завдання до лабораторної роботи:\r*     1. Виконайте наведені нижче приклади, збережіть і поясніть отримані результати.\r*     2. Випробуйте різноманітні способи додавання нових класів до системи.\r*     3. Навчіться доповнювати функціональність класів.\r*     4. Випробуйте методи опрацювання колекцій.\r*\r\r    Виконайте за допомогою <Print it> \r\r ------ ПРИНАЛЕЖНІСТЬ КЛАСОВІ, ІЄРАРХІЯ КЛАСІВ\r"\r    #(Francesca Jackie Marisa Bree) class. "Array"\r    (#(Francesca Jackie Marisa Bree) at:2) class. "ByteSymbol"\r    \'Rakesh Vijay Charles Daniel Tyler\' class. "ByteString"\r    (\'Rakesh Vijay Charles Daniel Tyler\' at:2) class. "Character (a)"\r    World class . "WorldMorph"\r    Magnitude class. "Magnitude class"\r    Magnitude class class. "Metaclass"\r    nil class. "UndefinedObject"\r    5 species. "SmallInteger"\r    123456789000 species. "SmallInteger"\r    #aName species. "ByteString"\r " Яка різниця між повідомленнями class i species ? \r   Відповідь: \r\tclass – це «хто я є?»\r\tspecies – це «якого типу нові колекції я породжую?»\r\r    Випробуйте різні способи відкривання браузера класів: за допомогою меню чи програмно \r     Виконайте за допомогою <Do it>\r"\r    ClyFullBrowserMorph open. \r    ClyFullBrowserMorph openOnClass: Date. \r    ClyFullBrowserMorph openOnClass: VolumeShape  selector:  #volume. \r\r" ------ МЕТОДИ КЛАСУ, КОНСТРУКТОРИ\r  Виконайте за допомогою <Print It>. Запропонуйте власні приклади. "\r\r    Array new: 10. "#(nil nil nil nil nil nil nil nil nil nil)"        \r    OrderedCollection  new. "an OrderedCollection()"\r    Date today. "29 September 2025"\r    Time now. "10:28:52.422 am"\r    UIManager default  request:\'How are you?\' initialAnswer:\'I\'\'m fine!\'. "\'I\'\'m fine!\'"\r    Integer readFrom: \'2013  1925\'. "2013"\r    Integer primesUpTo: 100. "#(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97)"\r    Rectangle origin:0@0 corner:200@100. "(0@0) corner: (200@100)"\r    Date nameOfMonth:12. "#December"\r    Date dayOfWeek: #Friday. "6"\r    Date orthodoxEasterDateFor: 2022. "24 April 2022"\r\r\r   \r"Інсталюйте вказані нижче МЕТОДИ КЛАСУ Date:\r  перенесіть копію тексту визначення методу з робочого вікна в браузер класів.\r\r""!Date class methodsFor: \'specific inquiries\' stamp: \'CamilloBruni 8/22/2013 19:47\'!""\r\rorthodoxEasterDateFor: year\r ""  compute the easter date according to the rules of the orthodox calendar.\r    source:       http://www.smart.net/~mmontes/ortheast.html   ""\r     | r1 r2 r3 r4 ra rb r5 rc date |\r\r    r1 := year \\\\ 19.\r    r2 := year \\\\ 4.\r    r3 := year \\\\ 7.\r    ra := 19*r1 + 16.\r    r4 := ra \\\\ 30.\r    rb := r2 + r2 + (4*r3) + (6*r4).\r    r5 := rb \\\\ 7.\r    rc := r4 + r5.\r    date := self year: year month: 4 day: 3.\r    ^date addDays: rc.\r""--------------------------------------------------------------------------------------""\r""!Date class methodsFor: \'specific inquiries\' stamp: \'CamilloBruni 8/22/2013 19:48\'!""\r\reasterDateFor: year\r ""  compute the easter date.\r    source: Physikalisch-Technische Bundesanstalt Braunschweig.\r    Lichtenberg, H.: Zur Interpretation der Gaussschen Osterformel und ihrer Ausnahmeregeln, Historia Mathematica 24 (1997), pp. 441-444\r      http://www.ptb.de/de/org/4/44/441/oste.htm  ""\r\r  | k m s a d r og sz oe day |\r\r  k := year // 100.\r  m := 15 + (3*k + 3//4) - (8*k + 13//25).\r   s := 2 - (3*k + 3// 4).\r  a := year \\\\ 19.\r  d := 19*a + m \\\\ 30.\r  r := d//29 + ((d//28) - (d//29)* (a// 11)).\r\r  og := 21 + d - r.\r  sz := 7 - (year//4 + year + s\\\\7).\r  oe := 7 - (og - sz\\\\7).\r  day := og + oe.\r  ^day <= 31\r    ifTrue: [ Date year: year month: 3 day: day ]\r    ifFalse: [ Date year: year month: 4 day: day - 31 ].\r"\r\r"Знайдіть роки, коли святкування припадають на один день."\r\r\r" ------ РЕКУРСІЯ\r  Додайте до класу Integer і випробуйте різні методи обчислення чисел  Фібоначчі.\r  Запропонуйте власні. Порівняйте їхню ефективність.      \r  Перед випробуванням fibonacci ЗБЕРЕЖІТЬ ІМІДЖ СИСТЕМИ! Він може зайняти Ваш комп на тиждень.  "\r\r3 fibStart: 1 with: 10  "<-- 12"\r4 fibo "<-- 5"\r12 fibonacci "<-- 233"\r\r\r"\r==============\rВласні методи:\r==============\r\r- Метод 1:\rInteger >> factorial\r    ""Обчислення факторіалу числа""\r    ^ self <= 1 ifTrue: [1] ifFalse: [self * (self - 1) factorial].\r\r- Метод 2:\rInteger >> sumTo\r    ""Сума всіх чисел від 1 до self""\r    | sum i |\r    sum := 0.\r    1 to: self do: [:i | sum := sum + i].\r    ^ sum.\r"\r\r"\rПояснення: <fibStart:with:>\rРекурсивний метод, який обчислює n-те число Фібоначчі, використовуючи два акумулятори: n1 (попереднє) і n2 (пред-попереднє).\rРекурсія: (self - 1) fibStart: n1+n2 with: n1 → наступний крок отримує нове попереднє число як суму двох попередніх.\r\rДуже швидкий для будь-якого n, навіть великого. Не обчислює одні й ті ж значення повторно → O(n). \rПам’яті потрібно лише для стеку рекурсії (глибина n).\r\rПояснення: <fibo>\rПроста обгортка над <fibStart:with:.>\r\rПовністю така ж, як у fibStart:with:. Зручно викликати без ручного передавання початкових чисел.\r\rПояснення: <fibonacci>\rКласична рекурсія: F(n) = F(n-1) + F(n-2).\r\rДуже повільний для великих n. Обчислює одні й ті ж значення багато разів → експоненційна складність O(2ⁿ). \rМоже сильно навантажити процесор і стек викликів.\r"\r\r"------------------------------------------------------------------------------------\r ------ СТВОРЕННЯ, ОПРАЦЮВАННЯ КОЛЕКЦІЙ\r  У текстовому файлі записано інформацію про матрицю цілих чисел: розміри\r  матриці в першому рядку файла, у всіх наступних рядках - рядки матриці.}\r  Прочитати матрицю, знайти максимальні елементи кожного рядка і зберегти\r  їх у файлі. Надрукувати максимальний елемент цілої матриці."\r\r"Наведений нижче код можна виконати безпосередньо в робочому вікні,\r проте,  доцільно зробити його методом власного навчального класу."\r\r| matr fStream fName n m mMatr mLines |\r        "Вибір файла за допомогою діалогу"\r    (fName:=UIManager default\r\t\t\tchooseFullFileNameMatching: nil \r\t\t\tlabel: \'Виберіть файл з числовими даними\' ) isNil\r        ifTrue: [ ^\'Ви не вибрали файла\' ]. \r        fStream := fName asFileReference readStream.\r\t        "Введення даних"\r \t    n := Integer readFrom: fStream.  \r\t    matr := Array new: n.\r\t    m := Integer readFrom: fStream.\r\t    matr := matr collect: [ :x | Array new: m ]. \r\t    1 to: n do: [ :i |  fStream nextLine.\r \t\t     matr at: i put: (\r\t\t\t\t (matr at: i) collect: [ :x |  \r\t\t\t\t\t\tInteger readFrom: fStream. ]\r\t\t\t\t\t )\t ].\r    fStream close. matr inspect.\r        "Обчислення максимальних елементів"\r    mLines:=matr collect: [ :r | r inject: (r at: 1) into: [ :x :y | x max: y] ].\r    mMatr:=mLines at: 1.\r    mLines do: [ :x | x > mMatr ifTrue: [ mMatr := x ] ].\r        "Побудова імені файла результатів, збереження"\r    fName at: fName size - 4 put: $_ .\r    fStream := fName asFileReference writeStream.\r    mLines do: [ :x | x printOn: fStream. fStream cr ].\r    fStream close.\r    ^mMatr .  \r\r" Поясніть код, наведений вище (кожне повідомлення!):\r\r\t| matr fStream fName n m mMatr mLines | <-- Локальні змінні\r\r\tВідкриваємо діалог вибору файлу. Якщо користувач не вибрав файл – повертаємо повідомлення:\r\t(fName := UIManager default\r\t    chooseFullFileNameMatching: nil\r\t    label: \'Виберіть файл з числовими даними\') isNil\r\t    ifTrue: [ ^\'Ви не вибрали файла\' ].\r\r\tfStream := fName asFileReference readStream. <-- Відкриваємо потік для читання файлу\r\tn := Integer readFrom: fStream. <-- Читаємо перше число з файлу – кількість рядків матриці\r\tmatr := Array new: n. <-- Створюємо масив для рядків матриці:\r\tm := Integer readFrom: fStream. <-- Читаємо друге число з файлу – кількість стовпців матриці\r\tmatr := matr collect: [:x | Array new: m]. <-- Заповнюємо кожен рядок новим масивом стовпців (масив масивів)\r\r\tПроходимо по кожному рядку:\r\t - пропускаємо порожню або заголовочну лінію\r\t - читаємо числа рядка і записуємо у відповідний рядок матриці:\r\t1 to: n do: [:i |\r\t    fStream nextLine.\r\t    matr at: i put: (\r\t        (matr at: i) collect: [:x | Integer readFrom: fStream]\r\t    )].\r\r\tfStream close. <-- Закриваємо потік після читання\r\tmatr inspect. <-- Відкриваємо інспектор для перегляду матриці\r\r\tОбчислюємо максимум у кожному рядку:\r\t - inject: використовується для проходження елементів\r\t - функція x max: y повертає більший елемент\r\tmLines := matr collect: [:r | r inject: (r at: 1) into: [:x :y | x max: y]].\r\r\tЗнаходимо загальний максимум матриці:\r\t - проходимо по максимумам рядків і оновлюємо mMatr:\r\tmMatr := mLines at: 1.\r\tmLines do: [:x | x > mMatr ifTrue: [ mMatr := x ]].\r\r\tfName at: fName size - 4 put: $_. <-- Змінюємо розширення файлу для збереження результатів\r\tfStream := fName asFileReference writeStream. <-- Відкриваємо потік для запису у файл\r\tmLines do: [:x | x printOn: fStream. fStream cr]. <-- Записуємо максимуми рядків у файл, кожен на новий рядок\r\tfStream close. <-- Закриваємо файл після запису\r\t^ mMatr. <-- Повертаємо максимальний елемент всієї матриці\r\r   Як замінити масивмасивів на екземпляр класу Matrix?:\r\tMatrix замінює масив масивів, тобто ми маємо одну структуру n × m. До елементів доступ через at: i at: j.\r\tЦе дозволяє компактно читати дані з файлу, знаходити максимуми і записувати результати, не створюючи додаткових масивів рядків:\r\t\r\t| matr fStream n m mMatr |\r\r\tВідкриваємо файл та читаємо розміри:\r\tfStream := \'file.txt\' asFileReference readStream.\r\tn := Integer readFrom: fStream.\r\tm := Integer readFrom: fStream.\r\r\tСтворюємо і заповнюємо матрицю:\r\tmatr := Matrix rows: n columns: m.\r\t1 to: n do: [:i | 1 to: m do: [:j | matr at: i at: j put: Integer readFrom: fStream]].\r\tfStream close.\r\r\tЗнаходимо загальний максимум:\r\tmMatr := (1 to: n) inject: 0 into: [:maxRow :i | maxRow max: ((1 to: m) inject: 0 into: [:maxCol :j | maxCol max: (matr at: i at: j)])].\r\t^ mMatr.\r\r======================================================\r\r ------ АДРЕСНА КНИГА\r Приклад створення і використання адресної книги, описаний у одній з лекцій. \r Пригадуєте, спочатку оголошуємо глобальну змінну, що міститиме впорядковану \r колекцію масивів з трьох рядків. Спосіб порівняння описує бінарний блок.    "\r\r    Smalltalk globals at: #AddressBook\r              put:(SortedCollection sortBlock:[:a :b | (a at:1)<=(b at:1)]).\r\r" * --- Тепер до книги можна додавати записи. "\r\r    AddressBook\r            add: #(\'Ruth\' \'Babe\' \'456 Mudville Flats\');\r            add: #(\'Smith\' \'John\' \'12/5 Park Ave\');\r            add: #(\'Jexon\' \'John\' \'5 Baverli Hills\');\r            add: #(\'Adams\' \'John\' \'1 Hell str\');\r            add: #(\'Taylor\' \'Babe\' \'2a/35 Deribas str\');\r            add: #(\'Greg\' \'Voss\' \'12345 the USA\')."<-- #(\'Greg\' \'Voss\' \'12345 the USA\')"\r\r" * --- Додайте власні записи. Видрукуйте вміст книги (код запропоновано нижче)."\r   | s w |  s := WriteStream on: String new.\r\r    AddressBook do:[:x | x do:\r        [ :y | s nextPutAll: y; tab; tab.].\r        s cr. ]. "<-- a SortedCollection(#(\'Adams\' \'John\' \'1 Hell str\') \r\t\t\t\t\t  #(\'Greg\' \'Voss\' \'12345 the USA\') #(\'Jexon\' \'John\' \'5 Baverli Hills\') \r\t\t\t\t\t  #(\'Ruth\' \'Babe\' \'456 Mudville Flats\') #(\'Smith\' \'John\' \'12/5 Park Ave\') \r\t\t\t\t\t  #(\'Taylor\' \'Babe\' \'2a/35 Deribas str\'))"\r\r\tAddressBook\r    add: #(\'Brown\' \'Alice\' \'7 Cherry Lane\');\r    add: #(\'White\' \'Bob\' \'15 Oak Street\');\r    add: #(\'Green\' \'Clara\' \'9 Pine Avenue\').\r\r\t  \r\ts := WriteStream on: String new.\r\tAddressBook do: [ :x | x do: [ :y | s nextPutAll: y; tab; tab. ] ] \r\t\r\t" Я трохи начудив з додаванням записів, тому ось такий результат:\r\ta SortedCollection(#(\'Adams\' \'John\' \'1 Hell str\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Greg\' \'Voss\' \'12345 the USA\') #(\'Jexon\' \'John\' \'5 Baverli Hills\') #(\'Oleh\' \'Chyzhov\' \'MyAddress 23\') #(\'Oleh\' \'Chyzhov\' \'MyAddress 23\') #(\'Oleh\' \'Chyzhov\' \'ofjidjf\') #(\'Oleh\' \'Chyzhov\' \'frjgirgjir\') #(\'Ruth\' \'Babe\' \'456 Mudville Flats\') #(\'Smith\' \'John\' \'12/5 Park Ave\') #(\'Taylor\' \'Babe\' \'2a/35 Deribas str\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'oleh\' \'chyzhov\' \'myaddress 23\'))"\r\r\r  w := Workspace openLabel: \'My Address Book\'.\r  w contents: s contents.\r\r" * ----  Наступне завдання - надрукувати список прізвищ людей з однаковими іменами. \r              Приклад демонструє різні способи перебору та перетворення колекцій."\r\r | firstNames duplicates |\r    firstNames:=Bag new.        "утворимо торбу імен"\r    AddressBook do: [ :entry | firstNames add: (entry at: 2) ]. "<-- a SortedCollection(#(\'Adams\' \'John\' \'1 Hell str\') #(\'Greg\' \'Voss\' \'12345 the USA\') \r\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t#(\'Jexon\' \'John\' \'5 Baverli Hills\') #(\'Ruth\' \'Babe\' \'456 Mudville Flats\') #(\'Smith\' \'John\' \'12/5 Park Ave\')\r\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t#(\'Taylor\' \'Babe\' \'2a/35 Deribas str\'))"\r\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r        "виберемо ті імена, які зустрічаються більше одного разу"\r    duplicates:=firstNames select:\r        [ :name | (firstNames occurrencesOf: name)>1 ]. "<-- a Bag(\'John\' \'John\' \'John\' \'Babe\' \'Babe\')"\r            "і впорядкуємо їх"\r    duplicates:=duplicates asSet asSortedCollection. "<-- a SortedCollection(\'Babe\' \'John\')"\r        "друкуємо імена та відповідні їм прізвища"\r    duplicates do: [ :first | first printOn: Transcript. Transcript show:\'==>\'.\r        AddressBook do: [ :entry | (entry at: 2)=first\r            ifTrue: [ Transcript show:\' \'. (entry at: 1) printOn: Transcript ] ].\r        Transcript cr ]. Transcript show:\' \'.\r\r" Поясніть перетворення, що відбуваються в цьому фрагменті:\r\tBag — дозволяє зберігати елементи з повтореннями.\r\tselect: — фільтрує колекцію, залишаючи тільки елементи, що задовольняють умові (тут, occurrencesOf: > 1).\r\tasSet — видаляє дублікати після фільтрації.\r\tasSortedCollection — сортує результати для зручного виводу.\r\tdo: — ітерує колекцію і виконує дію (друк у Transcript).\r\r   Запропонуйте власні варіанти використання та перетворення колекцій. \r \r  Оформіть запропоновані вище фрагменти як методи навчального класу:\r\tObject subclass: #AddressBookUtils\r    \tinstanceVariableNames: \'\'\r    \tclassVariableNames: \'\'\r    \tpoolDictionaries: \'\'\r    \tcategory: \'Training-Examples\'.\r\r"\r\r\r" ------ ДОДАВАННЯ АДРЕС\r  Можливо, додавання записів до AddressBook за допомогою явного програмування \r  виглядає не надто привабливо. Використайте з цією метою діалоги "\r\r| a b c | \ra := UIManager default request: \'Input first name\'.\rb := UIManager default request: \'Input second name\'.\rc := UIManager default request: \'Input address\'.\ra isNil | b isNil | c isNil ifFalse: [ AddressBook add: (Array with:a with:b with:c)]. "<-- #(\'Oleh\' \'Chyzhov\' \'MyAddress 23\')"\r\r" Додайте до книги декілька нових записів, знову видрукуйте її. "\r"Через це в книзі так багато записів:"\r[\r    | a b c |\r    a := UIManager default request: \'Input first name\'.\r    a isNil ifTrue: [ ^self ].  "Cancel завершує цикл"\r\r    b := UIManager default request: \'Input second name\'.\r    b isNil ifTrue: [ ^self ].\r\r    c := UIManager default request: \'Input address\'.\r    c isNil ifTrue: [ ^self ].\r\r    AddressBook add: (Array with: a with: b with: c).\r] repeat.\r\r\ts := WriteStream on: String new.\r\tAddressBook do: [ :x | x do: [ :y | s nextPutAll: y; tab; tab. ] ] "<--  \r\ta SortedCollection(\r\t#(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') \r\t#(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') \r\t#(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'Adams\' \'John\' \'1 Hell str\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') \r\t#(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') \r\t#(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Greg\' \'Voss\' \'12345 the USA\') #(\'Jexon\' \'John\' \'5 Baverli Hills\') \r\t#(\'Oleh\' \'Chyzhov\' \'MyAddress 23\') #(\'Oleh\' \'Chyzhov\' \'MyAddress 23\') #(\'Oleh\' \'Chyzhov\' \'ofjidjf\') #(\'Oleh\' \'Chyzhov\' \'frjgirgjir\') #(\'Ruth\' \'Babe\' \'456 Mudville Flats\') \r\t#(\'Smith\' \'John\' \'12/5 Park Ave\') #(\'Taylor\' \'Babe\' \'2a/35 Deribas str\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'White\' \'Bob\' \'15 Oak Street\') \r\t#(\'White\' \'Bob\' \'15 Oak Street\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'oleh\' \'chyzhov\' \'myaddress 23\'))"\r\r" Поміркуйте, як зробити зручнішим звертання до діалогу додавання адрес та друку адресної книги. \rМожна винести логіку у клас: один метод відповідатиме за введення одного запису. Інший — за введення кількох записів. Ще інший — за друк книги"\r\r" Що станеться, якщо виконати наступний код? Випробуйте. "\r    Smalltalk globals removeKey:#AddressBook. "<-- з глобального словника Smalltalk globals буде видалено ключ #AddressBook і, відповідно, саму твою колекцію (адресну книгу)."\r\r "------ ПЕРЕТВОРЕННЯ (ПЕРЕВТІЛЕННЯ) ОБ\'ЄКТІВ\r   Виконайте за допомогою Do It. "\r\r | a b c|\r    a := OrderedCollection new.\r    b := Cylinder new.\r    c := Array with: a with: b with: b.\r    Transcript show: \'Old Array is = \'.\r    c do: [ :x | Transcript show: \'     \'. x printOn: Transcript ].\r    Transcript cr.\r    a become: b.\r    Transcript show: \'New Array is = \'.\r    c do: [ :x | Transcript show: \'     \'. x printOn: Transcript ].\r    Transcript cr; show:\' \'. "<-- Unknown variable"\r\r" Поясніть дію методу become:. Чи можна замість нього користуватися звичайним присвоєнням? Наведіть власні приклади. "\r\r" Метод become: міняє всі посилання на два об’єкти місцями у всій системі.  \r  Це відрізняється від простого присвоєння, яке змінює лише одну змінну.  \r  У прикладі масив c до become: містив [OrderedCollection, Cylinder, Cylinder],  \r  а після become: став [Cylinder, OrderedCollection, OrderedCollection].  \r  Звичайним присвоєнням такого ефекту не досягти. "\r\r\r\r\r\r\r\r'
}OmEntry {
	#tags : {
		#timestamp : DateAndTime [ '2025-10-04T21:27:27.36+03:00' ],
		#self : OmReference [ '5' ]
	},
	#content : '"--------------------------------------------------------------------------------------\r*                      ЛАБОРОТОРНА РОБОТА 3\r*                 Тема: КЛАСИ ТА МЕТОДИ. КОЛЕКЦІЇ\r*\r*  Завдання до лабораторної роботи:\r*     1. Виконайте наведені нижче приклади, збережіть і поясніть отримані результати.\r*     2. Випробуйте різноманітні способи додавання нових класів до системи.\r*     3. Навчіться доповнювати функціональність класів.\r*     4. Випробуйте методи опрацювання колекцій.\r*\r\r    Виконайте за допомогою <Print it> \r\r ------ ПРИНАЛЕЖНІСТЬ КЛАСОВІ, ІЄРАРХІЯ КЛАСІВ\r"\r    #(Francesca Jackie Marisa Bree) class. "Array"\r    (#(Francesca Jackie Marisa Bree) at:2) class. "ByteSymbol"\r    \'Rakesh Vijay Charles Daniel Tyler\' class. "ByteString"\r    (\'Rakesh Vijay Charles Daniel Tyler\' at:2) class. "Character (a)"\r    World class . "WorldMorph"\r    Magnitude class. "Magnitude class"\r    Magnitude class class. "Metaclass"\r    nil class. "UndefinedObject"\r    5 species. "SmallInteger"\r    123456789000 species. "SmallInteger"\r    #aName species. "ByteString"\r " Яка різниця між повідомленнями class i species ? \r   Відповідь: \r\tclass – це «хто я є?»\r\tspecies – це «якого типу нові колекції я породжую?»\r\r    Випробуйте різні способи відкривання браузера класів: за допомогою меню чи програмно \r     Виконайте за допомогою <Do it>\r"\r    ClyFullBrowserMorph open. \r    ClyFullBrowserMorph openOnClass: Date. \r    ClyFullBrowserMorph openOnClass: VolumeShape  selector:  #volume. \r\r" ------ МЕТОДИ КЛАСУ, КОНСТРУКТОРИ\r  Виконайте за допомогою <Print It>. Запропонуйте власні приклади. "\r\r    Array new: 10. "#(nil nil nil nil nil nil nil nil nil nil)"        \r    OrderedCollection  new. "an OrderedCollection()"\r    Date today. "29 September 2025"\r    Time now. "10:28:52.422 am"\r    UIManager default  request:\'How are you?\' initialAnswer:\'I\'\'m fine!\'. "\'I\'\'m fine!\'"\r    Integer readFrom: \'2013  1925\'. "2013"\r    Integer primesUpTo: 100. "#(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97)"\r    Rectangle origin:0@0 corner:200@100. "(0@0) corner: (200@100)"\r    Date nameOfMonth:12. "#December"\r    Date dayOfWeek: #Friday. "6"\r    Date orthodoxEasterDateFor: 2022. "24 April 2022"\r\r\r   \r"Інсталюйте вказані нижче МЕТОДИ КЛАСУ Date:\r  перенесіть копію тексту визначення методу з робочого вікна в браузер класів.\r\r""!Date class methodsFor: \'specific inquiries\' stamp: \'CamilloBruni 8/22/2013 19:47\'!""\r\rorthodoxEasterDateFor: year\r ""  compute the easter date according to the rules of the orthodox calendar.\r    source:       http://www.smart.net/~mmontes/ortheast.html   ""\r     | r1 r2 r3 r4 ra rb r5 rc date |\r\r    r1 := year \\\\ 19.\r    r2 := year \\\\ 4.\r    r3 := year \\\\ 7.\r    ra := 19*r1 + 16.\r    r4 := ra \\\\ 30.\r    rb := r2 + r2 + (4*r3) + (6*r4).\r    r5 := rb \\\\ 7.\r    rc := r4 + r5.\r    date := self year: year month: 4 day: 3.\r    ^date addDays: rc.\r""--------------------------------------------------------------------------------------""\r""!Date class methodsFor: \'specific inquiries\' stamp: \'CamilloBruni 8/22/2013 19:48\'!""\r\reasterDateFor: year\r ""  compute the easter date.\r    source: Physikalisch-Technische Bundesanstalt Braunschweig.\r    Lichtenberg, H.: Zur Interpretation der Gaussschen Osterformel und ihrer Ausnahmeregeln, Historia Mathematica 24 (1997), pp. 441-444\r      http://www.ptb.de/de/org/4/44/441/oste.htm  ""\r\r  | k m s a d r og sz oe day |\r\r  k := year // 100.\r  m := 15 + (3*k + 3//4) - (8*k + 13//25).\r   s := 2 - (3*k + 3// 4).\r  a := year \\\\ 19.\r  d := 19*a + m \\\\ 30.\r  r := d//29 + ((d//28) - (d//29)* (a// 11)).\r\r  og := 21 + d - r.\r  sz := 7 - (year//4 + year + s\\\\7).\r  oe := 7 - (og - sz\\\\7).\r  day := og + oe.\r  ^day <= 31\r    ifTrue: [ Date year: year month: 3 day: day ]\r    ifFalse: [ Date year: year month: 4 day: day - 31 ].\r"\r\r"Знайдіть роки, коли святкування припадають на один день."\r\r| matchingYears orthodoxDate catholicDate |\r    matchingYears := OrderedCollection new.\r    (startYear to: endYear) do: [:year |\r        orthodoxDate := self orthodoxEasterDateFor: year.\r        catholicDate := self easterDateFor: year.\r        (orthodoxDate = catholicDate) ifTrue: [\r            matchingYears add: year\r        ].\r    ].\r    ^matchingYears asArray\r\rDate yearsWithMatchingEasterFrom: 2000 to: 2050.\r\r" ------ РЕКУРСІЯ\r  Додайте до класу Integer і випробуйте різні методи обчислення чисел  Фібоначчі.\r  Запропонуйте власні. Порівняйте їхню ефективність.      \r  Перед випробуванням fibonacci ЗБЕРЕЖІТЬ ІМІДЖ СИСТЕМИ! Він може зайняти Ваш комп на тиждень.  "\r\r3 fibStart: 1 with: 10  "<-- 12"\r4 fibo "<-- 5"\r12 fibonacci "<-- 233"\r\r\r"\r==============\rВласні методи:\r==============\r\r- Метод 1:\rInteger >> factorial\r    ""Обчислення факторіалу числа""\r    ^ self <= 1 ifTrue: [1] ifFalse: [self * (self - 1) factorial].\r\r- Метод 2:\rInteger >> sumTo\r    ""Сума всіх чисел від 1 до self""\r    | sum i |\r    sum := 0.\r    1 to: self do: [:i | sum := sum + i].\r    ^ sum.\r"\r\r"\rПояснення: <fibStart:with:>\rРекурсивний метод, який обчислює n-те число Фібоначчі, використовуючи два акумулятори: n1 (попереднє) і n2 (пред-попереднє).\rРекурсія: (self - 1) fibStart: n1+n2 with: n1 → наступний крок отримує нове попереднє число як суму двох попередніх.\r\rДуже швидкий для будь-якого n, навіть великого. Не обчислює одні й ті ж значення повторно → O(n). \rПам’яті потрібно лише для стеку рекурсії (глибина n).\r\rПояснення: <fibo>\rПроста обгортка над <fibStart:with:.>\r\rПовністю така ж, як у fibStart:with:. Зручно викликати без ручного передавання початкових чисел.\r\rПояснення: <fibonacci>\rКласична рекурсія: F(n) = F(n-1) + F(n-2).\r\rДуже повільний для великих n. Обчислює одні й ті ж значення багато разів → експоненційна складність O(2ⁿ). \rМоже сильно навантажити процесор і стек викликів.\r"\r\r"------------------------------------------------------------------------------------\r ------ СТВОРЕННЯ, ОПРАЦЮВАННЯ КОЛЕКЦІЙ\r  У текстовому файлі записано інформацію про матрицю цілих чисел: розміри\r  матриці в першому рядку файла, у всіх наступних рядках - рядки матриці.}\r  Прочитати матрицю, знайти максимальні елементи кожного рядка і зберегти\r  їх у файлі. Надрукувати максимальний елемент цілої матриці."\r\r"Наведений нижче код можна виконати безпосередньо в робочому вікні,\r проте,  доцільно зробити його методом власного навчального класу."\r\r| matr fStream fName n m mMatr mLines |\r        "Вибір файла за допомогою діалогу"\r    (fName:=UIManager default\r\t\t\tchooseFullFileNameMatching: nil \r\t\t\tlabel: \'Виберіть файл з числовими даними\' ) isNil\r        ifTrue: [ ^\'Ви не вибрали файла\' ]. \r        fStream := fName asFileReference readStream.\r\t        "Введення даних"\r \t    n := Integer readFrom: fStream.  \r\t    matr := Array new: n.\r\t    m := Integer readFrom: fStream.\r\t    matr := matr collect: [ :x | Array new: m ]. \r\t    1 to: n do: [ :i |  fStream nextLine.\r \t\t     matr at: i put: (\r\t\t\t\t (matr at: i) collect: [ :x |  \r\t\t\t\t\t\tInteger readFrom: fStream. ]\r\t\t\t\t\t )\t ].\r    fStream close. matr inspect.\r        "Обчислення максимальних елементів"\r    mLines:=matr collect: [ :r | r inject: (r at: 1) into: [ :x :y | x max: y] ].\r    mMatr:=mLines at: 1.\r    mLines do: [ :x | x > mMatr ifTrue: [ mMatr := x ] ].\r        "Побудова імені файла результатів, збереження"\r    fName at: fName size - 4 put: $_ .\r    fStream := fName asFileReference writeStream.\r    mLines do: [ :x | x printOn: fStream. fStream cr ].\r    fStream close.\r    ^mMatr .  \r\r" Поясніть код, наведений вище (кожне повідомлення!):\r\r\t| matr fStream fName n m mMatr mLines | <-- Локальні змінні\r\r\tВідкриваємо діалог вибору файлу. Якщо користувач не вибрав файл – повертаємо повідомлення:\r\t(fName := UIManager default\r\t    chooseFullFileNameMatching: nil\r\t    label: \'Виберіть файл з числовими даними\') isNil\r\t    ifTrue: [ ^\'Ви не вибрали файла\' ].\r\r\tfStream := fName asFileReference readStream. <-- Відкриваємо потік для читання файлу\r\tn := Integer readFrom: fStream. <-- Читаємо перше число з файлу – кількість рядків матриці\r\tmatr := Array new: n. <-- Створюємо масив для рядків матриці:\r\tm := Integer readFrom: fStream. <-- Читаємо друге число з файлу – кількість стовпців матриці\r\tmatr := matr collect: [:x | Array new: m]. <-- Заповнюємо кожен рядок новим масивом стовпців (масив масивів)\r\r\tПроходимо по кожному рядку:\r\t - пропускаємо порожню або заголовочну лінію\r\t - читаємо числа рядка і записуємо у відповідний рядок матриці:\r\t1 to: n do: [:i |\r\t    fStream nextLine.\r\t    matr at: i put: (\r\t        (matr at: i) collect: [:x | Integer readFrom: fStream]\r\t    )].\r\r\tfStream close. <-- Закриваємо потік після читання\r\tmatr inspect. <-- Відкриваємо інспектор для перегляду матриці\r\r\tОбчислюємо максимум у кожному рядку:\r\t - inject: використовується для проходження елементів\r\t - функція x max: y повертає більший елемент\r\tmLines := matr collect: [:r | r inject: (r at: 1) into: [:x :y | x max: y]].\r\r\tЗнаходимо загальний максимум матриці:\r\t - проходимо по максимумам рядків і оновлюємо mMatr:\r\tmMatr := mLines at: 1.\r\tmLines do: [:x | x > mMatr ifTrue: [ mMatr := x ]].\r\r\tfName at: fName size - 4 put: $_. <-- Змінюємо розширення файлу для збереження результатів\r\tfStream := fName asFileReference writeStream. <-- Відкриваємо потік для запису у файл\r\tmLines do: [:x | x printOn: fStream. fStream cr]. <-- Записуємо максимуми рядків у файл, кожен на новий рядок\r\tfStream close. <-- Закриваємо файл після запису\r\t^ mMatr. <-- Повертаємо максимальний елемент всієї матриці\r\r   Як замінити масивмасивів на екземпляр класу Matrix?:\r\tMatrix замінює масив масивів, тобто ми маємо одну структуру n × m. До елементів доступ через at: i at: j.\r\tЦе дозволяє компактно читати дані з файлу, знаходити максимуми і записувати результати, не створюючи додаткових масивів рядків:\r\t\r\t| matr fStream n m mMatr |\r\r\tВідкриваємо файл та читаємо розміри:\r\tfStream := \'file.txt\' asFileReference readStream.\r\tn := Integer readFrom: fStream.\r\tm := Integer readFrom: fStream.\r\r\tСтворюємо і заповнюємо матрицю:\r\tmatr := Matrix rows: n columns: m.\r\t1 to: n do: [:i | 1 to: m do: [:j | matr at: i at: j put: Integer readFrom: fStream]].\r\tfStream close.\r\r\tЗнаходимо загальний максимум:\r\tmMatr := (1 to: n) inject: 0 into: [:maxRow :i | maxRow max: ((1 to: m) inject: 0 into: [:maxCol :j | maxCol max: (matr at: i at: j)])].\r\t^ mMatr.\r\r======================================================\r\r ------ АДРЕСНА КНИГА\r Приклад створення і використання адресної книги, описаний у одній з лекцій. \r Пригадуєте, спочатку оголошуємо глобальну змінну, що міститиме впорядковану \r колекцію масивів з трьох рядків. Спосіб порівняння описує бінарний блок.    "\r\r    Smalltalk globals at: #AddressBook\r              put:(SortedCollection sortBlock:[:a :b | (a at:1)<=(b at:1)]).\r\r" * --- Тепер до книги можна додавати записи. "\r\r    AddressBook\r            add: #(\'Ruth\' \'Babe\' \'456 Mudville Flats\');\r            add: #(\'Smith\' \'John\' \'12/5 Park Ave\');\r            add: #(\'Jexon\' \'John\' \'5 Baverli Hills\');\r            add: #(\'Adams\' \'John\' \'1 Hell str\');\r            add: #(\'Taylor\' \'Babe\' \'2a/35 Deribas str\');\r            add: #(\'Greg\' \'Voss\' \'12345 the USA\')."<-- #(\'Greg\' \'Voss\' \'12345 the USA\')"\r\r" * --- Додайте власні записи. Видрукуйте вміст книги (код запропоновано нижче)."\r   | s w |  s := WriteStream on: String new.\r\r    AddressBook do:[:x | x do:\r        [ :y | s nextPutAll: y; tab; tab.].\r        s cr. ]. "<-- a SortedCollection(#(\'Adams\' \'John\' \'1 Hell str\') \r\t\t\t\t\t  #(\'Greg\' \'Voss\' \'12345 the USA\') #(\'Jexon\' \'John\' \'5 Baverli Hills\') \r\t\t\t\t\t  #(\'Ruth\' \'Babe\' \'456 Mudville Flats\') #(\'Smith\' \'John\' \'12/5 Park Ave\') \r\t\t\t\t\t  #(\'Taylor\' \'Babe\' \'2a/35 Deribas str\'))"\r\r\tAddressBook\r    add: #(\'Brown\' \'Alice\' \'7 Cherry Lane\');\r    add: #(\'White\' \'Bob\' \'15 Oak Street\');\r    add: #(\'Green\' \'Clara\' \'9 Pine Avenue\').\r\r\t  \r\ts := WriteStream on: String new.\r\tAddressBook do: [ :x | x do: [ :y | s nextPutAll: y; tab; tab. ] ] \r\t\r\t" Я трохи начудив з додаванням записів, тому ось такий результат:\r\ta SortedCollection(#(\'Adams\' \'John\' \'1 Hell str\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Greg\' \'Voss\' \'12345 the USA\') #(\'Jexon\' \'John\' \'5 Baverli Hills\') #(\'Oleh\' \'Chyzhov\' \'MyAddress 23\') #(\'Oleh\' \'Chyzhov\' \'MyAddress 23\') #(\'Oleh\' \'Chyzhov\' \'ofjidjf\') #(\'Oleh\' \'Chyzhov\' \'frjgirgjir\') #(\'Ruth\' \'Babe\' \'456 Mudville Flats\') #(\'Smith\' \'John\' \'12/5 Park Ave\') #(\'Taylor\' \'Babe\' \'2a/35 Deribas str\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'oleh\' \'chyzhov\' \'myaddress 23\'))"\r\r\r  w := Workspace openLabel: \'My Address Book\'.\r  w contents: s contents.\r\r" * ----  Наступне завдання - надрукувати список прізвищ людей з однаковими іменами. \r              Приклад демонструє різні способи перебору та перетворення колекцій."\r\r | firstNames duplicates |\r    firstNames:=Bag new.        "утворимо торбу імен"\r    AddressBook do: [ :entry | firstNames add: (entry at: 2) ]. "<-- a SortedCollection(#(\'Adams\' \'John\' \'1 Hell str\') #(\'Greg\' \'Voss\' \'12345 the USA\') \r\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t#(\'Jexon\' \'John\' \'5 Baverli Hills\') #(\'Ruth\' \'Babe\' \'456 Mudville Flats\') #(\'Smith\' \'John\' \'12/5 Park Ave\')\r\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t#(\'Taylor\' \'Babe\' \'2a/35 Deribas str\'))"\r\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r        "виберемо ті імена, які зустрічаються більше одного разу"\r    duplicates:=firstNames select:\r        [ :name | (firstNames occurrencesOf: name)>1 ]. "<-- a Bag(\'John\' \'John\' \'John\' \'Babe\' \'Babe\')"\r            "і впорядкуємо їх"\r    duplicates:=duplicates asSet asSortedCollection. "<-- a SortedCollection(\'Babe\' \'John\')"\r        "друкуємо імена та відповідні їм прізвища"\r    duplicates do: [ :first | first printOn: Transcript. Transcript show:\'==>\'.\r        AddressBook do: [ :entry | (entry at: 2)=first\r            ifTrue: [ Transcript show:\' \'. (entry at: 1) printOn: Transcript ] ].\r        Transcript cr ]. Transcript show:\' \'.\r\r" Поясніть перетворення, що відбуваються в цьому фрагменті:\r\tBag — дозволяє зберігати елементи з повтореннями.\r\tselect: — фільтрує колекцію, залишаючи тільки елементи, що задовольняють умові (тут, occurrencesOf: > 1).\r\tasSet — видаляє дублікати після фільтрації.\r\tasSortedCollection — сортує результати для зручного виводу.\r\tdo: — ітерує колекцію і виконує дію (друк у Transcript).\r\r   Запропонуйте власні варіанти використання та перетворення колекцій. \r \r  Оформіть запропоновані вище фрагменти як методи навчального класу:\r\tObject subclass: #AddressBookUtils\r    \tinstanceVariableNames: \'\'\r    \tclassVariableNames: \'\'\r    \tpoolDictionaries: \'\'\r    \tcategory: \'Training-Examples\'.\r\r"\r\r\r" ------ ДОДАВАННЯ АДРЕС\r  Можливо, додавання записів до AddressBook за допомогою явного програмування \r  виглядає не надто привабливо. Використайте з цією метою діалоги "\r\r| a b c | \ra := UIManager default request: \'Input first name\'.\rb := UIManager default request: \'Input second name\'.\rc := UIManager default request: \'Input address\'.\ra isNil | b isNil | c isNil ifFalse: [ AddressBook add: (Array with:a with:b with:c)]. "<-- #(\'Oleh\' \'Chyzhov\' \'MyAddress 23\')"\r\r" Додайте до книги декілька нових записів, знову видрукуйте її. "\r"Через це в книзі так багато записів:"\r[\r    | a b c |\r    a := UIManager default request: \'Input first name\'.\r    a isNil ifTrue: [ ^self ].  "Cancel завершує цикл"\r\r    b := UIManager default request: \'Input second name\'.\r    b isNil ifTrue: [ ^self ].\r\r    c := UIManager default request: \'Input address\'.\r    c isNil ifTrue: [ ^self ].\r\r    AddressBook add: (Array with: a with: b with: c).\r] repeat.\r\r\ts := WriteStream on: String new.\r\tAddressBook do: [ :x | x do: [ :y | s nextPutAll: y; tab; tab. ] ] "<--  \r\ta SortedCollection(\r\t#(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') \r\t#(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') \r\t#(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'Adams\' \'John\' \'1 Hell str\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') \r\t#(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') \r\t#(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Greg\' \'Voss\' \'12345 the USA\') #(\'Jexon\' \'John\' \'5 Baverli Hills\') \r\t#(\'Oleh\' \'Chyzhov\' \'MyAddress 23\') #(\'Oleh\' \'Chyzhov\' \'MyAddress 23\') #(\'Oleh\' \'Chyzhov\' \'ofjidjf\') #(\'Oleh\' \'Chyzhov\' \'frjgirgjir\') #(\'Ruth\' \'Babe\' \'456 Mudville Flats\') \r\t#(\'Smith\' \'John\' \'12/5 Park Ave\') #(\'Taylor\' \'Babe\' \'2a/35 Deribas str\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'White\' \'Bob\' \'15 Oak Street\') \r\t#(\'White\' \'Bob\' \'15 Oak Street\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'oleh\' \'chyzhov\' \'myaddress 23\'))"\r\r" Поміркуйте, як зробити зручнішим звертання до діалогу додавання адрес та друку адресної книги. \rМожна винести логіку у клас: один метод відповідатиме за введення одного запису. Інший — за введення кількох записів. Ще інший — за друк книги"\r\r" Що станеться, якщо виконати наступний код? Випробуйте. "\r    Smalltalk globals removeKey:#AddressBook. "<-- з глобального словника Smalltalk globals буде видалено ключ #AddressBook і, відповідно, саму твою колекцію (адресну книгу)."\r\r "------ ПЕРЕТВОРЕННЯ (ПЕРЕВТІЛЕННЯ) ОБ\'ЄКТІВ\r   Виконайте за допомогою Do It. "\r\r | a b c|\r    a := OrderedCollection new.\r    b := Cylinder new.\r    c := Array with: a with: b with: b.\r    Transcript show: \'Old Array is = \'.\r    c do: [ :x | Transcript show: \'     \'. x printOn: Transcript ].\r    Transcript cr.\r    a become: b.\r    Transcript show: \'New Array is = \'.\r    c do: [ :x | Transcript show: \'     \'. x printOn: Transcript ].\r    Transcript cr; show:\' \'. "<-- Unknown variable"\r\r" Поясніть дію методу become:. Чи можна замість нього користуватися звичайним присвоєнням? Наведіть власні приклади. "\r\r" Метод become: міняє всі посилання на два об’єкти місцями у всій системі.  \r  Це відрізняється від простого присвоєння, яке змінює лише одну змінну.  \r  У прикладі масив c до become: містив [OrderedCollection, Cylinder, Cylinder],  \r  а після become: став [Cylinder, OrderedCollection, OrderedCollection].  \r  Звичайним присвоєнням такого ефекту не досягти. "\r\r\r\r\r\r\r\r'
}OmEntry {
	#tags : {
		#timestamp : DateAndTime [ '2025-10-04T21:33:14.6+03:00' ],
		#self : OmReference [ '6' ]
	},
	#content : '"--------------------------------------------------------------------------------------\r*                      ЛАБОРОТОРНА РОБОТА 3\r*                 Тема: КЛАСИ ТА МЕТОДИ. КОЛЕКЦІЇ\r*\r*  Завдання до лабораторної роботи:\r*     1. Виконайте наведені нижче приклади, збережіть і поясніть отримані результати.\r*     2. Випробуйте різноманітні способи додавання нових класів до системи.\r*     3. Навчіться доповнювати функціональність класів.\r*     4. Випробуйте методи опрацювання колекцій.\r*\r\r    Виконайте за допомогою <Print it> \r\r ------ ПРИНАЛЕЖНІСТЬ КЛАСОВІ, ІЄРАРХІЯ КЛАСІВ\r"\r    #(Francesca Jackie Marisa Bree) class. "Array"\r    (#(Francesca Jackie Marisa Bree) at:2) class. "ByteSymbol"\r    \'Rakesh Vijay Charles Daniel Tyler\' class. "ByteString"\r    (\'Rakesh Vijay Charles Daniel Tyler\' at:2) class. "Character (a)"\r    World class . "WorldMorph"\r    Magnitude class. "Magnitude class"\r    Magnitude class class. "Metaclass"\r    nil class. "UndefinedObject"\r    5 species. "SmallInteger"\r    123456789000 species. "SmallInteger"\r    #aName species. "ByteString"\r " Яка різниця між повідомленнями class i species ? \r   Відповідь: \r\tclass – це «хто я є?»\r\tspecies – це «якого типу нові колекції я породжую?»\r\r    Випробуйте різні способи відкривання браузера класів: за допомогою меню чи програмно \r     Виконайте за допомогою <Do it>\r"\r    ClyFullBrowserMorph open. \r    ClyFullBrowserMorph openOnClass: Date. \r    ClyFullBrowserMorph openOnClass: VolumeShape  selector:  #volume. \r\r" ------ МЕТОДИ КЛАСУ, КОНСТРУКТОРИ\r  Виконайте за допомогою <Print It>. Запропонуйте власні приклади. "\r\r    Array new: 10. "#(nil nil nil nil nil nil nil nil nil nil)"        \r    OrderedCollection  new. "an OrderedCollection()"\r    Date today. "29 September 2025"\r    Time now. "10:28:52.422 am"\r    UIManager default  request:\'How are you?\' initialAnswer:\'I\'\'m fine!\'. "\'I\'\'m fine!\'"\r    Integer readFrom: \'2013  1925\'. "2013"\r    Integer primesUpTo: 100. "#(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97)"\r    Rectangle origin:0@0 corner:200@100. "(0@0) corner: (200@100)"\r    Date nameOfMonth:12. "#December"\r    Date dayOfWeek: #Friday. "6"\r    Date orthodoxEasterDateFor: 2022. "24 April 2022"\r\r\r   \r"Інсталюйте вказані нижче МЕТОДИ КЛАСУ Date:\r  перенесіть копію тексту визначення методу з робочого вікна в браузер класів.\r\r""!Date class methodsFor: \'specific inquiries\' stamp: \'CamilloBruni 8/22/2013 19:47\'!""\r\rorthodoxEasterDateFor: year\r ""  compute the easter date according to the rules of the orthodox calendar.\r    source:       http://www.smart.net/~mmontes/ortheast.html   ""\r     | r1 r2 r3 r4 ra rb r5 rc date |\r\r    r1 := year \\\\ 19.\r    r2 := year \\\\ 4.\r    r3 := year \\\\ 7.\r    ra := 19*r1 + 16.\r    r4 := ra \\\\ 30.\r    rb := r2 + r2 + (4*r3) + (6*r4).\r    r5 := rb \\\\ 7.\r    rc := r4 + r5.\r    date := self year: year month: 4 day: 3.\r    ^date addDays: rc.\r""--------------------------------------------------------------------------------------""\r""!Date class methodsFor: \'specific inquiries\' stamp: \'CamilloBruni 8/22/2013 19:48\'!""\r\reasterDateFor: year\r ""  compute the easter date.\r    source: Physikalisch-Technische Bundesanstalt Braunschweig.\r    Lichtenberg, H.: Zur Interpretation der Gaussschen Osterformel und ihrer Ausnahmeregeln, Historia Mathematica 24 (1997), pp. 441-444\r      http://www.ptb.de/de/org/4/44/441/oste.htm  ""\r\r  | k m s a d r og sz oe day |\r\r  k := year // 100.\r  m := 15 + (3*k + 3//4) - (8*k + 13//25).\r   s := 2 - (3*k + 3// 4).\r  a := year \\\\ 19.\r  d := 19*a + m \\\\ 30.\r  r := d//29 + ((d//28) - (d//29)* (a// 11)).\r\r  og := 21 + d - r.\r  sz := 7 - (year//4 + year + s\\\\7).\r  oe := 7 - (og - sz\\\\7).\r  day := og + oe.\r  ^day <= 31\r    ifTrue: [ Date year: year month: 3 day: day ]\r    ifFalse: [ Date year: year month: 4 day: day - 31 ].\r"\r\r"Знайдіть роки, коли святкування припадають на один день."\r\ryearsWithMatchingEasterFrom: startYear to: endYear\r    "Повертає список років, коли православна і католицька Пасха припадають на один день"\r    | matchingYears orthodoxDate catholicDate |\r    matchingYears := OrderedCollection new.\r    (startYear to: endYear) do: [:year |\r        orthodoxDate := self orthodoxEasterDateFor: year.\r        catholicDate := self easterDateFor: year.\r        (orthodoxDate = catholicDate) ifTrue: [\r            matchingYears add: year\r        ].\r    ].\r    ^matchingYears asArray\r\rDate yearsWithMatchingEasterFrom: 2000 to: 2050.\r\r" ------ РЕКУРСІЯ\r  Додайте до класу Integer і випробуйте різні методи обчислення чисел  Фібоначчі.\r  Запропонуйте власні. Порівняйте їхню ефективність.      \r  Перед випробуванням fibonacci ЗБЕРЕЖІТЬ ІМІДЖ СИСТЕМИ! Він може зайняти Ваш комп на тиждень.  "\r\r3 fibStart: 1 with: 10  "<-- 12"\r4 fibo "<-- 5"\r12 fibonacci "<-- 233"\r\r\r"\r==============\rВласні методи:\r==============\r\r- Метод 1:\rInteger >> factorial\r    ""Обчислення факторіалу числа""\r    ^ self <= 1 ifTrue: [1] ifFalse: [self * (self - 1) factorial].\r\r- Метод 2:\rInteger >> sumTo\r    ""Сума всіх чисел від 1 до self""\r    | sum i |\r    sum := 0.\r    1 to: self do: [:i | sum := sum + i].\r    ^ sum.\r"\r\r"\rПояснення: <fibStart:with:>\rРекурсивний метод, який обчислює n-те число Фібоначчі, використовуючи два акумулятори: n1 (попереднє) і n2 (пред-попереднє).\rРекурсія: (self - 1) fibStart: n1+n2 with: n1 → наступний крок отримує нове попереднє число як суму двох попередніх.\r\rДуже швидкий для будь-якого n, навіть великого. Не обчислює одні й ті ж значення повторно → O(n). \rПам’яті потрібно лише для стеку рекурсії (глибина n).\r\rПояснення: <fibo>\rПроста обгортка над <fibStart:with:.>\r\rПовністю така ж, як у fibStart:with:. Зручно викликати без ручного передавання початкових чисел.\r\rПояснення: <fibonacci>\rКласична рекурсія: F(n) = F(n-1) + F(n-2).\r\rДуже повільний для великих n. Обчислює одні й ті ж значення багато разів → експоненційна складність O(2ⁿ). \rМоже сильно навантажити процесор і стек викликів.\r"\r\r"------------------------------------------------------------------------------------\r ------ СТВОРЕННЯ, ОПРАЦЮВАННЯ КОЛЕКЦІЙ\r  У текстовому файлі записано інформацію про матрицю цілих чисел: розміри\r  матриці в першому рядку файла, у всіх наступних рядках - рядки матриці.}\r  Прочитати матрицю, знайти максимальні елементи кожного рядка і зберегти\r  їх у файлі. Надрукувати максимальний елемент цілої матриці."\r\r"Наведений нижче код можна виконати безпосередньо в робочому вікні,\r проте,  доцільно зробити його методом власного навчального класу."\r\r| matr fStream fName n m mMatr mLines |\r        "Вибір файла за допомогою діалогу"\r    (fName:=UIManager default\r\t\t\tchooseFullFileNameMatching: nil \r\t\t\tlabel: \'Виберіть файл з числовими даними\' ) isNil\r        ifTrue: [ ^\'Ви не вибрали файла\' ]. \r        fStream := fName asFileReference readStream.\r\t        "Введення даних"\r \t    n := Integer readFrom: fStream.  \r\t    matr := Array new: n.\r\t    m := Integer readFrom: fStream.\r\t    matr := matr collect: [ :x | Array new: m ]. \r\t    1 to: n do: [ :i |  fStream nextLine.\r \t\t     matr at: i put: (\r\t\t\t\t (matr at: i) collect: [ :x |  \r\t\t\t\t\t\tInteger readFrom: fStream. ]\r\t\t\t\t\t )\t ].\r    fStream close. matr inspect.\r        "Обчислення максимальних елементів"\r    mLines:=matr collect: [ :r | r inject: (r at: 1) into: [ :x :y | x max: y] ].\r    mMatr:=mLines at: 1.\r    mLines do: [ :x | x > mMatr ifTrue: [ mMatr := x ] ].\r        "Побудова імені файла результатів, збереження"\r    fName at: fName size - 4 put: $_ .\r    fStream := fName asFileReference writeStream.\r    mLines do: [ :x | x printOn: fStream. fStream cr ].\r    fStream close.\r    ^mMatr .  \r\r" Поясніть код, наведений вище (кожне повідомлення!):\r\r\t| matr fStream fName n m mMatr mLines | <-- Локальні змінні\r\r\tВідкриваємо діалог вибору файлу. Якщо користувач не вибрав файл – повертаємо повідомлення:\r\t(fName := UIManager default\r\t    chooseFullFileNameMatching: nil\r\t    label: \'Виберіть файл з числовими даними\') isNil\r\t    ifTrue: [ ^\'Ви не вибрали файла\' ].\r\r\tfStream := fName asFileReference readStream. <-- Відкриваємо потік для читання файлу\r\tn := Integer readFrom: fStream. <-- Читаємо перше число з файлу – кількість рядків матриці\r\tmatr := Array new: n. <-- Створюємо масив для рядків матриці:\r\tm := Integer readFrom: fStream. <-- Читаємо друге число з файлу – кількість стовпців матриці\r\tmatr := matr collect: [:x | Array new: m]. <-- Заповнюємо кожен рядок новим масивом стовпців (масив масивів)\r\r\tПроходимо по кожному рядку:\r\t - пропускаємо порожню або заголовочну лінію\r\t - читаємо числа рядка і записуємо у відповідний рядок матриці:\r\t1 to: n do: [:i |\r\t    fStream nextLine.\r\t    matr at: i put: (\r\t        (matr at: i) collect: [:x | Integer readFrom: fStream]\r\t    )].\r\r\tfStream close. <-- Закриваємо потік після читання\r\tmatr inspect. <-- Відкриваємо інспектор для перегляду матриці\r\r\tОбчислюємо максимум у кожному рядку:\r\t - inject: використовується для проходження елементів\r\t - функція x max: y повертає більший елемент\r\tmLines := matr collect: [:r | r inject: (r at: 1) into: [:x :y | x max: y]].\r\r\tЗнаходимо загальний максимум матриці:\r\t - проходимо по максимумам рядків і оновлюємо mMatr:\r\tmMatr := mLines at: 1.\r\tmLines do: [:x | x > mMatr ifTrue: [ mMatr := x ]].\r\r\tfName at: fName size - 4 put: $_. <-- Змінюємо розширення файлу для збереження результатів\r\tfStream := fName asFileReference writeStream. <-- Відкриваємо потік для запису у файл\r\tmLines do: [:x | x printOn: fStream. fStream cr]. <-- Записуємо максимуми рядків у файл, кожен на новий рядок\r\tfStream close. <-- Закриваємо файл після запису\r\t^ mMatr. <-- Повертаємо максимальний елемент всієї матриці\r\r   Як замінити масивмасивів на екземпляр класу Matrix?:\r\tMatrix замінює масив масивів, тобто ми маємо одну структуру n × m. До елементів доступ через at: i at: j.\r\tЦе дозволяє компактно читати дані з файлу, знаходити максимуми і записувати результати, не створюючи додаткових масивів рядків:\r\t\r\t| matr fStream n m mMatr |\r\r\tВідкриваємо файл та читаємо розміри:\r\tfStream := \'file.txt\' asFileReference readStream.\r\tn := Integer readFrom: fStream.\r\tm := Integer readFrom: fStream.\r\r\tСтворюємо і заповнюємо матрицю:\r\tmatr := Matrix rows: n columns: m.\r\t1 to: n do: [:i | 1 to: m do: [:j | matr at: i at: j put: Integer readFrom: fStream]].\r\tfStream close.\r\r\tЗнаходимо загальний максимум:\r\tmMatr := (1 to: n) inject: 0 into: [:maxRow :i | maxRow max: ((1 to: m) inject: 0 into: [:maxCol :j | maxCol max: (matr at: i at: j)])].\r\t^ mMatr.\r\r======================================================\r\r ------ АДРЕСНА КНИГА\r Приклад створення і використання адресної книги, описаний у одній з лекцій. \r Пригадуєте, спочатку оголошуємо глобальну змінну, що міститиме впорядковану \r колекцію масивів з трьох рядків. Спосіб порівняння описує бінарний блок.    "\r\r    Smalltalk globals at: #AddressBook\r              put:(SortedCollection sortBlock:[:a :b | (a at:1)<=(b at:1)]).\r\r" * --- Тепер до книги можна додавати записи. "\r\r    AddressBook\r            add: #(\'Ruth\' \'Babe\' \'456 Mudville Flats\');\r            add: #(\'Smith\' \'John\' \'12/5 Park Ave\');\r            add: #(\'Jexon\' \'John\' \'5 Baverli Hills\');\r            add: #(\'Adams\' \'John\' \'1 Hell str\');\r            add: #(\'Taylor\' \'Babe\' \'2a/35 Deribas str\');\r            add: #(\'Greg\' \'Voss\' \'12345 the USA\')."<-- #(\'Greg\' \'Voss\' \'12345 the USA\')"\r\r" * --- Додайте власні записи. Видрукуйте вміст книги (код запропоновано нижче)."\r   | s w |  s := WriteStream on: String new.\r\r    AddressBook do:[:x | x do:\r        [ :y | s nextPutAll: y; tab; tab.].\r        s cr. ]. "<-- a SortedCollection(#(\'Adams\' \'John\' \'1 Hell str\') \r\t\t\t\t\t  #(\'Greg\' \'Voss\' \'12345 the USA\') #(\'Jexon\' \'John\' \'5 Baverli Hills\') \r\t\t\t\t\t  #(\'Ruth\' \'Babe\' \'456 Mudville Flats\') #(\'Smith\' \'John\' \'12/5 Park Ave\') \r\t\t\t\t\t  #(\'Taylor\' \'Babe\' \'2a/35 Deribas str\'))"\r\r\tAddressBook\r    add: #(\'Brown\' \'Alice\' \'7 Cherry Lane\');\r    add: #(\'White\' \'Bob\' \'15 Oak Street\');\r    add: #(\'Green\' \'Clara\' \'9 Pine Avenue\').\r\r\t  \r\ts := WriteStream on: String new.\r\tAddressBook do: [ :x | x do: [ :y | s nextPutAll: y; tab; tab. ] ] \r\t\r\t" Я трохи начудив з додаванням записів, тому ось такий результат:\r\ta SortedCollection(#(\'Adams\' \'John\' \'1 Hell str\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Greg\' \'Voss\' \'12345 the USA\') #(\'Jexon\' \'John\' \'5 Baverli Hills\') #(\'Oleh\' \'Chyzhov\' \'MyAddress 23\') #(\'Oleh\' \'Chyzhov\' \'MyAddress 23\') #(\'Oleh\' \'Chyzhov\' \'ofjidjf\') #(\'Oleh\' \'Chyzhov\' \'frjgirgjir\') #(\'Ruth\' \'Babe\' \'456 Mudville Flats\') #(\'Smith\' \'John\' \'12/5 Park Ave\') #(\'Taylor\' \'Babe\' \'2a/35 Deribas str\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'oleh\' \'chyzhov\' \'myaddress 23\'))"\r\r\r  w := Workspace openLabel: \'My Address Book\'.\r  w contents: s contents.\r\r" * ----  Наступне завдання - надрукувати список прізвищ людей з однаковими іменами. \r              Приклад демонструє різні способи перебору та перетворення колекцій."\r\r | firstNames duplicates |\r    firstNames:=Bag new.        "утворимо торбу імен"\r    AddressBook do: [ :entry | firstNames add: (entry at: 2) ]. "<-- a SortedCollection(#(\'Adams\' \'John\' \'1 Hell str\') #(\'Greg\' \'Voss\' \'12345 the USA\') \r\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t#(\'Jexon\' \'John\' \'5 Baverli Hills\') #(\'Ruth\' \'Babe\' \'456 Mudville Flats\') #(\'Smith\' \'John\' \'12/5 Park Ave\')\r\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t#(\'Taylor\' \'Babe\' \'2a/35 Deribas str\'))"\r\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r        "виберемо ті імена, які зустрічаються більше одного разу"\r    duplicates:=firstNames select:\r        [ :name | (firstNames occurrencesOf: name)>1 ]. "<-- a Bag(\'John\' \'John\' \'John\' \'Babe\' \'Babe\')"\r            "і впорядкуємо їх"\r    duplicates:=duplicates asSet asSortedCollection. "<-- a SortedCollection(\'Babe\' \'John\')"\r        "друкуємо імена та відповідні їм прізвища"\r    duplicates do: [ :first | first printOn: Transcript. Transcript show:\'==>\'.\r        AddressBook do: [ :entry | (entry at: 2)=first\r            ifTrue: [ Transcript show:\' \'. (entry at: 1) printOn: Transcript ] ].\r        Transcript cr ]. Transcript show:\' \'.\r\r" Поясніть перетворення, що відбуваються в цьому фрагменті:\r\tBag — дозволяє зберігати елементи з повтореннями.\r\tselect: — фільтрує колекцію, залишаючи тільки елементи, що задовольняють умові (тут, occurrencesOf: > 1).\r\tasSet — видаляє дублікати після фільтрації.\r\tasSortedCollection — сортує результати для зручного виводу.\r\tdo: — ітерує колекцію і виконує дію (друк у Transcript).\r\r   Запропонуйте власні варіанти використання та перетворення колекцій. \r \r  Оформіть запропоновані вище фрагменти як методи навчального класу:\r\tObject subclass: #AddressBookUtils\r    \tinstanceVariableNames: \'\'\r    \tclassVariableNames: \'\'\r    \tpoolDictionaries: \'\'\r    \tcategory: \'Training-Examples\'.\r\r"\r\r\r" ------ ДОДАВАННЯ АДРЕС\r  Можливо, додавання записів до AddressBook за допомогою явного програмування \r  виглядає не надто привабливо. Використайте з цією метою діалоги "\r\r| a b c | \ra := UIManager default request: \'Input first name\'.\rb := UIManager default request: \'Input second name\'.\rc := UIManager default request: \'Input address\'.\ra isNil | b isNil | c isNil ifFalse: [ AddressBook add: (Array with:a with:b with:c)]. "<-- #(\'Oleh\' \'Chyzhov\' \'MyAddress 23\')"\r\r" Додайте до книги декілька нових записів, знову видрукуйте її. "\r"Через це в книзі так багато записів:"\r[\r    | a b c |\r    a := UIManager default request: \'Input first name\'.\r    a isNil ifTrue: [ ^self ].  "Cancel завершує цикл"\r\r    b := UIManager default request: \'Input second name\'.\r    b isNil ifTrue: [ ^self ].\r\r    c := UIManager default request: \'Input address\'.\r    c isNil ifTrue: [ ^self ].\r\r    AddressBook add: (Array with: a with: b with: c).\r] repeat.\r\r\ts := WriteStream on: String new.\r\tAddressBook do: [ :x | x do: [ :y | s nextPutAll: y; tab; tab. ] ] "<--  \r\ta SortedCollection(\r\t#(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') \r\t#(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') \r\t#(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'Adams\' \'John\' \'1 Hell str\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') \r\t#(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') \r\t#(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Greg\' \'Voss\' \'12345 the USA\') #(\'Jexon\' \'John\' \'5 Baverli Hills\') \r\t#(\'Oleh\' \'Chyzhov\' \'MyAddress 23\') #(\'Oleh\' \'Chyzhov\' \'MyAddress 23\') #(\'Oleh\' \'Chyzhov\' \'ofjidjf\') #(\'Oleh\' \'Chyzhov\' \'frjgirgjir\') #(\'Ruth\' \'Babe\' \'456 Mudville Flats\') \r\t#(\'Smith\' \'John\' \'12/5 Park Ave\') #(\'Taylor\' \'Babe\' \'2a/35 Deribas str\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'White\' \'Bob\' \'15 Oak Street\') \r\t#(\'White\' \'Bob\' \'15 Oak Street\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'oleh\' \'chyzhov\' \'myaddress 23\'))"\r\r" Поміркуйте, як зробити зручнішим звертання до діалогу додавання адрес та друку адресної книги. \rМожна винести логіку у клас: один метод відповідатиме за введення одного запису. Інший — за введення кількох записів. Ще інший — за друк книги"\r\r" Що станеться, якщо виконати наступний код? Випробуйте. "\r    Smalltalk globals removeKey:#AddressBook. "<-- з глобального словника Smalltalk globals буде видалено ключ #AddressBook і, відповідно, саму твою колекцію (адресну книгу)."\r\r "------ ПЕРЕТВОРЕННЯ (ПЕРЕВТІЛЕННЯ) ОБ\'ЄКТІВ\r   Виконайте за допомогою Do It. "\r\r | a b c|\r    a := OrderedCollection new.\r    b := Cylinder new.\r    c := Array with: a with: b with: b.\r    Transcript show: \'Old Array is = \'.\r    c do: [ :x | Transcript show: \'     \'. x printOn: Transcript ].\r    Transcript cr.\r    a become: b.\r    Transcript show: \'New Array is = \'.\r    c do: [ :x | Transcript show: \'     \'. x printOn: Transcript ].\r    Transcript cr; show:\' \'. "<-- Unknown variable"\r\r" Поясніть дію методу become:. Чи можна замість нього користуватися звичайним присвоєнням? Наведіть власні приклади. "\r\r" Метод become: міняє всі посилання на два об’єкти місцями у всій системі.  \r  Це відрізняється від простого присвоєння, яке змінює лише одну змінну.  \r  У прикладі масив c до become: містив [OrderedCollection, Cylinder, Cylinder],  \r  а після become: став [Cylinder, OrderedCollection, OrderedCollection].  \r  Звичайним присвоєнням такого ефекту не досягти. "\r\r\r\r\r\r\r\r'
}OmEntry {
	#tags : {
		#timestamp : DateAndTime [ '2025-10-04T21:33:31.938+03:00' ],
		#self : OmReference [ '7' ]
	},
	#content : '"--------------------------------------------------------------------------------------\r*                      ЛАБОРОТОРНА РОБОТА 3\r*                 Тема: КЛАСИ ТА МЕТОДИ. КОЛЕКЦІЇ\r*\r*  Завдання до лабораторної роботи:\r*     1. Виконайте наведені нижче приклади, збережіть і поясніть отримані результати.\r*     2. Випробуйте різноманітні способи додавання нових класів до системи.\r*     3. Навчіться доповнювати функціональність класів.\r*     4. Випробуйте методи опрацювання колекцій.\r*\r\r    Виконайте за допомогою <Print it> \r\r ------ ПРИНАЛЕЖНІСТЬ КЛАСОВІ, ІЄРАРХІЯ КЛАСІВ\r"\r    #(Francesca Jackie Marisa Bree) class. "Array"\r    (#(Francesca Jackie Marisa Bree) at:2) class. "ByteSymbol"\r    \'Rakesh Vijay Charles Daniel Tyler\' class. "ByteString"\r    (\'Rakesh Vijay Charles Daniel Tyler\' at:2) class. "Character (a)"\r    World class . "WorldMorph"\r    Magnitude class. "Magnitude class"\r    Magnitude class class. "Metaclass"\r    nil class. "UndefinedObject"\r    5 species. "SmallInteger"\r    123456789000 species. "SmallInteger"\r    #aName species. "ByteString"\r " Яка різниця між повідомленнями class i species ? \r   Відповідь: \r\tclass – це «хто я є?»\r\tspecies – це «якого типу нові колекції я породжую?»\r\r    Випробуйте різні способи відкривання браузера класів: за допомогою меню чи програмно \r     Виконайте за допомогою <Do it>\r"\r    ClyFullBrowserMorph open. \r    ClyFullBrowserMorph openOnClass: Date. \r    ClyFullBrowserMorph openOnClass: VolumeShape  selector:  #volume. \r\r" ------ МЕТОДИ КЛАСУ, КОНСТРУКТОРИ\r  Виконайте за допомогою <Print It>. Запропонуйте власні приклади. "\r\r    Array new: 10. "#(nil nil nil nil nil nil nil nil nil nil)"        \r    OrderedCollection  new. "an OrderedCollection()"\r    Date today. "29 September 2025"\r    Time now. "10:28:52.422 am"\r    UIManager default  request:\'How are you?\' initialAnswer:\'I\'\'m fine!\'. "\'I\'\'m fine!\'"\r    Integer readFrom: \'2013  1925\'. "2013"\r    Integer primesUpTo: 100. "#(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97)"\r    Rectangle origin:0@0 corner:200@100. "(0@0) corner: (200@100)"\r    Date nameOfMonth:12. "#December"\r    Date dayOfWeek: #Friday. "6"\r    Date orthodoxEasterDateFor: 2022. "24 April 2022"\r\r\r   \r"Інсталюйте вказані нижче МЕТОДИ КЛАСУ Date:\r  перенесіть копію тексту визначення методу з робочого вікна в браузер класів.\r\r""!Date class methodsFor: \'specific inquiries\' stamp: \'CamilloBruni 8/22/2013 19:47\'!""\r\rorthodoxEasterDateFor: year\r ""  compute the easter date according to the rules of the orthodox calendar.\r    source:       http://www.smart.net/~mmontes/ortheast.html   ""\r     | r1 r2 r3 r4 ra rb r5 rc date |\r\r    r1 := year \\\\ 19.\r    r2 := year \\\\ 4.\r    r3 := year \\\\ 7.\r    ra := 19*r1 + 16.\r    r4 := ra \\\\ 30.\r    rb := r2 + r2 + (4*r3) + (6*r4).\r    r5 := rb \\\\ 7.\r    rc := r4 + r5.\r    date := self year: year month: 4 day: 3.\r    ^date addDays: rc.\r""--------------------------------------------------------------------------------------""\r""!Date class methodsFor: \'specific inquiries\' stamp: \'CamilloBruni 8/22/2013 19:48\'!""\r\reasterDateFor: year\r ""  compute the easter date.\r    source: Physikalisch-Technische Bundesanstalt Braunschweig.\r    Lichtenberg, H.: Zur Interpretation der Gaussschen Osterformel und ihrer Ausnahmeregeln, Historia Mathematica 24 (1997), pp. 441-444\r      http://www.ptb.de/de/org/4/44/441/oste.htm  ""\r\r  | k m s a d r og sz oe day |\r\r  k := year // 100.\r  m := 15 + (3*k + 3//4) - (8*k + 13//25).\r   s := 2 - (3*k + 3// 4).\r  a := year \\\\ 19.\r  d := 19*a + m \\\\ 30.\r  r := d//29 + ((d//28) - (d//29)* (a// 11)).\r\r  og := 21 + d - r.\r  sz := 7 - (year//4 + year + s\\\\7).\r  oe := 7 - (og - sz\\\\7).\r  day := og + oe.\r  ^day <= 31\r    ifTrue: [ Date year: year month: 3 day: day ]\r    ifFalse: [ Date year: year month: 4 day: day - 31 ].\r"\r\r"Знайдіть роки, коли святкування припадають на один день."\r\ryearsWithMatchingEasterFrom: startYear to: endYear\r    "Повертає список років, коли православна і католицька Пасха припадають на один день"\r    | matchingYears orthodoxDate catholicDate |\r    matchingYears := OrderedCollection new.\r    (startYear to: endYear) do: [:year |\r        orthodoxDate := self orthodoxEasterDateFor: year.\r        catholicDate := self easterDateFor: year.\r        (orthodoxDate = catholicDate) ifTrue: [\r            matchingYears add: year\r        ].\r    ].\r    ^matchingYears asArray\r\rDate yearsWithMatchingEasterFrom: 2000 to: 2050. "#(2001 2004 2007 2010 2011 2014 2017 2025 2028 2031 2034 2037 2038 2041 2045 2048)"\r\r" ------ РЕКУРСІЯ\r  Додайте до класу Integer і випробуйте різні методи обчислення чисел  Фібоначчі.\r  Запропонуйте власні. Порівняйте їхню ефективність.      \r  Перед випробуванням fibonacci ЗБЕРЕЖІТЬ ІМІДЖ СИСТЕМИ! Він може зайняти Ваш комп на тиждень.  "\r\r3 fibStart: 1 with: 10  "<-- 12"\r4 fibo "<-- 5"\r12 fibonacci "<-- 233"\r\r\r"\r==============\rВласні методи:\r==============\r\r- Метод 1:\rInteger >> factorial\r    ""Обчислення факторіалу числа""\r    ^ self <= 1 ifTrue: [1] ifFalse: [self * (self - 1) factorial].\r\r- Метод 2:\rInteger >> sumTo\r    ""Сума всіх чисел від 1 до self""\r    | sum i |\r    sum := 0.\r    1 to: self do: [:i | sum := sum + i].\r    ^ sum.\r"\r\r"\rПояснення: <fibStart:with:>\rРекурсивний метод, який обчислює n-те число Фібоначчі, використовуючи два акумулятори: n1 (попереднє) і n2 (пред-попереднє).\rРекурсія: (self - 1) fibStart: n1+n2 with: n1 → наступний крок отримує нове попереднє число як суму двох попередніх.\r\rДуже швидкий для будь-якого n, навіть великого. Не обчислює одні й ті ж значення повторно → O(n). \rПам’яті потрібно лише для стеку рекурсії (глибина n).\r\rПояснення: <fibo>\rПроста обгортка над <fibStart:with:.>\r\rПовністю така ж, як у fibStart:with:. Зручно викликати без ручного передавання початкових чисел.\r\rПояснення: <fibonacci>\rКласична рекурсія: F(n) = F(n-1) + F(n-2).\r\rДуже повільний для великих n. Обчислює одні й ті ж значення багато разів → експоненційна складність O(2ⁿ). \rМоже сильно навантажити процесор і стек викликів.\r"\r\r"------------------------------------------------------------------------------------\r ------ СТВОРЕННЯ, ОПРАЦЮВАННЯ КОЛЕКЦІЙ\r  У текстовому файлі записано інформацію про матрицю цілих чисел: розміри\r  матриці в першому рядку файла, у всіх наступних рядках - рядки матриці.}\r  Прочитати матрицю, знайти максимальні елементи кожного рядка і зберегти\r  їх у файлі. Надрукувати максимальний елемент цілої матриці."\r\r"Наведений нижче код можна виконати безпосередньо в робочому вікні,\r проте,  доцільно зробити його методом власного навчального класу."\r\r| matr fStream fName n m mMatr mLines |\r        "Вибір файла за допомогою діалогу"\r    (fName:=UIManager default\r\t\t\tchooseFullFileNameMatching: nil \r\t\t\tlabel: \'Виберіть файл з числовими даними\' ) isNil\r        ifTrue: [ ^\'Ви не вибрали файла\' ]. \r        fStream := fName asFileReference readStream.\r\t        "Введення даних"\r \t    n := Integer readFrom: fStream.  \r\t    matr := Array new: n.\r\t    m := Integer readFrom: fStream.\r\t    matr := matr collect: [ :x | Array new: m ]. \r\t    1 to: n do: [ :i |  fStream nextLine.\r \t\t     matr at: i put: (\r\t\t\t\t (matr at: i) collect: [ :x |  \r\t\t\t\t\t\tInteger readFrom: fStream. ]\r\t\t\t\t\t )\t ].\r    fStream close. matr inspect.\r        "Обчислення максимальних елементів"\r    mLines:=matr collect: [ :r | r inject: (r at: 1) into: [ :x :y | x max: y] ].\r    mMatr:=mLines at: 1.\r    mLines do: [ :x | x > mMatr ifTrue: [ mMatr := x ] ].\r        "Побудова імені файла результатів, збереження"\r    fName at: fName size - 4 put: $_ .\r    fStream := fName asFileReference writeStream.\r    mLines do: [ :x | x printOn: fStream. fStream cr ].\r    fStream close.\r    ^mMatr .  \r\r" Поясніть код, наведений вище (кожне повідомлення!):\r\r\t| matr fStream fName n m mMatr mLines | <-- Локальні змінні\r\r\tВідкриваємо діалог вибору файлу. Якщо користувач не вибрав файл – повертаємо повідомлення:\r\t(fName := UIManager default\r\t    chooseFullFileNameMatching: nil\r\t    label: \'Виберіть файл з числовими даними\') isNil\r\t    ifTrue: [ ^\'Ви не вибрали файла\' ].\r\r\tfStream := fName asFileReference readStream. <-- Відкриваємо потік для читання файлу\r\tn := Integer readFrom: fStream. <-- Читаємо перше число з файлу – кількість рядків матриці\r\tmatr := Array new: n. <-- Створюємо масив для рядків матриці:\r\tm := Integer readFrom: fStream. <-- Читаємо друге число з файлу – кількість стовпців матриці\r\tmatr := matr collect: [:x | Array new: m]. <-- Заповнюємо кожен рядок новим масивом стовпців (масив масивів)\r\r\tПроходимо по кожному рядку:\r\t - пропускаємо порожню або заголовочну лінію\r\t - читаємо числа рядка і записуємо у відповідний рядок матриці:\r\t1 to: n do: [:i |\r\t    fStream nextLine.\r\t    matr at: i put: (\r\t        (matr at: i) collect: [:x | Integer readFrom: fStream]\r\t    )].\r\r\tfStream close. <-- Закриваємо потік після читання\r\tmatr inspect. <-- Відкриваємо інспектор для перегляду матриці\r\r\tОбчислюємо максимум у кожному рядку:\r\t - inject: використовується для проходження елементів\r\t - функція x max: y повертає більший елемент\r\tmLines := matr collect: [:r | r inject: (r at: 1) into: [:x :y | x max: y]].\r\r\tЗнаходимо загальний максимум матриці:\r\t - проходимо по максимумам рядків і оновлюємо mMatr:\r\tmMatr := mLines at: 1.\r\tmLines do: [:x | x > mMatr ifTrue: [ mMatr := x ]].\r\r\tfName at: fName size - 4 put: $_. <-- Змінюємо розширення файлу для збереження результатів\r\tfStream := fName asFileReference writeStream. <-- Відкриваємо потік для запису у файл\r\tmLines do: [:x | x printOn: fStream. fStream cr]. <-- Записуємо максимуми рядків у файл, кожен на новий рядок\r\tfStream close. <-- Закриваємо файл після запису\r\t^ mMatr. <-- Повертаємо максимальний елемент всієї матриці\r\r   Як замінити масивмасивів на екземпляр класу Matrix?:\r\tMatrix замінює масив масивів, тобто ми маємо одну структуру n × m. До елементів доступ через at: i at: j.\r\tЦе дозволяє компактно читати дані з файлу, знаходити максимуми і записувати результати, не створюючи додаткових масивів рядків:\r\t\r\t| matr fStream n m mMatr |\r\r\tВідкриваємо файл та читаємо розміри:\r\tfStream := \'file.txt\' asFileReference readStream.\r\tn := Integer readFrom: fStream.\r\tm := Integer readFrom: fStream.\r\r\tСтворюємо і заповнюємо матрицю:\r\tmatr := Matrix rows: n columns: m.\r\t1 to: n do: [:i | 1 to: m do: [:j | matr at: i at: j put: Integer readFrom: fStream]].\r\tfStream close.\r\r\tЗнаходимо загальний максимум:\r\tmMatr := (1 to: n) inject: 0 into: [:maxRow :i | maxRow max: ((1 to: m) inject: 0 into: [:maxCol :j | maxCol max: (matr at: i at: j)])].\r\t^ mMatr.\r\r======================================================\r\r ------ АДРЕСНА КНИГА\r Приклад створення і використання адресної книги, описаний у одній з лекцій. \r Пригадуєте, спочатку оголошуємо глобальну змінну, що міститиме впорядковану \r колекцію масивів з трьох рядків. Спосіб порівняння описує бінарний блок.    "\r\r    Smalltalk globals at: #AddressBook\r              put:(SortedCollection sortBlock:[:a :b | (a at:1)<=(b at:1)]).\r\r" * --- Тепер до книги можна додавати записи. "\r\r    AddressBook\r            add: #(\'Ruth\' \'Babe\' \'456 Mudville Flats\');\r            add: #(\'Smith\' \'John\' \'12/5 Park Ave\');\r            add: #(\'Jexon\' \'John\' \'5 Baverli Hills\');\r            add: #(\'Adams\' \'John\' \'1 Hell str\');\r            add: #(\'Taylor\' \'Babe\' \'2a/35 Deribas str\');\r            add: #(\'Greg\' \'Voss\' \'12345 the USA\')."<-- #(\'Greg\' \'Voss\' \'12345 the USA\')"\r\r" * --- Додайте власні записи. Видрукуйте вміст книги (код запропоновано нижче)."\r   | s w |  s := WriteStream on: String new.\r\r    AddressBook do:[:x | x do:\r        [ :y | s nextPutAll: y; tab; tab.].\r        s cr. ]. "<-- a SortedCollection(#(\'Adams\' \'John\' \'1 Hell str\') \r\t\t\t\t\t  #(\'Greg\' \'Voss\' \'12345 the USA\') #(\'Jexon\' \'John\' \'5 Baverli Hills\') \r\t\t\t\t\t  #(\'Ruth\' \'Babe\' \'456 Mudville Flats\') #(\'Smith\' \'John\' \'12/5 Park Ave\') \r\t\t\t\t\t  #(\'Taylor\' \'Babe\' \'2a/35 Deribas str\'))"\r\r\tAddressBook\r    add: #(\'Brown\' \'Alice\' \'7 Cherry Lane\');\r    add: #(\'White\' \'Bob\' \'15 Oak Street\');\r    add: #(\'Green\' \'Clara\' \'9 Pine Avenue\').\r\r\t  \r\ts := WriteStream on: String new.\r\tAddressBook do: [ :x | x do: [ :y | s nextPutAll: y; tab; tab. ] ] \r\t\r\t" Я трохи начудив з додаванням записів, тому ось такий результат:\r\ta SortedCollection(#(\'Adams\' \'John\' \'1 Hell str\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Greg\' \'Voss\' \'12345 the USA\') #(\'Jexon\' \'John\' \'5 Baverli Hills\') #(\'Oleh\' \'Chyzhov\' \'MyAddress 23\') #(\'Oleh\' \'Chyzhov\' \'MyAddress 23\') #(\'Oleh\' \'Chyzhov\' \'ofjidjf\') #(\'Oleh\' \'Chyzhov\' \'frjgirgjir\') #(\'Ruth\' \'Babe\' \'456 Mudville Flats\') #(\'Smith\' \'John\' \'12/5 Park Ave\') #(\'Taylor\' \'Babe\' \'2a/35 Deribas str\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'oleh\' \'chyzhov\' \'myaddress 23\'))"\r\r\r  w := Workspace openLabel: \'My Address Book\'.\r  w contents: s contents.\r\r" * ----  Наступне завдання - надрукувати список прізвищ людей з однаковими іменами. \r              Приклад демонструє різні способи перебору та перетворення колекцій."\r\r | firstNames duplicates |\r    firstNames:=Bag new.        "утворимо торбу імен"\r    AddressBook do: [ :entry | firstNames add: (entry at: 2) ]. "<-- a SortedCollection(#(\'Adams\' \'John\' \'1 Hell str\') #(\'Greg\' \'Voss\' \'12345 the USA\') \r\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t#(\'Jexon\' \'John\' \'5 Baverli Hills\') #(\'Ruth\' \'Babe\' \'456 Mudville Flats\') #(\'Smith\' \'John\' \'12/5 Park Ave\')\r\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t#(\'Taylor\' \'Babe\' \'2a/35 Deribas str\'))"\r\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r        "виберемо ті імена, які зустрічаються більше одного разу"\r    duplicates:=firstNames select:\r        [ :name | (firstNames occurrencesOf: name)>1 ]. "<-- a Bag(\'John\' \'John\' \'John\' \'Babe\' \'Babe\')"\r            "і впорядкуємо їх"\r    duplicates:=duplicates asSet asSortedCollection. "<-- a SortedCollection(\'Babe\' \'John\')"\r        "друкуємо імена та відповідні їм прізвища"\r    duplicates do: [ :first | first printOn: Transcript. Transcript show:\'==>\'.\r        AddressBook do: [ :entry | (entry at: 2)=first\r            ifTrue: [ Transcript show:\' \'. (entry at: 1) printOn: Transcript ] ].\r        Transcript cr ]. Transcript show:\' \'.\r\r" Поясніть перетворення, що відбуваються в цьому фрагменті:\r\tBag — дозволяє зберігати елементи з повтореннями.\r\tselect: — фільтрує колекцію, залишаючи тільки елементи, що задовольняють умові (тут, occurrencesOf: > 1).\r\tasSet — видаляє дублікати після фільтрації.\r\tasSortedCollection — сортує результати для зручного виводу.\r\tdo: — ітерує колекцію і виконує дію (друк у Transcript).\r\r   Запропонуйте власні варіанти використання та перетворення колекцій. \r \r  Оформіть запропоновані вище фрагменти як методи навчального класу:\r\tObject subclass: #AddressBookUtils\r    \tinstanceVariableNames: \'\'\r    \tclassVariableNames: \'\'\r    \tpoolDictionaries: \'\'\r    \tcategory: \'Training-Examples\'.\r\r"\r\r\r" ------ ДОДАВАННЯ АДРЕС\r  Можливо, додавання записів до AddressBook за допомогою явного програмування \r  виглядає не надто привабливо. Використайте з цією метою діалоги "\r\r| a b c | \ra := UIManager default request: \'Input first name\'.\rb := UIManager default request: \'Input second name\'.\rc := UIManager default request: \'Input address\'.\ra isNil | b isNil | c isNil ifFalse: [ AddressBook add: (Array with:a with:b with:c)]. "<-- #(\'Oleh\' \'Chyzhov\' \'MyAddress 23\')"\r\r" Додайте до книги декілька нових записів, знову видрукуйте її. "\r"Через це в книзі так багато записів:"\r[\r    | a b c |\r    a := UIManager default request: \'Input first name\'.\r    a isNil ifTrue: [ ^self ].  "Cancel завершує цикл"\r\r    b := UIManager default request: \'Input second name\'.\r    b isNil ifTrue: [ ^self ].\r\r    c := UIManager default request: \'Input address\'.\r    c isNil ifTrue: [ ^self ].\r\r    AddressBook add: (Array with: a with: b with: c).\r] repeat.\r\r\ts := WriteStream on: String new.\r\tAddressBook do: [ :x | x do: [ :y | s nextPutAll: y; tab; tab. ] ] "<--  \r\ta SortedCollection(\r\t#(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') \r\t#(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') \r\t#(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'Adams\' \'John\' \'1 Hell str\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') \r\t#(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') \r\t#(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Greg\' \'Voss\' \'12345 the USA\') #(\'Jexon\' \'John\' \'5 Baverli Hills\') \r\t#(\'Oleh\' \'Chyzhov\' \'MyAddress 23\') #(\'Oleh\' \'Chyzhov\' \'MyAddress 23\') #(\'Oleh\' \'Chyzhov\' \'ofjidjf\') #(\'Oleh\' \'Chyzhov\' \'frjgirgjir\') #(\'Ruth\' \'Babe\' \'456 Mudville Flats\') \r\t#(\'Smith\' \'John\' \'12/5 Park Ave\') #(\'Taylor\' \'Babe\' \'2a/35 Deribas str\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'White\' \'Bob\' \'15 Oak Street\') \r\t#(\'White\' \'Bob\' \'15 Oak Street\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'oleh\' \'chyzhov\' \'myaddress 23\'))"\r\r" Поміркуйте, як зробити зручнішим звертання до діалогу додавання адрес та друку адресної книги. \rМожна винести логіку у клас: один метод відповідатиме за введення одного запису. Інший — за введення кількох записів. Ще інший — за друк книги"\r\r" Що станеться, якщо виконати наступний код? Випробуйте. "\r    Smalltalk globals removeKey:#AddressBook. "<-- з глобального словника Smalltalk globals буде видалено ключ #AddressBook і, відповідно, саму твою колекцію (адресну книгу)."\r\r "------ ПЕРЕТВОРЕННЯ (ПЕРЕВТІЛЕННЯ) ОБ\'ЄКТІВ\r   Виконайте за допомогою Do It. "\r\r | a b c|\r    a := OrderedCollection new.\r    b := Cylinder new.\r    c := Array with: a with: b with: b.\r    Transcript show: \'Old Array is = \'.\r    c do: [ :x | Transcript show: \'     \'. x printOn: Transcript ].\r    Transcript cr.\r    a become: b.\r    Transcript show: \'New Array is = \'.\r    c do: [ :x | Transcript show: \'     \'. x printOn: Transcript ].\r    Transcript cr; show:\' \'. "<-- Unknown variable"\r\r" Поясніть дію методу become:. Чи можна замість нього користуватися звичайним присвоєнням? Наведіть власні приклади. "\r\r" Метод become: міняє всі посилання на два об’єкти місцями у всій системі.  \r  Це відрізняється від простого присвоєння, яке змінює лише одну змінну.  \r  У прикладі масив c до become: містив [OrderedCollection, Cylinder, Cylinder],  \r  а після become: став [Cylinder, OrderedCollection, OrderedCollection].  \r  Звичайним присвоєнням такого ефекту не досягти. "\r\r\r\r\r\r\r\r'
}OmEntry {
	#tags : {
		#timestamp : DateAndTime [ '2025-10-04T21:34:13.469+03:00' ],
		#self : OmReference [ '8' ]
	},
	#content : '"--------------------------------------------------------------------------------------\r*                      ЛАБОРОТОРНА РОБОТА 3\r*                 Тема: КЛАСИ ТА МЕТОДИ. КОЛЕКЦІЇ\r*\r*  Завдання до лабораторної роботи:\r*     1. Виконайте наведені нижче приклади, збережіть і поясніть отримані результати.\r*     2. Випробуйте різноманітні способи додавання нових класів до системи.\r*     3. Навчіться доповнювати функціональність класів.\r*     4. Випробуйте методи опрацювання колекцій.\r*\r\r    Виконайте за допомогою <Print it> \r\r ------ ПРИНАЛЕЖНІСТЬ КЛАСОВІ, ІЄРАРХІЯ КЛАСІВ\r"\r    #(Francesca Jackie Marisa Bree) class. "Array"\r    (#(Francesca Jackie Marisa Bree) at:2) class. "ByteSymbol"\r    \'Rakesh Vijay Charles Daniel Tyler\' class. "ByteString"\r    (\'Rakesh Vijay Charles Daniel Tyler\' at:2) class. "Character (a)"\r    World class . "WorldMorph"\r    Magnitude class. "Magnitude class"\r    Magnitude class class. "Metaclass"\r    nil class. "UndefinedObject"\r    5 species. "SmallInteger"\r    123456789000 species. "SmallInteger"\r    #aName species. "ByteString"\r " Яка різниця між повідомленнями class i species ? \r\r    Випробуйте різні способи відкривання браузера класів: за допомогою меню чи програмно \r     Виконайте за допомогою <Do it>\r"\r    ClyFullBrowserMorph open. \r    ClyFullBrowserMorph openOnClass: Date. \r    ClyFullBrowserMorph openOnClass: VolumeShape  selector:  #volume. \r\r" ------ МЕТОДИ КЛАСУ, КОНСТРУКТОРИ\r  Виконайте за допомогою <Print It>. Запропонуйте власні приклади. "\r\r    Array new: 10. "#(nil nil nil nil nil nil nil nil nil nil)"        \r    OrderedCollection  new. "an OrderedCollection()"\r    Date today. "29 September 2025"\r    Time now. "10:28:52.422 am"\r    UIManager default  request:\'How are you?\' initialAnswer:\'I\'\'m fine!\'. "\'I\'\'m fine!\'"\r    Integer readFrom: \'2013  1925\'. "2013"\r    Integer primesUpTo: 100. "#(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97)"\r    Rectangle origin:0@0 corner:200@100. "(0@0) corner: (200@100)"\r    Date nameOfMonth:12. "#December"\r    Date dayOfWeek: #Friday. "6"\r    Date orthodoxEasterDateFor: 2022. "24 April 2022"\r\r\r   \r"Інсталюйте вказані нижче МЕТОДИ КЛАСУ Date:\r  перенесіть копію тексту визначення методу з робочого вікна в браузер класів.\r\r""!Date class methodsFor: \'specific inquiries\' stamp: \'CamilloBruni 8/22/2013 19:47\'!""\r\rorthodoxEasterDateFor: year\r ""  compute the easter date according to the rules of the orthodox calendar.\r    source:       http://www.smart.net/~mmontes/ortheast.html   ""\r     | r1 r2 r3 r4 ra rb r5 rc date |\r\r    r1 := year \\\\ 19.\r    r2 := year \\\\ 4.\r    r3 := year \\\\ 7.\r    ra := 19*r1 + 16.\r    r4 := ra \\\\ 30.\r    rb := r2 + r2 + (4*r3) + (6*r4).\r    r5 := rb \\\\ 7.\r    rc := r4 + r5.\r    date := self year: year month: 4 day: 3.\r    ^date addDays: rc.\r""--------------------------------------------------------------------------------------""\r""!Date class methodsFor: \'specific inquiries\' stamp: \'CamilloBruni 8/22/2013 19:48\'!""\r\reasterDateFor: year\r ""  compute the easter date.\r    source: Physikalisch-Technische Bundesanstalt Braunschweig.\r    Lichtenberg, H.: Zur Interpretation der Gaussschen Osterformel und ihrer Ausnahmeregeln, Historia Mathematica 24 (1997), pp. 441-444\r      http://www.ptb.de/de/org/4/44/441/oste.htm  ""\r\r  | k m s a d r og sz oe day |\r\r  k := year // 100.\r  m := 15 + (3*k + 3//4) - (8*k + 13//25).\r   s := 2 - (3*k + 3// 4).\r  a := year \\\\ 19.\r  d := 19*a + m \\\\ 30.\r  r := d//29 + ((d//28) - (d//29)* (a// 11)).\r\r  og := 21 + d - r.\r  sz := 7 - (year//4 + year + s\\\\7).\r  oe := 7 - (og - sz\\\\7).\r  day := og + oe.\r  ^day <= 31\r    ifTrue: [ Date year: year month: 3 day: day ]\r    ifFalse: [ Date year: year month: 4 day: day - 31 ].\r"\r\r"Знайдіть роки, коли святкування припадають на один день."\r\ryearsWithMatchingEasterFrom: startYear to: endYear\r    "Повертає список років, коли православна і католицька Пасха припадають на один день"\r    | matchingYears orthodoxDate catholicDate |\r    matchingYears := OrderedCollection new.\r    (startYear to: endYear) do: [:year |\r        orthodoxDate := self orthodoxEasterDateFor: year.\r        catholicDate := self easterDateFor: year.\r        (orthodoxDate = catholicDate) ifTrue: [\r            matchingYears add: year\r        ].\r    ].\r    ^matchingYears asArray\r\rDate yearsWithMatchingEasterFrom: 2000 to: 2050. "#(2001 2004 2007 2010 2011 2014 2017 2025 2028 2031 2034 2037 2038 2041 2045 2048)"\r\r" ------ РЕКУРСІЯ\r  Додайте до класу Integer і випробуйте різні методи обчислення чисел  Фібоначчі.\r  Запропонуйте власні. Порівняйте їхню ефективність.      \r  Перед випробуванням fibonacci ЗБЕРЕЖІТЬ ІМІДЖ СИСТЕМИ! Він може зайняти Ваш комп на тиждень.  "\r\r3 fibStart: 1 with: 10  "<-- 12"\r4 fibo "<-- 5"\r12 fibonacci "<-- 233"\r\r\r"\r==============\rВласні методи:\r==============\r\r- Метод 1:\rInteger >> factorial\r    ""Обчислення факторіалу числа""\r    ^ self <= 1 ifTrue: [1] ifFalse: [self * (self - 1) factorial].\r\r- Метод 2:\rInteger >> sumTo\r    ""Сума всіх чисел від 1 до self""\r    | sum i |\r    sum := 0.\r    1 to: self do: [:i | sum := sum + i].\r    ^ sum.\r"\r\r"\rПояснення: <fibStart:with:>\rРекурсивний метод, який обчислює n-те число Фібоначчі, використовуючи два акумулятори: n1 (попереднє) і n2 (пред-попереднє).\rРекурсія: (self - 1) fibStart: n1+n2 with: n1 → наступний крок отримує нове попереднє число як суму двох попередніх.\r\rДуже швидкий для будь-якого n, навіть великого. Не обчислює одні й ті ж значення повторно → O(n). \rПам’яті потрібно лише для стеку рекурсії (глибина n).\r\rПояснення: <fibo>\rПроста обгортка над <fibStart:with:.>\r\rПовністю така ж, як у fibStart:with:. Зручно викликати без ручного передавання початкових чисел.\r\rПояснення: <fibonacci>\rКласична рекурсія: F(n) = F(n-1) + F(n-2).\r\rДуже повільний для великих n. Обчислює одні й ті ж значення багато разів → експоненційна складність O(2ⁿ). \rМоже сильно навантажити процесор і стек викликів.\r"\r\r"------------------------------------------------------------------------------------\r ------ СТВОРЕННЯ, ОПРАЦЮВАННЯ КОЛЕКЦІЙ\r  У текстовому файлі записано інформацію про матрицю цілих чисел: розміри\r  матриці в першому рядку файла, у всіх наступних рядках - рядки матриці.}\r  Прочитати матрицю, знайти максимальні елементи кожного рядка і зберегти\r  їх у файлі. Надрукувати максимальний елемент цілої матриці."\r\r"Наведений нижче код можна виконати безпосередньо в робочому вікні,\r проте,  доцільно зробити його методом власного навчального класу."\r\r| matr fStream fName n m mMatr mLines |\r        "Вибір файла за допомогою діалогу"\r    (fName:=UIManager default\r\t\t\tchooseFullFileNameMatching: nil \r\t\t\tlabel: \'Виберіть файл з числовими даними\' ) isNil\r        ifTrue: [ ^\'Ви не вибрали файла\' ]. \r        fStream := fName asFileReference readStream.\r\t        "Введення даних"\r \t    n := Integer readFrom: fStream.  \r\t    matr := Array new: n.\r\t    m := Integer readFrom: fStream.\r\t    matr := matr collect: [ :x | Array new: m ]. \r\t    1 to: n do: [ :i |  fStream nextLine.\r \t\t     matr at: i put: (\r\t\t\t\t (matr at: i) collect: [ :x |  \r\t\t\t\t\t\tInteger readFrom: fStream. ]\r\t\t\t\t\t )\t ].\r    fStream close. matr inspect.\r        "Обчислення максимальних елементів"\r    mLines:=matr collect: [ :r | r inject: (r at: 1) into: [ :x :y | x max: y] ].\r    mMatr:=mLines at: 1.\r    mLines do: [ :x | x > mMatr ifTrue: [ mMatr := x ] ].\r        "Побудова імені файла результатів, збереження"\r    fName at: fName size - 4 put: $_ .\r    fStream := fName asFileReference writeStream.\r    mLines do: [ :x | x printOn: fStream. fStream cr ].\r    fStream close.\r    ^mMatr .  \r\r" Поясніть код, наведений вище (кожне повідомлення!):\r\r\t| matr fStream fName n m mMatr mLines | <-- Локальні змінні\r\r\tВідкриваємо діалог вибору файлу. Якщо користувач не вибрав файл – повертаємо повідомлення:\r\t(fName := UIManager default\r\t    chooseFullFileNameMatching: nil\r\t    label: \'Виберіть файл з числовими даними\') isNil\r\t    ifTrue: [ ^\'Ви не вибрали файла\' ].\r\r\tfStream := fName asFileReference readStream. <-- Відкриваємо потік для читання файлу\r\tn := Integer readFrom: fStream. <-- Читаємо перше число з файлу – кількість рядків матриці\r\tmatr := Array new: n. <-- Створюємо масив для рядків матриці:\r\tm := Integer readFrom: fStream. <-- Читаємо друге число з файлу – кількість стовпців матриці\r\tmatr := matr collect: [:x | Array new: m]. <-- Заповнюємо кожен рядок новим масивом стовпців (масив масивів)\r\r\tПроходимо по кожному рядку:\r\t - пропускаємо порожню або заголовочну лінію\r\t - читаємо числа рядка і записуємо у відповідний рядок матриці:\r\t1 to: n do: [:i |\r\t    fStream nextLine.\r\t    matr at: i put: (\r\t        (matr at: i) collect: [:x | Integer readFrom: fStream]\r\t    )].\r\r\tfStream close. <-- Закриваємо потік після читання\r\tmatr inspect. <-- Відкриваємо інспектор для перегляду матриці\r\r\tОбчислюємо максимум у кожному рядку:\r\t - inject: використовується для проходження елементів\r\t - функція x max: y повертає більший елемент\r\tmLines := matr collect: [:r | r inject: (r at: 1) into: [:x :y | x max: y]].\r\r\tЗнаходимо загальний максимум матриці:\r\t - проходимо по максимумам рядків і оновлюємо mMatr:\r\tmMatr := mLines at: 1.\r\tmLines do: [:x | x > mMatr ifTrue: [ mMatr := x ]].\r\r\tfName at: fName size - 4 put: $_. <-- Змінюємо розширення файлу для збереження результатів\r\tfStream := fName asFileReference writeStream. <-- Відкриваємо потік для запису у файл\r\tmLines do: [:x | x printOn: fStream. fStream cr]. <-- Записуємо максимуми рядків у файл, кожен на новий рядок\r\tfStream close. <-- Закриваємо файл після запису\r\t^ mMatr. <-- Повертаємо максимальний елемент всієї матриці\r\r   Як замінити масивмасивів на екземпляр класу Matrix?:\r\tMatrix замінює масив масивів, тобто ми маємо одну структуру n × m. До елементів доступ через at: i at: j.\r\tЦе дозволяє компактно читати дані з файлу, знаходити максимуми і записувати результати, не створюючи додаткових масивів рядків:\r\t\r\t| matr fStream n m mMatr |\r\r\tВідкриваємо файл та читаємо розміри:\r\tfStream := \'file.txt\' asFileReference readStream.\r\tn := Integer readFrom: fStream.\r\tm := Integer readFrom: fStream.\r\r\tСтворюємо і заповнюємо матрицю:\r\tmatr := Matrix rows: n columns: m.\r\t1 to: n do: [:i | 1 to: m do: [:j | matr at: i at: j put: Integer readFrom: fStream]].\r\tfStream close.\r\r\tЗнаходимо загальний максимум:\r\tmMatr := (1 to: n) inject: 0 into: [:maxRow :i | maxRow max: ((1 to: m) inject: 0 into: [:maxCol :j | maxCol max: (matr at: i at: j)])].\r\t^ mMatr.\r\r======================================================\r\r ------ АДРЕСНА КНИГА\r Приклад створення і використання адресної книги, описаний у одній з лекцій. \r Пригадуєте, спочатку оголошуємо глобальну змінну, що міститиме впорядковану \r колекцію масивів з трьох рядків. Спосіб порівняння описує бінарний блок.    "\r\r    Smalltalk globals at: #AddressBook\r              put:(SortedCollection sortBlock:[:a :b | (a at:1)<=(b at:1)]).\r\r" * --- Тепер до книги можна додавати записи. "\r\r    AddressBook\r            add: #(\'Ruth\' \'Babe\' \'456 Mudville Flats\');\r            add: #(\'Smith\' \'John\' \'12/5 Park Ave\');\r            add: #(\'Jexon\' \'John\' \'5 Baverli Hills\');\r            add: #(\'Adams\' \'John\' \'1 Hell str\');\r            add: #(\'Taylor\' \'Babe\' \'2a/35 Deribas str\');\r            add: #(\'Greg\' \'Voss\' \'12345 the USA\')."<-- #(\'Greg\' \'Voss\' \'12345 the USA\')"\r\r" * --- Додайте власні записи. Видрукуйте вміст книги (код запропоновано нижче)."\r   | s w |  s := WriteStream on: String new.\r\r    AddressBook do:[:x | x do:\r        [ :y | s nextPutAll: y; tab; tab.].\r        s cr. ]. "<-- a SortedCollection(#(\'Adams\' \'John\' \'1 Hell str\') \r\t\t\t\t\t  #(\'Greg\' \'Voss\' \'12345 the USA\') #(\'Jexon\' \'John\' \'5 Baverli Hills\') \r\t\t\t\t\t  #(\'Ruth\' \'Babe\' \'456 Mudville Flats\') #(\'Smith\' \'John\' \'12/5 Park Ave\') \r\t\t\t\t\t  #(\'Taylor\' \'Babe\' \'2a/35 Deribas str\'))"\r\r\tAddressBook\r    add: #(\'Brown\' \'Alice\' \'7 Cherry Lane\');\r    add: #(\'White\' \'Bob\' \'15 Oak Street\');\r    add: #(\'Green\' \'Clara\' \'9 Pine Avenue\').\r\r\t  \r\ts := WriteStream on: String new.\r\tAddressBook do: [ :x | x do: [ :y | s nextPutAll: y; tab; tab. ] ] \r\t\r\t" Я трохи начудив з додаванням записів, тому ось такий результат:\r\ta SortedCollection(#(\'Adams\' \'John\' \'1 Hell str\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Greg\' \'Voss\' \'12345 the USA\') #(\'Jexon\' \'John\' \'5 Baverli Hills\') #(\'Oleh\' \'Chyzhov\' \'MyAddress 23\') #(\'Oleh\' \'Chyzhov\' \'MyAddress 23\') #(\'Oleh\' \'Chyzhov\' \'ofjidjf\') #(\'Oleh\' \'Chyzhov\' \'frjgirgjir\') #(\'Ruth\' \'Babe\' \'456 Mudville Flats\') #(\'Smith\' \'John\' \'12/5 Park Ave\') #(\'Taylor\' \'Babe\' \'2a/35 Deribas str\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'oleh\' \'chyzhov\' \'myaddress 23\'))"\r\r\r  w := Workspace openLabel: \'My Address Book\'.\r  w contents: s contents.\r\r" * ----  Наступне завдання - надрукувати список прізвищ людей з однаковими іменами. \r              Приклад демонструє різні способи перебору та перетворення колекцій."\r\r | firstNames duplicates |\r    firstNames:=Bag new.        "утворимо торбу імен"\r    AddressBook do: [ :entry | firstNames add: (entry at: 2) ]. "<-- a SortedCollection(#(\'Adams\' \'John\' \'1 Hell str\') #(\'Greg\' \'Voss\' \'12345 the USA\') \r\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t#(\'Jexon\' \'John\' \'5 Baverli Hills\') #(\'Ruth\' \'Babe\' \'456 Mudville Flats\') #(\'Smith\' \'John\' \'12/5 Park Ave\')\r\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t#(\'Taylor\' \'Babe\' \'2a/35 Deribas str\'))"\r\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r        "виберемо ті імена, які зустрічаються більше одного разу"\r    duplicates:=firstNames select:\r        [ :name | (firstNames occurrencesOf: name)>1 ]. "<-- a Bag(\'John\' \'John\' \'John\' \'Babe\' \'Babe\')"\r            "і впорядкуємо їх"\r    duplicates:=duplicates asSet asSortedCollection. "<-- a SortedCollection(\'Babe\' \'John\')"\r        "друкуємо імена та відповідні їм прізвища"\r    duplicates do: [ :first | first printOn: Transcript. Transcript show:\'==>\'.\r        AddressBook do: [ :entry | (entry at: 2)=first\r            ifTrue: [ Transcript show:\' \'. (entry at: 1) printOn: Transcript ] ].\r        Transcript cr ]. Transcript show:\' \'.\r\r" Поясніть перетворення, що відбуваються в цьому фрагменті:\r\tBag — дозволяє зберігати елементи з повтореннями.\r\tselect: — фільтрує колекцію, залишаючи тільки елементи, що задовольняють умові (тут, occurrencesOf: > 1).\r\tasSet — видаляє дублікати після фільтрації.\r\tasSortedCollection — сортує результати для зручного виводу.\r\tdo: — ітерує колекцію і виконує дію (друк у Transcript).\r\r   Запропонуйте власні варіанти використання та перетворення колекцій. \r \r  Оформіть запропоновані вище фрагменти як методи навчального класу:\r\tObject subclass: #AddressBookUtils\r    \tinstanceVariableNames: \'\'\r    \tclassVariableNames: \'\'\r    \tpoolDictionaries: \'\'\r    \tcategory: \'Training-Examples\'.\r\r"\r\r\r" ------ ДОДАВАННЯ АДРЕС\r  Можливо, додавання записів до AddressBook за допомогою явного програмування \r  виглядає не надто привабливо. Використайте з цією метою діалоги "\r\r| a b c | \ra := UIManager default request: \'Input first name\'.\rb := UIManager default request: \'Input second name\'.\rc := UIManager default request: \'Input address\'.\ra isNil | b isNil | c isNil ifFalse: [ AddressBook add: (Array with:a with:b with:c)]. "<-- #(\'Oleh\' \'Chyzhov\' \'MyAddress 23\')"\r\r" Додайте до книги декілька нових записів, знову видрукуйте її. "\r"Через це в книзі так багато записів:"\r[\r    | a b c |\r    a := UIManager default request: \'Input first name\'.\r    a isNil ifTrue: [ ^self ].  "Cancel завершує цикл"\r\r    b := UIManager default request: \'Input second name\'.\r    b isNil ifTrue: [ ^self ].\r\r    c := UIManager default request: \'Input address\'.\r    c isNil ifTrue: [ ^self ].\r\r    AddressBook add: (Array with: a with: b with: c).\r] repeat.\r\r\ts := WriteStream on: String new.\r\tAddressBook do: [ :x | x do: [ :y | s nextPutAll: y; tab; tab. ] ] "<--  \r\ta SortedCollection(\r\t#(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') \r\t#(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') \r\t#(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'Adams\' \'John\' \'1 Hell str\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') \r\t#(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') \r\t#(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Greg\' \'Voss\' \'12345 the USA\') #(\'Jexon\' \'John\' \'5 Baverli Hills\') \r\t#(\'Oleh\' \'Chyzhov\' \'MyAddress 23\') #(\'Oleh\' \'Chyzhov\' \'MyAddress 23\') #(\'Oleh\' \'Chyzhov\' \'ofjidjf\') #(\'Oleh\' \'Chyzhov\' \'frjgirgjir\') #(\'Ruth\' \'Babe\' \'456 Mudville Flats\') \r\t#(\'Smith\' \'John\' \'12/5 Park Ave\') #(\'Taylor\' \'Babe\' \'2a/35 Deribas str\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'White\' \'Bob\' \'15 Oak Street\') \r\t#(\'White\' \'Bob\' \'15 Oak Street\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'oleh\' \'chyzhov\' \'myaddress 23\'))"\r\r" Поміркуйте, як зробити зручнішим звертання до діалогу додавання адрес та друку адресної книги. \rМожна винести логіку у клас: один метод відповідатиме за введення одного запису. Інший — за введення кількох записів. Ще інший — за друк книги"\r\r" Що станеться, якщо виконати наступний код? Випробуйте. "\r    Smalltalk globals removeKey:#AddressBook. "<-- з глобального словника Smalltalk globals буде видалено ключ #AddressBook і, відповідно, саму твою колекцію (адресну книгу)."\r\r "------ ПЕРЕТВОРЕННЯ (ПЕРЕВТІЛЕННЯ) ОБ\'ЄКТІВ\r   Виконайте за допомогою Do It. "\r\r | a b c|\r    a := OrderedCollection new.\r    b := Cylinder new.\r    c := Array with: a with: b with: b.\r    Transcript show: \'Old Array is = \'.\r    c do: [ :x | Transcript show: \'     \'. x printOn: Transcript ].\r    Transcript cr.\r    a become: b.\r    Transcript show: \'New Array is = \'.\r    c do: [ :x | Transcript show: \'     \'. x printOn: Transcript ].\r    Transcript cr; show:\' \'. "<-- Unknown variable"\r\r" Поясніть дію методу become:. Чи можна замість нього користуватися звичайним присвоєнням? Наведіть власні приклади. "\r\r" Метод become: міняє всі посилання на два об’єкти місцями у всій системі.  \r  Це відрізняється від простого присвоєння, яке змінює лише одну змінну.  \r  У прикладі масив c до become: містив [OrderedCollection, Cylinder, Cylinder],  \r  а після become: став [Cylinder, OrderedCollection, OrderedCollection].  \r  Звичайним присвоєнням такого ефекту не досягти. "\r\r\r\r\r\r\r\r'
}OmEntry {
	#tags : {
		#timestamp : DateAndTime [ '2025-10-04T22:18:42.006+03:00' ],
		#self : OmReference [ '9' ]
	},
	#content : '"--------------------------------------------------------------------------------------\r*                      ЛАБОРОТОРНА РОБОТА 3\r*                 Тема: КЛАСИ ТА МЕТОДИ. КОЛЕКЦІЇ\r*\r*  Завдання до лабораторної роботи:\r*     1. Виконайте наведені нижче приклади, збережіть і поясніть отримані результати.\r*     2. Випробуйте різноманітні способи додавання нових класів до системи.\r*     3. Навчіться доповнювати функціональність класів.\r*     4. Випробуйте методи опрацювання колекцій.\r*\r\r    Виконайте за допомогою <Print it> \r\r ------ ПРИНАЛЕЖНІСТЬ КЛАСОВІ, ІЄРАРХІЯ КЛАСІВ\r"\r    #(Francesca Jackie Marisa Bree) class. "Array"\r    (#(Francesca Jackie Marisa Bree) at:2) class. "ByteSymbol"\r    \'Rakesh Vijay Charles Daniel Tyler\' class. "ByteString"\r    (\'Rakesh Vijay Charles Daniel Tyler\' at:2) class. "Character (a)"\r    World class . "WorldMorph"\r    Magnitude class. "Magnitude class"\r    Magnitude class class. "Metaclass"\r    nil class. "UndefinedObject"\r    5 species. "SmallInteger"\r    123456789000 species. "SmallInteger"\r    #aName species. "ByteString"\r " Яка різниця між повідомленнями class i species ? \r\r    Випробуйте різні способи відкривання браузера класів: за допомогою меню чи програмно \r     Виконайте за допомогою <Do it>\r"\r    ClyFullBrowserMorph open. \r    ClyFullBrowserMorph openOnClass: Date. \r    ClyFullBrowserMorph openOnClass: VolumeShape  selector:  #volume. \r\r" ------ МЕТОДИ КЛАСУ, КОНСТРУКТОРИ\r  Виконайте за допомогою <Print It>. Запропонуйте власні приклади. "\r\r    Array new: 10. "#(nil nil nil nil nil nil nil nil nil nil)"        \r    OrderedCollection  new. "an OrderedCollection()"\r    Date today. "29 September 2025"\r    Time now. "10:28:52.422 am"\r    UIManager default  request:\'How are you?\' initialAnswer:\'I\'\'m fine!\'. "\'I\'\'m fine!\'"\r    Integer readFrom: \'2013  1925\'. "2013"\r    Integer primesUpTo: 100. "#(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97)"\r    Rectangle origin:0@0 corner:200@100. "(0@0) corner: (200@100)"\r    Date nameOfMonth:12. "#December"\r    Date dayOfWeek: #Friday. "6"\r    Date orthodoxEasterDateFor: 2022. "24 April 2022"\r\r\r   \r"Інсталюйте вказані нижче МЕТОДИ КЛАСУ Date:\r  перенесіть копію тексту визначення методу з робочого вікна в браузер класів.\r\r""!Date class methodsFor: \'specific inquiries\' stamp: \'CamilloBruni 8/22/2013 19:47\'!""\r\rorthodoxEasterDateFor: year\r ""  compute the easter date according to the rules of the orthodox calendar.\r    source:       http://www.smart.net/~mmontes/ortheast.html   ""\r     | r1 r2 r3 r4 ra rb r5 rc date |\r\r    r1 := year \\\\ 19.\r    r2 := year \\\\ 4.\r    r3 := year \\\\ 7.\r    ra := 19*r1 + 16.\r    r4 := ra \\\\ 30.\r    rb := r2 + r2 + (4*r3) + (6*r4).\r    r5 := rb \\\\ 7.\r    rc := r4 + r5.\r    date := self year: year month: 4 day: 3.\r    ^date addDays: rc.\r""--------------------------------------------------------------------------------------""\r""!Date class methodsFor: \'specific inquiries\' stamp: \'CamilloBruni 8/22/2013 19:48\'!""\r\reasterDateFor: year\r ""  compute the easter date.\r    source: Physikalisch-Technische Bundesanstalt Braunschweig.\r    Lichtenberg, H.: Zur Interpretation der Gaussschen Osterformel und ihrer Ausnahmeregeln, Historia Mathematica 24 (1997), pp. 441-444\r      http://www.ptb.de/de/org/4/44/441/oste.htm  ""\r\r  | k m s a d r og sz oe day |\r\r  k := year // 100.\r  m := 15 + (3*k + 3//4) - (8*k + 13//25).\r   s := 2 - (3*k + 3// 4).\r  a := year \\\\ 19.\r  d := 19*a + m \\\\ 30.\r  r := d//29 + ((d//28) - (d//29)* (a// 11)).\r\r  og := 21 + d - r.\r  sz := 7 - (year//4 + year + s\\\\7).\r  oe := 7 - (og - sz\\\\7).\r  day := og + oe.\r  ^day <= 31\r    ifTrue: [ Date year: year month: 3 day: day ]\r    ifFalse: [ Date year: year month: 4 day: day - 31 ].\r"\r\r"Знайдіть роки, коли святкування припадають на один день."\r\ryearsWithMatchingEasterFrom: startYear to: endYear\r\r    | matchingYears orthodoxDate catholicDate |\r    matchingYears := OrderedCollection new.\r    (startYear to: endYear) do: [:year |\r        orthodoxDate := self orthodoxEasterDateFor: year.\r        catholicDate := self easterDateFor: year.\r        (orthodoxDate = catholicDate) ifTrue: [\r            matchingYears add: year\r        ].\r    ].\r    ^matchingYears asArray\r\rDate yearsWithMatchingEasterFrom: 2000 to: 2050. "#(2001 2004 2007 2010 2011 2014 2017 2025 2028 2031 2034 2037 2038 2041 2045 2048)"\r\r" ------ РЕКУРСІЯ\r  Додайте до класу Integer і випробуйте різні методи обчислення чисел  Фібоначчі.\r  Запропонуйте власні. Порівняйте їхню ефективність.      \r  Перед випробуванням fibonacci ЗБЕРЕЖІТЬ ІМІДЖ СИСТЕМИ! Він може зайняти Ваш комп на тиждень.  "\r\r3 fibStart: 1 with: 10  "<-- 12"\r4 fibo "<-- 5"\r12 fibonacci "<-- 233"\r\r\r"\r==============\rВласні методи:\r==============\r\r- Метод 1:\rInteger >> factorial\r    ""Обчислення факторіалу числа""\r    ^ self <= 1 ifTrue: [1] ifFalse: [self * (self - 1) factorial].\r\r- Метод 2:\rInteger >> sumTo\r    ""Сума всіх чисел від 1 до self""\r    | sum i |\r    sum := 0.\r    1 to: self do: [:i | sum := sum + i].\r    ^ sum.\r"\r\r"\rПояснення: <fibStart:with:>\rРекурсивний метод, який обчислює n-те число Фібоначчі, використовуючи два акумулятори: n1 (попереднє) і n2 (пред-попереднє).\rРекурсія: (self - 1) fibStart: n1+n2 with: n1 → наступний крок отримує нове попереднє число як суму двох попередніх.\r\rДуже швидкий для будь-якого n, навіть великого. Не обчислює одні й ті ж значення повторно → O(n). \rПам’яті потрібно лише для стеку рекурсії (глибина n).\r\rПояснення: <fibo>\rПроста обгортка над <fibStart:with:.>\r\rПовністю така ж, як у fibStart:with:. Зручно викликати без ручного передавання початкових чисел.\r\rПояснення: <fibonacci>\rКласична рекурсія: F(n) = F(n-1) + F(n-2).\r\rДуже повільний для великих n. Обчислює одні й ті ж значення багато разів → експоненційна складність O(2ⁿ). \rМоже сильно навантажити процесор і стек викликів.\r"\r\r"------------------------------------------------------------------------------------\r ------ СТВОРЕННЯ, ОПРАЦЮВАННЯ КОЛЕКЦІЙ\r  У текстовому файлі записано інформацію про матрицю цілих чисел: розміри\r  матриці в першому рядку файла, у всіх наступних рядках - рядки матриці.}\r  Прочитати матрицю, знайти максимальні елементи кожного рядка і зберегти\r  їх у файлі. Надрукувати максимальний елемент цілої матриці."\r\r"Наведений нижче код можна виконати безпосередньо в робочому вікні,\r проте,  доцільно зробити його методом власного навчального класу."\r\r| matr fStream fName n m mMatr mLines |\r        "Вибір файла за допомогою діалогу"\r    (fName:=UIManager default\r\t\t\tchooseFullFileNameMatching: nil \r\t\t\tlabel: \'Виберіть файл з числовими даними\' ) isNil\r        ifTrue: [ ^\'Ви не вибрали файла\' ]. \r        fStream := fName asFileReference readStream.\r\t        "Введення даних"\r \t    n := Integer readFrom: fStream.  \r\t    matr := Array new: n.\r\t    m := Integer readFrom: fStream.\r\t    matr := matr collect: [ :x | Array new: m ]. \r\t    1 to: n do: [ :i |  fStream nextLine.\r \t\t     matr at: i put: (\r\t\t\t\t (matr at: i) collect: [ :x |  \r\t\t\t\t\t\tInteger readFrom: fStream. ]\r\t\t\t\t\t )\t ].\r    fStream close. matr inspect.\r        "Обчислення максимальних елементів"\r    mLines:=matr collect: [ :r | r inject: (r at: 1) into: [ :x :y | x max: y] ].\r    mMatr:=mLines at: 1.\r    mLines do: [ :x | x > mMatr ifTrue: [ mMatr := x ] ].\r        "Побудова імені файла результатів, збереження"\r    fName at: fName size - 4 put: $_ .\r    fStream := fName asFileReference writeStream.\r    mLines do: [ :x | x printOn: fStream. fStream cr ].\r    fStream close.\r    ^mMatr .  \r\r" Поясніть код, наведений вище (кожне повідомлення!):\r\r\t| matr fStream fName n m mMatr mLines | <-- Локальні змінні\r\r\tВідкриваємо діалог вибору файлу. Якщо користувач не вибрав файл – повертаємо повідомлення:\r\t(fName := UIManager default\r\t    chooseFullFileNameMatching: nil\r\t    label: \'Виберіть файл з числовими даними\') isNil\r\t    ifTrue: [ ^\'Ви не вибрали файла\' ].\r\r\tfStream := fName asFileReference readStream. <-- Відкриваємо потік для читання файлу\r\tn := Integer readFrom: fStream. <-- Читаємо перше число з файлу – кількість рядків матриці\r\tmatr := Array new: n. <-- Створюємо масив для рядків матриці:\r\tm := Integer readFrom: fStream. <-- Читаємо друге число з файлу – кількість стовпців матриці\r\tmatr := matr collect: [:x | Array new: m]. <-- Заповнюємо кожен рядок новим масивом стовпців (масив масивів)\r\r\tПроходимо по кожному рядку:\r\t - пропускаємо порожню або заголовочну лінію\r\t - читаємо числа рядка і записуємо у відповідний рядок матриці:\r\t1 to: n do: [:i |\r\t    fStream nextLine.\r\t    matr at: i put: (\r\t        (matr at: i) collect: [:x | Integer readFrom: fStream]\r\t    )].\r\r\tfStream close. <-- Закриваємо потік після читання\r\tmatr inspect. <-- Відкриваємо інспектор для перегляду матриці\r\r\tОбчислюємо максимум у кожному рядку:\r\t - inject: використовується для проходження елементів\r\t - функція x max: y повертає більший елемент\r\tmLines := matr collect: [:r | r inject: (r at: 1) into: [:x :y | x max: y]].\r\r\tЗнаходимо загальний максимум матриці:\r\t - проходимо по максимумам рядків і оновлюємо mMatr:\r\tmMatr := mLines at: 1.\r\tmLines do: [:x | x > mMatr ifTrue: [ mMatr := x ]].\r\r\tfName at: fName size - 4 put: $_. <-- Змінюємо розширення файлу для збереження результатів\r\tfStream := fName asFileReference writeStream. <-- Відкриваємо потік для запису у файл\r\tmLines do: [:x | x printOn: fStream. fStream cr]. <-- Записуємо максимуми рядків у файл, кожен на новий рядок\r\tfStream close. <-- Закриваємо файл після запису\r\t^ mMatr. <-- Повертаємо максимальний елемент всієї матриці\r\r   Як замінити масивмасивів на екземпляр класу Matrix?:\r\tMatrix замінює масив масивів, тобто ми маємо одну структуру n × m. До елементів доступ через at: i at: j.\r\tЦе дозволяє компактно читати дані з файлу, знаходити максимуми і записувати результати, не створюючи додаткових масивів рядків:\r\t\r\t| matr fStream n m mMatr |\r\r\tВідкриваємо файл та читаємо розміри:\r\tfStream := \'file.txt\' asFileReference readStream.\r\tn := Integer readFrom: fStream.\r\tm := Integer readFrom: fStream.\r\r\tСтворюємо і заповнюємо матрицю:\r\tmatr := Matrix rows: n columns: m.\r\t1 to: n do: [:i | 1 to: m do: [:j | matr at: i at: j put: Integer readFrom: fStream]].\r\tfStream close.\r\r\tЗнаходимо загальний максимум:\r\tmMatr := (1 to: n) inject: 0 into: [:maxRow :i | maxRow max: ((1 to: m) inject: 0 into: [:maxCol :j | maxCol max: (matr at: i at: j)])].\r\t^ mMatr.\r\r======================================================\r\r ------ АДРЕСНА КНИГА\r Приклад створення і використання адресної книги, описаний у одній з лекцій. \r Пригадуєте, спочатку оголошуємо глобальну змінну, що міститиме впорядковану \r колекцію масивів з трьох рядків. Спосіб порівняння описує бінарний блок.    "\r\r    Smalltalk globals at: #AddressBook\r              put:(SortedCollection sortBlock:[:a :b | (a at:1)<=(b at:1)]).\r\r" * --- Тепер до книги можна додавати записи. "\r\r    AddressBook\r            add: #(\'Ruth\' \'Babe\' \'456 Mudville Flats\');\r            add: #(\'Smith\' \'John\' \'12/5 Park Ave\');\r            add: #(\'Jexon\' \'John\' \'5 Baverli Hills\');\r            add: #(\'Adams\' \'John\' \'1 Hell str\');\r            add: #(\'Taylor\' \'Babe\' \'2a/35 Deribas str\');\r            add: #(\'Greg\' \'Voss\' \'12345 the USA\')."<-- #(\'Greg\' \'Voss\' \'12345 the USA\')"\r\r" * --- Додайте власні записи. Видрукуйте вміст книги (код запропоновано нижче)."\r   | s w |  s := WriteStream on: String new.\r\r    AddressBook do:[:x | x do:\r        [ :y | s nextPutAll: y; tab; tab.].\r        s cr. ]. "<-- a SortedCollection(#(\'Adams\' \'John\' \'1 Hell str\') \r\t\t\t\t\t  #(\'Greg\' \'Voss\' \'12345 the USA\') #(\'Jexon\' \'John\' \'5 Baverli Hills\') \r\t\t\t\t\t  #(\'Ruth\' \'Babe\' \'456 Mudville Flats\') #(\'Smith\' \'John\' \'12/5 Park Ave\') \r\t\t\t\t\t  #(\'Taylor\' \'Babe\' \'2a/35 Deribas str\'))"\r\r\tAddressBook\r    add: #(\'Brown\' \'Alice\' \'7 Cherry Lane\');\r    add: #(\'White\' \'Bob\' \'15 Oak Street\');\r    add: #(\'Green\' \'Clara\' \'9 Pine Avenue\').\r\r\t  \r\ts := WriteStream on: String new.\r\tAddressBook do: [ :x | x do: [ :y | s nextPutAll: y; tab; tab. ] ] \r\t\r\t" Я трохи начудив з додаванням записів, тому ось такий результат:\r\ta SortedCollection(#(\'Adams\' \'John\' \'1 Hell str\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Greg\' \'Voss\' \'12345 the USA\') #(\'Jexon\' \'John\' \'5 Baverli Hills\') #(\'Oleh\' \'Chyzhov\' \'MyAddress 23\') #(\'Oleh\' \'Chyzhov\' \'MyAddress 23\') #(\'Oleh\' \'Chyzhov\' \'ofjidjf\') #(\'Oleh\' \'Chyzhov\' \'frjgirgjir\') #(\'Ruth\' \'Babe\' \'456 Mudville Flats\') #(\'Smith\' \'John\' \'12/5 Park Ave\') #(\'Taylor\' \'Babe\' \'2a/35 Deribas str\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'oleh\' \'chyzhov\' \'myaddress 23\'))"\r\r\r  w := Workspace openLabel: \'My Address Book\'.\r  w contents: s contents.\r\r" * ----  Наступне завдання - надрукувати список прізвищ людей з однаковими іменами. \r              Приклад демонструє різні способи перебору та перетворення колекцій."\r\r | firstNames duplicates |\r    firstNames:=Bag new.        "утворимо торбу імен"\r    AddressBook do: [ :entry | firstNames add: (entry at: 2) ]. "<-- a SortedCollection(#(\'Adams\' \'John\' \'1 Hell str\') #(\'Greg\' \'Voss\' \'12345 the USA\') \r\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t#(\'Jexon\' \'John\' \'5 Baverli Hills\') #(\'Ruth\' \'Babe\' \'456 Mudville Flats\') #(\'Smith\' \'John\' \'12/5 Park Ave\')\r\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t#(\'Taylor\' \'Babe\' \'2a/35 Deribas str\'))"\r\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r        "виберемо ті імена, які зустрічаються більше одного разу"\r    duplicates:=firstNames select:\r        [ :name | (firstNames occurrencesOf: name)>1 ]. "<-- a Bag(\'John\' \'John\' \'John\' \'Babe\' \'Babe\')"\r            "і впорядкуємо їх"\r    duplicates:=duplicates asSet asSortedCollection. "<-- a SortedCollection(\'Babe\' \'John\')"\r        "друкуємо імена та відповідні їм прізвища"\r    duplicates do: [ :first | first printOn: Transcript. Transcript show:\'==>\'.\r        AddressBook do: [ :entry | (entry at: 2)=first\r            ifTrue: [ Transcript show:\' \'. (entry at: 1) printOn: Transcript ] ].\r        Transcript cr ]. Transcript show:\' \'.\r\r" Поясніть перетворення, що відбуваються в цьому фрагменті:\r\tBag — дозволяє зберігати елементи з повтореннями.\r\tselect: — фільтрує колекцію, залишаючи тільки елементи, що задовольняють умові (тут, occurrencesOf: > 1).\r\tasSet — видаляє дублікати після фільтрації.\r\tasSortedCollection — сортує результати для зручного виводу.\r\tdo: — ітерує колекцію і виконує дію (друк у Transcript).\r\r   Запропонуйте власні варіанти використання та перетворення колекцій. \r \r  Оформіть запропоновані вище фрагменти як методи навчального класу:\r\tObject subclass: #AddressBookUtils\r    \tinstanceVariableNames: \'\'\r    \tclassVariableNames: \'\'\r    \tpoolDictionaries: \'\'\r    \tcategory: \'Training-Examples\'.\r\r"\r\r\r" ------ ДОДАВАННЯ АДРЕС\r  Можливо, додавання записів до AddressBook за допомогою явного програмування \r  виглядає не надто привабливо. Використайте з цією метою діалоги "\r\r| a b c | \ra := UIManager default request: \'Input first name\'.\rb := UIManager default request: \'Input second name\'.\rc := UIManager default request: \'Input address\'.\ra isNil | b isNil | c isNil ifFalse: [ AddressBook add: (Array with:a with:b with:c)]. "<-- #(\'Oleh\' \'Chyzhov\' \'MyAddress 23\')"\r\r" Додайте до книги декілька нових записів, знову видрукуйте її. "\r"Через це в книзі так багато записів:"\r[\r    | a b c |\r    a := UIManager default request: \'Input first name\'.\r    a isNil ifTrue: [ ^self ].  "Cancel завершує цикл"\r\r    b := UIManager default request: \'Input second name\'.\r    b isNil ifTrue: [ ^self ].\r\r    c := UIManager default request: \'Input address\'.\r    c isNil ifTrue: [ ^self ].\r\r    AddressBook add: (Array with: a with: b with: c).\r] repeat.\r\r\ts := WriteStream on: String new.\r\tAddressBook do: [ :x | x do: [ :y | s nextPutAll: y; tab; tab. ] ] "<--  \r\ta SortedCollection(\r\t#(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') \r\t#(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') \r\t#(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'Adams\' \'John\' \'1 Hell str\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') \r\t#(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') \r\t#(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Greg\' \'Voss\' \'12345 the USA\') #(\'Jexon\' \'John\' \'5 Baverli Hills\') \r\t#(\'Oleh\' \'Chyzhov\' \'MyAddress 23\') #(\'Oleh\' \'Chyzhov\' \'MyAddress 23\') #(\'Oleh\' \'Chyzhov\' \'ofjidjf\') #(\'Oleh\' \'Chyzhov\' \'frjgirgjir\') #(\'Ruth\' \'Babe\' \'456 Mudville Flats\') \r\t#(\'Smith\' \'John\' \'12/5 Park Ave\') #(\'Taylor\' \'Babe\' \'2a/35 Deribas str\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'White\' \'Bob\' \'15 Oak Street\') \r\t#(\'White\' \'Bob\' \'15 Oak Street\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'oleh\' \'chyzhov\' \'myaddress 23\'))"\r\r" Поміркуйте, як зробити зручнішим звертання до діалогу додавання адрес та друку адресної книги. \rМожна винести логіку у клас: один метод відповідатиме за введення одного запису. Інший — за введення кількох записів. Ще інший — за друк книги"\r\r" Що станеться, якщо виконати наступний код? Випробуйте. "\r    Smalltalk globals removeKey:#AddressBook. "<-- з глобального словника Smalltalk globals буде видалено ключ #AddressBook і, відповідно, саму твою колекцію (адресну книгу)."\r\r "------ ПЕРЕТВОРЕННЯ (ПЕРЕВТІЛЕННЯ) ОБ\'ЄКТІВ\r   Виконайте за допомогою Do It. "\r\r | a b c|\r    a := OrderedCollection new.\r    b := Cylinder new.\r    c := Array with: a with: b with: b.\r    Transcript show: \'Old Array is = \'.\r    c do: [ :x | Transcript show: \'     \'. x printOn: Transcript ].\r    Transcript cr.\r    a become: b.\r    Transcript show: \'New Array is = \'.\r    c do: [ :x | Transcript show: \'     \'. x printOn: Transcript ].\r    Transcript cr; show:\' \'. "<-- Unknown variable"\r\r" Поясніть дію методу become:. Чи можна замість нього користуватися звичайним присвоєнням? Наведіть власні приклади. "\r\r" Метод become: міняє всі посилання на два об’єкти місцями у всій системі.  \r  Це відрізняється від простого присвоєння, яке змінює лише одну змінну.  \r  У прикладі масив c до become: містив [OrderedCollection, Cylinder, Cylinder],  \r  а після become: став [Cylinder, OrderedCollection, OrderedCollection].  \r  Звичайним присвоєнням такого ефекту не досягти. "\r\r\r\r\r\r\r\r'
}OmEntry {
	#tags : {
		#timestamp : DateAndTime [ '2025-10-04T22:20:32.638+03:00' ],
		#self : OmReference [ '10' ]
	},
	#content : '"--------------------------------------------------------------------------------------\r*                      ЛАБОРОТОРНА РОБОТА 3\r*                 Тема: КЛАСИ ТА МЕТОДИ. КОЛЕКЦІЇ\r*\r*  Завдання до лабораторної роботи:\r*     1. Виконайте наведені нижче приклади, збережіть і поясніть отримані результати.\r*     2. Випробуйте різноманітні способи додавання нових класів до системи.\r*     3. Навчіться доповнювати функціональність класів.\r*     4. Випробуйте методи опрацювання колекцій.\r*\r\r    Виконайте за допомогою <Print it> \r\r ------ ПРИНАЛЕЖНІСТЬ КЛАСОВІ, ІЄРАРХІЯ КЛАСІВ\r"\r    #(Francesca Jackie Marisa Bree) class. "Array"\r    (#(Francesca Jackie Marisa Bree) at:2) class. "ByteSymbol"\r    \'Rakesh Vijay Charles Daniel Tyler\' class. "ByteString"\r    (\'Rakesh Vijay Charles Daniel Tyler\' at:2) class. "Character (a)"\r    World class . "WorldMorph"\r    Magnitude class. "Magnitude class"\r    Magnitude class class. "Metaclass"\r    nil class. "UndefinedObject"\r    5 species. "SmallInteger"\r    123456789000 species. "SmallInteger"\r    #aName species. "ByteString"\r " Яка різниця між повідомленнями class i species ? \r\r    Випробуйте різні способи відкривання браузера класів: за допомогою меню чи програмно \r     Виконайте за допомогою <Do it>\r"\r    ClyFullBrowserMorph open. \r    ClyFullBrowserMorph openOnClass: Date. \r    ClyFullBrowserMorph openOnClass: VolumeShape  selector:  #volume. \r\r" ------ МЕТОДИ КЛАСУ, КОНСТРУКТОРИ\r  Виконайте за допомогою <Print It>. Запропонуйте власні приклади. "\r\r    Array new: 10. "#(nil nil nil nil nil nil nil nil nil nil)"        \r    OrderedCollection  new. "an OrderedCollection()"\r    Date today. "29 September 2025"\r    Time now. "10:28:52.422 am"\r    UIManager default  request:\'How are you?\' initialAnswer:\'I\'\'m fine!\'. "\'I\'\'m fine!\'"\r    Integer readFrom: \'2013  1925\'. "2013"\r    Integer primesUpTo: 100. "#(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97)"\r    Rectangle origin:0@0 corner:200@100. "(0@0) corner: (200@100)"\r    Date nameOfMonth:12. "#December"\r    Date dayOfWeek: #Friday. "6"\r    Date orthodoxEasterDateFor: 2022. "24 April 2022"\r\r\r   \r"Інсталюйте вказані нижче МЕТОДИ КЛАСУ Date:\r  перенесіть копію тексту визначення методу з робочого вікна в браузер класів.\r\r""!Date class methodsFor: \'specific inquiries\' stamp: \'CamilloBruni 8/22/2013 19:47\'!""\r\rorthodoxEasterDateFor: year\r ""  compute the easter date according to the rules of the orthodox calendar.\r    source:       http://www.smart.net/~mmontes/ortheast.html   ""\r     | r1 r2 r3 r4 ra rb r5 rc date |\r\r    r1 := year \\\\ 19.\r    r2 := year \\\\ 4.\r    r3 := year \\\\ 7.\r    ra := 19*r1 + 16.\r    r4 := ra \\\\ 30.\r    rb := r2 + r2 + (4*r3) + (6*r4).\r    r5 := rb \\\\ 7.\r    rc := r4 + r5.\r    date := self year: year month: 4 day: 3.\r    ^date addDays: rc.\r""--------------------------------------------------------------------------------------""\r""!Date class methodsFor: \'specific inquiries\' stamp: \'CamilloBruni 8/22/2013 19:48\'!""\r\reasterDateFor: year\r ""  compute the easter date.\r    source: Physikalisch-Technische Bundesanstalt Braunschweig.\r    Lichtenberg, H.: Zur Interpretation der Gaussschen Osterformel und ihrer Ausnahmeregeln, Historia Mathematica 24 (1997), pp. 441-444\r      http://www.ptb.de/de/org/4/44/441/oste.htm  ""\r\r  | k m s a d r og sz oe day |\r\r  k := year // 100.\r  m := 15 + (3*k + 3//4) - (8*k + 13//25).\r   s := 2 - (3*k + 3// 4).\r  a := year \\\\ 19.\r  d := 19*a + m \\\\ 30.\r  r := d//29 + ((d//28) - (d//29)* (a// 11)).\r\r  og := 21 + d - r.\r  sz := 7 - (year//4 + year + s\\\\7).\r  oe := 7 - (og - sz\\\\7).\r  day := og + oe.\r  ^day <= 31\r    ifTrue: [ Date year: year month: 3 day: day ]\r    ifFalse: [ Date year: year month: 4 day: day - 31 ].\r"\r\r"Знайдіть роки, коли святкування припадають на один день."\r\ryearsWithMatchingEasterFrom: startYear to: endYear\r\r    | matchingYears orthodoxDate catholicDate |\r    matchingYears := OrderedCollection new.\r    (startYear to: endYear) do: [:year |\r        orthodoxDate := self orthodoxEasterDateFor: year.\r        catholicDate := self easterDateFor: year.\r        (orthodoxDate = catholicDate) ifTrue: [\r            matchingYears add: year\r        ].\r    ].\r    ^matchingYears asArray\r\rDate yearsWithMatchingEasterFrom: 2000 to: 2050. "#(2001 2004 2007 2010 2011 2014 2017 2025 2028 2031 2034 2037 2038 2041 2045 2048)"\r\r" ------ РЕКУРСІЯ\r  Додайте до класу Integer і випробуйте різні методи обчислення чисел  Фібоначчі.\r  Запропонуйте власні. Порівняйте їхню ефективність.      \r  Перед випробуванням fibonacci ЗБЕРЕЖІТЬ ІМІДЖ СИСТЕМИ! Він може зайняти Ваш комп на тиждень.  "\r\r3 fibStart: 1 with: 10  "<-- 12"\r4 fibo "<-- 5"\r12 fibonacci "<-- 233"\r\r\r"\r==============\rВласні методи:\r==============\r\r- Метод 1:\rInteger >> factorial\r    ""Обчислення факторіалу числа""\r    ^ self <= 1 ifTrue: [1] ifFalse: [self * (self - 1) factorial].\r\r- Метод 2:\rInteger >> sumTo\r    ""Сума всіх чисел від 1 до self""\r    | sum i |\r    sum := 0.\r    1 to: self do: [:i | sum := sum + i].\r    ^ sum.\r"\r\r"\rПояснення: <fibStart:with:>\rРекурсивний метод, який обчислює n-те число Фібоначчі, використовуючи два акумулятори: n1 (попереднє) і n2 (пред-попереднє).\rРекурсія: (self - 1) fibStart: n1+n2 with: n1 → наступний крок отримує нове попереднє число як суму двох попередніх.\r\rДуже швидкий для будь-якого n, навіть великого. Не обчислює одні й ті ж значення повторно → O(n). \rПам’яті потрібно лише для стеку рекурсії (глибина n).\r\rПояснення: <fibo>\rПроста обгортка над <fibStart:with:.>\r\rПовністю така ж, як у fibStart:with:. Зручно викликати без ручного передавання початкових чисел.\r\rПояснення: <fibonacci>\rКласична рекурсія: F(n) = F(n-1) + F(n-2).\r\rДуже повільний для великих n. Обчислює одні й ті ж значення багато разів → експоненційна складність O(2ⁿ). \rМоже сильно навантажити процесор і стек викликів.\r"\r\r"------------------------------------------------------------------------------------\r ------ СТВОРЕННЯ, ОПРАЦЮВАННЯ КОЛЕКЦІЙ\r  У текстовому файлі записано інформацію про матрицю цілих чисел: розміри\r  матриці в першому рядку файла, у всіх наступних рядках - рядки матриці.}\r  Прочитати матрицю, знайти максимальні елементи кожного рядка і зберегти\r  їх у файлі. Надрукувати максимальний елемент цілої матриці."\r\r"Наведений нижче код можна виконати безпосередньо в робочому вікні,\r проте,  доцільно зробити його методом власного навчального класу."\r\r| matr fStream fName n m mMatr mLines |\r        "Вибір файла за допомогою діалогу"\r    (fName:=UIManager default\r\t\t\tchooseFullFileNameMatching: nil \r\t\t\tlabel: \'Виберіть файл з числовими даними\' ) isNil\r        ifTrue: [ ^\'Ви не вибрали файла\' ]. \r        fStream := fName asFileReference readStream.\r\t        "Введення даних"\r \t    n := Integer readFrom: fStream.  \r\t    matr := Array new: n.\r\t    m := Integer readFrom: fStream.\r\t    matr := matr collect: [ :x | Array new: m ]. \r\t    1 to: n do: [ :i |  fStream nextLine.\r \t\t     matr at: i put: (\r\t\t\t\t (matr at: i) collect: [ :x |  \r\t\t\t\t\t\tInteger readFrom: fStream. ]\r\t\t\t\t\t )\t ].\r    fStream close. matr inspect.\r        "Обчислення максимальних елементів"\r    mLines:=matr collect: [ :r | r inject: (r at: 1) into: [ :x :y | x max: y] ].\r    mMatr:=mLines at: 1.\r    mLines do: [ :x | x > mMatr ifTrue: [ mMatr := x ] ].\r        "Побудова імені файла результатів, збереження"\r    fName at: fName size - 4 put: $_ .\r    fStream := fName asFileReference writeStream.\r    mLines do: [ :x | x printOn: fStream. fStream cr ].\r    fStream close.\r    ^mMatr .  \r\r" Поясніть код, наведений вище (кожне повідомлення!):\r\r\t| matr fStream fName n m mMatr mLines | <-- Локальні змінні\r\r\tВідкриваємо діалог вибору файлу. Якщо користувач не вибрав файл – повертаємо повідомлення:\r\t(fName := UIManager default\r\t    chooseFullFileNameMatching: nil\r\t    label: \'Виберіть файл з числовими даними\') isNil\r\t    ifTrue: [ ^\'Ви не вибрали файла\' ].\r\r\tfStream := fName asFileReference readStream. <-- Відкриваємо потік для читання файлу\r\tn := Integer readFrom: fStream. <-- Читаємо перше число з файлу – кількість рядків матриці\r\tmatr := Array new: n. <-- Створюємо масив для рядків матриці:\r\tm := Integer readFrom: fStream. <-- Читаємо друге число з файлу – кількість стовпців матриці\r\tmatr := matr collect: [:x | Array new: m]. <-- Заповнюємо кожен рядок новим масивом стовпців (масив масивів)\r\r\tПроходимо по кожному рядку:\r\t - пропускаємо порожню або заголовочну лінію\r\t - читаємо числа рядка і записуємо у відповідний рядок матриці:\r\t1 to: n do: [:i |\r\t    fStream nextLine.\r\t    matr at: i put: (\r\t        (matr at: i) collect: [:x | Integer readFrom: fStream]\r\t    )].\r\r\tfStream close. <-- Закриваємо потік після читання\r\tmatr inspect. <-- Відкриваємо інспектор для перегляду матриці\r\r\tОбчислюємо максимум у кожному рядку:\r\t - inject: використовується для проходження елементів\r\t - функція x max: y повертає більший елемент\r\tmLines := matr collect: [:r | r inject: (r at: 1) into: [:x :y | x max: y]].\r\r\tЗнаходимо загальний максимум матриці:\r\t - проходимо по максимумам рядків і оновлюємо mMatr:\r\tmMatr := mLines at: 1.\r\tmLines do: [:x | x > mMatr ifTrue: [ mMatr := x ]].\r\r\tfName at: fName size - 4 put: $_. <-- Змінюємо розширення файлу для збереження результатів\r\tfStream := fName asFileReference writeStream. <-- Відкриваємо потік для запису у файл\r\tmLines do: [:x | x printOn: fStream. fStream cr]. <-- Записуємо максимуми рядків у файл, кожен на новий рядок\r\tfStream close. <-- Закриваємо файл після запису\r\t^ mMatr. <-- Повертаємо максимальний елемент всієї матриці\r\r   Як замінити масивмасивів на екземпляр класу Matrix?:\r\tMatrix замінює масив масивів, тобто ми маємо одну структуру n × m. До елементів доступ через at: i at: j.\r\tЦе дозволяє компактно читати дані з файлу, знаходити максимуми і записувати результати, не створюючи додаткових масивів рядків:\r\t\r\t| matr fStream n m mMatr |\r\r\tВідкриваємо файл та читаємо розміри:\r\tfStream := \'file.txt\' asFileReference readStream.\r\tn := Integer readFrom: fStream.\r\tm := Integer readFrom: fStream.\r\r\tСтворюємо і заповнюємо матрицю:\r\tmatr := Matrix rows: n columns: m.\r\t1 to: n do: [:i | 1 to: m do: [:j | matr at: i at: j put: Integer readFrom: fStream]].\r\tfStream close.\r\r\tЗнаходимо загальний максимум:\r\tmMatr := (1 to: n) inject: 0 into: [:maxRow :i | maxRow max: ((1 to: m) inject: 0 into: [:maxCol :j | maxCol max: (matr at: i at: j)])].\r\t^ mMatr.\r\r======================================================\r\r ------ АДРЕСНА КНИГА\r Приклад створення і використання адресної книги, описаний у одній з лекцій. \r Пригадуєте, спочатку оголошуємо глобальну змінну, що міститиме впорядковану \r колекцію масивів з трьох рядків. Спосіб порівняння описує бінарний блок.    "\r\r    Smalltalk globals at: #AddressBook\r              put:(SortedCollection sortBlock:[:a :b | (a at:1)<=(b at:1)]).\r\r" * --- Тепер до книги можна додавати записи. "\r\r    AddressBook\r            add: #(\'Ruth\' \'Babe\' \'456 Mudville Flats\');\r            add: #(\'Smith\' \'John\' \'12/5 Park Ave\');\r            add: #(\'Jexon\' \'John\' \'5 Baverli Hills\');\r            add: #(\'Adams\' \'John\' \'1 Hell str\');\r            add: #(\'Taylor\' \'Babe\' \'2a/35 Deribas str\');\r            add: #(\'Greg\' \'Voss\' \'12345 the USA\')."<-- #(\'Greg\' \'Voss\' \'12345 the USA\')"\r\r" * --- Додайте власні записи. Видрукуйте вміст книги (код запропоновано нижче)."\r   | s w |  s := WriteStream on: String new.\r\r    AddressBook do:[:x | x do:\r        [ :y | s nextPutAll: y; tab; tab.].\r        s cr. ]. "<-- a SortedCollection(#(\'Adams\' \'John\' \'1 Hell str\') \r\t\t\t\t\t  #(\'Greg\' \'Voss\' \'12345 the USA\') #(\'Jexon\' \'John\' \'5 Baverli Hills\') \r\t\t\t\t\t  #(\'Ruth\' \'Babe\' \'456 Mudville Flats\') #(\'Smith\' \'John\' \'12/5 Park Ave\') \r\t\t\t\t\t  #(\'Taylor\' \'Babe\' \'2a/35 Deribas str\'))"\r\r\tAddressBook\r    add: #(\'Brown\' \'Alice\' \'7 Cherry Lane\');\r    add: #(\'White\' \'Bob\' \'15 Oak Street\');\r    add: #(\'Green\' \'Clara\' \'9 Pine Avenue\').\r\r\t  \r\ts := WriteStream on: String new.\r\tAddressBook do: [ :x | x do: [ :y | s nextPutAll: y; tab; tab. ] ] \r\t\r\t\r  w := Workspace openLabel: \'My Address Book\'.\r  w contents: s contents.\r\r" * ----  Наступне завдання - надрукувати список прізвищ людей з однаковими іменами. \r              Приклад демонструє різні способи перебору та перетворення колекцій."\r\r | firstNames duplicates |\r    firstNames:=Bag new.        "утворимо торбу імен"\r    AddressBook do: [ :entry | firstNames add: (entry at: 2) ]. "<-- a SortedCollection(#(\'Adams\' \'John\' \'1 Hell str\') #(\'Greg\' \'Voss\' \'12345 the USA\') \r\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t#(\'Jexon\' \'John\' \'5 Baverli Hills\') #(\'Ruth\' \'Babe\' \'456 Mudville Flats\') #(\'Smith\' \'John\' \'12/5 Park Ave\')\r\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t#(\'Taylor\' \'Babe\' \'2a/35 Deribas str\'))"\r\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r        "виберемо ті імена, які зустрічаються більше одного разу"\r    duplicates:=firstNames select:\r        [ :name | (firstNames occurrencesOf: name)>1 ]. "<-- a Bag(\'John\' \'John\' \'John\' \'Babe\' \'Babe\')"\r            "і впорядкуємо їх"\r    duplicates:=duplicates asSet asSortedCollection. "<-- a SortedCollection(\'Babe\' \'John\')"\r        "друкуємо імена та відповідні їм прізвища"\r    duplicates do: [ :first | first printOn: Transcript. Transcript show:\'==>\'.\r        AddressBook do: [ :entry | (entry at: 2)=first\r            ifTrue: [ Transcript show:\' \'. (entry at: 1) printOn: Transcript ] ].\r        Transcript cr ]. Transcript show:\' \'.\r\r" Поясніть перетворення, що відбуваються в цьому фрагменті:\r\tBag — дозволяє зберігати елементи з повтореннями.\r\tselect: — фільтрує колекцію, залишаючи тільки елементи, що задовольняють умові (тут, occurrencesOf: > 1).\r\tasSet — видаляє дублікати після фільтрації.\r\tasSortedCollection — сортує результати для зручного виводу.\r\tdo: — ітерує колекцію і виконує дію (друк у Transcript).\r\r   Запропонуйте власні варіанти використання та перетворення колекцій. \r \r  Оформіть запропоновані вище фрагменти як методи навчального класу:\r\tObject subclass: #AddressBookUtils\r    \tinstanceVariableNames: \'\'\r    \tclassVariableNames: \'\'\r    \tpoolDictionaries: \'\'\r    \tcategory: \'Training-Examples\'.\r\r"\r\r\r" ------ ДОДАВАННЯ АДРЕС\r  Можливо, додавання записів до AddressBook за допомогою явного програмування \r  виглядає не надто привабливо. Використайте з цією метою діалоги "\r\r| a b c | \ra := UIManager default request: \'Input first name\'.\rb := UIManager default request: \'Input second name\'.\rc := UIManager default request: \'Input address\'.\ra isNil | b isNil | c isNil ifFalse: [ AddressBook add: (Array with:a with:b with:c)]. "<-- #(\'Oleh\' \'Chyzhov\' \'MyAddress 23\')"\r\r" Додайте до книги декілька нових записів, знову видрукуйте її. "\r"Через це в книзі так багато записів:"\r[\r    | a b c |\r    a := UIManager default request: \'Input first name\'.\r    a isNil ifTrue: [ ^self ].  "Cancel завершує цикл"\r\r    b := UIManager default request: \'Input second name\'.\r    b isNil ifTrue: [ ^self ].\r\r    c := UIManager default request: \'Input address\'.\r    c isNil ifTrue: [ ^self ].\r\r    AddressBook add: (Array with: a with: b with: c).\r] repeat.\r\r\ts := WriteStream on: String new.\r\tAddressBook do: [ :x | x do: [ :y | s nextPutAll: y; tab; tab. ] ] "<--  \r\ta SortedCollection(\r\t#(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') \r\t#(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') \r\t#(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'\' \'\' \'\') #(\'Adams\' \'John\' \'1 Hell str\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') \r\t#(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Brown\' \'Alice\' \'7 Cherry Lane\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') \r\t#(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Green\' \'Clara\' \'9 Pine Avenue\') #(\'Greg\' \'Voss\' \'12345 the USA\') #(\'Jexon\' \'John\' \'5 Baverli Hills\') \r\t#(\'Oleh\' \'Chyzhov\' \'MyAddress 23\') #(\'Oleh\' \'Chyzhov\' \'MyAddress 23\') #(\'Oleh\' \'Chyzhov\' \'ofjidjf\') #(\'Oleh\' \'Chyzhov\' \'frjgirgjir\') #(\'Ruth\' \'Babe\' \'456 Mudville Flats\') \r\t#(\'Smith\' \'John\' \'12/5 Park Ave\') #(\'Taylor\' \'Babe\' \'2a/35 Deribas str\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'White\' \'Bob\' \'15 Oak Street\') \r\t#(\'White\' \'Bob\' \'15 Oak Street\') #(\'White\' \'Bob\' \'15 Oak Street\') #(\'oleh\' \'chyzhov\' \'myaddress 23\'))"\r\r" Поміркуйте, як зробити зручнішим звертання до діалогу додавання адрес та друку адресної книги. \rМожна винести логіку у клас: один метод відповідатиме за введення одного запису. Інший — за введення кількох записів. Ще інший — за друк книги"\r\r" Що станеться, якщо виконати наступний код? Випробуйте. "\r    Smalltalk globals removeKey:#AddressBook. "<-- з глобального словника Smalltalk globals буде видалено ключ #AddressBook і, відповідно, саму твою колекцію (адресну книгу)."\r\r "------ ПЕРЕТВОРЕННЯ (ПЕРЕВТІЛЕННЯ) ОБ\'ЄКТІВ\r   Виконайте за допомогою Do It. "\r\r | a b c|\r    a := OrderedCollection new.\r    b := Cylinder new.\r    c := Array with: a with: b with: b.\r    Transcript show: \'Old Array is = \'.\r    c do: [ :x | Transcript show: \'     \'. x printOn: Transcript ].\r    Transcript cr.\r    a become: b.\r    Transcript show: \'New Array is = \'.\r    c do: [ :x | Transcript show: \'     \'. x printOn: Transcript ].\r    Transcript cr; show:\' \'. "<-- Unknown variable"\r\r" Поясніть дію методу become:. Чи можна замість нього користуватися звичайним присвоєнням? Наведіть власні приклади. "\r\r" Метод become: міняє всі посилання на два об’єкти місцями у всій системі.  \r  Це відрізняється від простого присвоєння, яке змінює лише одну змінну.  \r  У прикладі масив c до become: містив [OrderedCollection, Cylinder, Cylinder],  \r  а після become: став [Cylinder, OrderedCollection, OrderedCollection].  \r  Звичайним присвоєнням такого ефекту не досягти. "\r\r\r\r\r\r\r\r'
}OmEntry {
	#tags : {
		#timestamp : DateAndTime [ '2025-10-04T22:21:36.653+03:00' ],
		#self : OmReference [ '11' ]
	},
	#content : '"--------------------------------------------------------------------------------------\r*                      ЛАБОРОТОРНА РОБОТА 3\r*                 Тема: КЛАСИ ТА МЕТОДИ. КОЛЕКЦІЇ\r*\r*  Завдання до лабораторної роботи:\r*     1. Виконайте наведені нижче приклади, збережіть і поясніть отримані результати.\r*     2. Випробуйте різноманітні способи додавання нових класів до системи.\r*     3. Навчіться доповнювати функціональність класів.\r*     4. Випробуйте методи опрацювання колекцій.\r*\r\r    Виконайте за допомогою <Print it> \r\r ------ ПРИНАЛЕЖНІСТЬ КЛАСОВІ, ІЄРАРХІЯ КЛАСІВ\r"\r    #(Francesca Jackie Marisa Bree) class. "Array"\r    (#(Francesca Jackie Marisa Bree) at:2) class. "ByteSymbol"\r    \'Rakesh Vijay Charles Daniel Tyler\' class. "ByteString"\r    (\'Rakesh Vijay Charles Daniel Tyler\' at:2) class. "Character (a)"\r    World class . "WorldMorph"\r    Magnitude class. "Magnitude class"\r    Magnitude class class. "Metaclass"\r    nil class. "UndefinedObject"\r    5 species. "SmallInteger"\r    123456789000 species. "SmallInteger"\r    #aName species. "ByteString"\r " Яка різниця між повідомленнями class i species ? \r\r    Випробуйте різні способи відкривання браузера класів: за допомогою меню чи програмно \r     Виконайте за допомогою <Do it>\r"\r    ClyFullBrowserMorph open. \r    ClyFullBrowserMorph openOnClass: Date. \r    ClyFullBrowserMorph openOnClass: VolumeShape  selector:  #volume. \r\r" ------ МЕТОДИ КЛАСУ, КОНСТРУКТОРИ\r  Виконайте за допомогою <Print It>. Запропонуйте власні приклади. "\r\r    Array new: 10. "#(nil nil nil nil nil nil nil nil nil nil)"        \r    OrderedCollection  new. "an OrderedCollection()"\r    Date today. "29 September 2025"\r    Time now. "10:28:52.422 am"\r    UIManager default  request:\'How are you?\' initialAnswer:\'I\'\'m fine!\'. "\'I\'\'m fine!\'"\r    Integer readFrom: \'2013  1925\'. "2013"\r    Integer primesUpTo: 100. "#(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97)"\r    Rectangle origin:0@0 corner:200@100. "(0@0) corner: (200@100)"\r    Date nameOfMonth:12. "#December"\r    Date dayOfWeek: #Friday. "6"\r    Date orthodoxEasterDateFor: 2022. "24 April 2022"\r\r\r   \r"Інсталюйте вказані нижче МЕТОДИ КЛАСУ Date:\r  перенесіть копію тексту визначення методу з робочого вікна в браузер класів.\r\r""!Date class methodsFor: \'specific inquiries\' stamp: \'CamilloBruni 8/22/2013 19:47\'!""\r\rorthodoxEasterDateFor: year\r ""  compute the easter date according to the rules of the orthodox calendar.\r    source:       http://www.smart.net/~mmontes/ortheast.html   ""\r     | r1 r2 r3 r4 ra rb r5 rc date |\r\r    r1 := year \\\\ 19.\r    r2 := year \\\\ 4.\r    r3 := year \\\\ 7.\r    ra := 19*r1 + 16.\r    r4 := ra \\\\ 30.\r    rb := r2 + r2 + (4*r3) + (6*r4).\r    r5 := rb \\\\ 7.\r    rc := r4 + r5.\r    date := self year: year month: 4 day: 3.\r    ^date addDays: rc.\r""--------------------------------------------------------------------------------------""\r""!Date class methodsFor: \'specific inquiries\' stamp: \'CamilloBruni 8/22/2013 19:48\'!""\r\reasterDateFor: year\r ""  compute the easter date.\r    source: Physikalisch-Technische Bundesanstalt Braunschweig.\r    Lichtenberg, H.: Zur Interpretation der Gaussschen Osterformel und ihrer Ausnahmeregeln, Historia Mathematica 24 (1997), pp. 441-444\r      http://www.ptb.de/de/org/4/44/441/oste.htm  ""\r\r  | k m s a d r og sz oe day |\r\r  k := year // 100.\r  m := 15 + (3*k + 3//4) - (8*k + 13//25).\r   s := 2 - (3*k + 3// 4).\r  a := year \\\\ 19.\r  d := 19*a + m \\\\ 30.\r  r := d//29 + ((d//28) - (d//29)* (a// 11)).\r\r  og := 21 + d - r.\r  sz := 7 - (year//4 + year + s\\\\7).\r  oe := 7 - (og - sz\\\\7).\r  day := og + oe.\r  ^day <= 31\r    ifTrue: [ Date year: year month: 3 day: day ]\r    ifFalse: [ Date year: year month: 4 day: day - 31 ].\r"\r\r"Знайдіть роки, коли святкування припадають на один день."\r\ryearsWithMatchingEasterFrom: startYear to: endYear\r\r    | matchingYears orthodoxDate catholicDate |\r    matchingYears := OrderedCollection new.\r    (startYear to: endYear) do: [:year |\r        orthodoxDate := self orthodoxEasterDateFor: year.\r        catholicDate := self easterDateFor: year.\r        (orthodoxDate = catholicDate) ifTrue: [\r            matchingYears add: year\r        ].\r    ].\r    ^matchingYears asArray\r\rDate yearsWithMatchingEasterFrom: 2000 to: 2050. "#(2001 2004 2007 2010 2011 2014 2017 2025 2028 2031 2034 2037 2038 2041 2045 2048)"\r\r" ------ РЕКУРСІЯ\r  Додайте до класу Integer і випробуйте різні методи обчислення чисел  Фібоначчі.\r  Запропонуйте власні. Порівняйте їхню ефективність.      \r  Перед випробуванням fibonacci ЗБЕРЕЖІТЬ ІМІДЖ СИСТЕМИ! Він може зайняти Ваш комп на тиждень.  "\r\r3 fibStart: 1 with: 10  "<-- 12"\r4 fibo "<-- 5"\r12 fibonacci "<-- 233"\r\r\r"\r==============\rВласні методи:\r==============\r\r- Метод 1:\rInteger >> factorial\r    ""Обчислення факторіалу числа""\r    ^ self <= 1 ifTrue: [1] ifFalse: [self * (self - 1) factorial].\r\r- Метод 2:\rInteger >> sumTo\r    ""Сума всіх чисел від 1 до self""\r    | sum i |\r    sum := 0.\r    1 to: self do: [:i | sum := sum + i].\r    ^ sum.\r"\r\r"\rПояснення: <fibStart:with:>\rРекурсивний метод, який обчислює n-те число Фібоначчі, використовуючи два акумулятори: n1 (попереднє) і n2 (пред-попереднє).\rРекурсія: (self - 1) fibStart: n1+n2 with: n1 → наступний крок отримує нове попереднє число як суму двох попередніх.\r\rДуже швидкий для будь-якого n, навіть великого. Не обчислює одні й ті ж значення повторно → O(n). \rПам’яті потрібно лише для стеку рекурсії (глибина n).\r\rПояснення: <fibo>\rПроста обгортка над <fibStart:with:.>\r\rПовністю така ж, як у fibStart:with:. Зручно викликати без ручного передавання початкових чисел.\r\rПояснення: <fibonacci>\rКласична рекурсія: F(n) = F(n-1) + F(n-2).\r\rДуже повільний для великих n. Обчислює одні й ті ж значення багато разів → експоненційна складність O(2ⁿ). \rМоже сильно навантажити процесор і стек викликів.\r"\r\r"------------------------------------------------------------------------------------\r ------ СТВОРЕННЯ, ОПРАЦЮВАННЯ КОЛЕКЦІЙ\r  У текстовому файлі записано інформацію про матрицю цілих чисел: розміри\r  матриці в першому рядку файла, у всіх наступних рядках - рядки матриці.}\r  Прочитати матрицю, знайти максимальні елементи кожного рядка і зберегти\r  їх у файлі. Надрукувати максимальний елемент цілої матриці."\r\r"Наведений нижче код можна виконати безпосередньо в робочому вікні,\r проте,  доцільно зробити його методом власного навчального класу."\r\r| matr fStream fName n m mMatr mLines |\r        "Вибір файла за допомогою діалогу"\r    (fName:=UIManager default\r\t\t\tchooseFullFileNameMatching: nil \r\t\t\tlabel: \'Виберіть файл з числовими даними\' ) isNil\r        ifTrue: [ ^\'Ви не вибрали файла\' ]. \r        fStream := fName asFileReference readStream.\r\t        "Введення даних"\r \t    n := Integer readFrom: fStream.  \r\t    matr := Array new: n.\r\t    m := Integer readFrom: fStream.\r\t    matr := matr collect: [ :x | Array new: m ]. \r\t    1 to: n do: [ :i |  fStream nextLine.\r \t\t     matr at: i put: (\r\t\t\t\t (matr at: i) collect: [ :x |  \r\t\t\t\t\t\tInteger readFrom: fStream. ]\r\t\t\t\t\t )\t ].\r    fStream close. matr inspect.\r        "Обчислення максимальних елементів"\r    mLines:=matr collect: [ :r | r inject: (r at: 1) into: [ :x :y | x max: y] ].\r    mMatr:=mLines at: 1.\r    mLines do: [ :x | x > mMatr ifTrue: [ mMatr := x ] ].\r        "Побудова імені файла результатів, збереження"\r    fName at: fName size - 4 put: $_ .\r    fStream := fName asFileReference writeStream.\r    mLines do: [ :x | x printOn: fStream. fStream cr ].\r    fStream close.\r    ^mMatr .  \r\r" Поясніть код, наведений вище (кожне повідомлення!):\r\r\t| matr fStream fName n m mMatr mLines | <-- Локальні змінні\r\r\tВідкриваємо діалог вибору файлу. Якщо користувач не вибрав файл – повертаємо повідомлення:\r\t(fName := UIManager default\r\t    chooseFullFileNameMatching: nil\r\t    label: \'Виберіть файл з числовими даними\') isNil\r\t    ifTrue: [ ^\'Ви не вибрали файла\' ].\r\r\tfStream := fName asFileReference readStream. <-- Відкриваємо потік для читання файлу\r\tn := Integer readFrom: fStream. <-- Читаємо перше число з файлу – кількість рядків матриці\r\tmatr := Array new: n. <-- Створюємо масив для рядків матриці:\r\tm := Integer readFrom: fStream. <-- Читаємо друге число з файлу – кількість стовпців матриці\r\tmatr := matr collect: [:x | Array new: m]. <-- Заповнюємо кожен рядок новим масивом стовпців (масив масивів)\r\r\tПроходимо по кожному рядку:\r\t - пропускаємо порожню або заголовочну лінію\r\t - читаємо числа рядка і записуємо у відповідний рядок матриці:\r\t1 to: n do: [:i |\r\t    fStream nextLine.\r\t    matr at: i put: (\r\t        (matr at: i) collect: [:x | Integer readFrom: fStream]\r\t    )].\r\r\tfStream close. <-- Закриваємо потік після читання\r\tmatr inspect. <-- Відкриваємо інспектор для перегляду матриці\r\r\tОбчислюємо максимум у кожному рядку:\r\t - inject: використовується для проходження елементів\r\t - функція x max: y повертає більший елемент\r\tmLines := matr collect: [:r | r inject: (r at: 1) into: [:x :y | x max: y]].\r\r\tЗнаходимо загальний максимум матриці:\r\t - проходимо по максимумам рядків і оновлюємо mMatr:\r\tmMatr := mLines at: 1.\r\tmLines do: [:x | x > mMatr ifTrue: [ mMatr := x ]].\r\r\tfName at: fName size - 4 put: $_. <-- Змінюємо розширення файлу для збереження результатів\r\tfStream := fName asFileReference writeStream. <-- Відкриваємо потік для запису у файл\r\tmLines do: [:x | x printOn: fStream. fStream cr]. <-- Записуємо максимуми рядків у файл, кожен на новий рядок\r\tfStream close. <-- Закриваємо файл після запису\r\t^ mMatr. <-- Повертаємо максимальний елемент всієї матриці\r\r   Як замінити масивмасивів на екземпляр класу Matrix?:\r\tMatrix замінює масив масивів, тобто ми маємо одну структуру n × m. До елементів доступ через at: i at: j.\r\tЦе дозволяє компактно читати дані з файлу, знаходити максимуми і записувати результати, не створюючи додаткових масивів рядків:\r\t\r\t| matr fStream n m mMatr |\r\r\tВідкриваємо файл та читаємо розміри:\r\tfStream := \'file.txt\' asFileReference readStream.\r\tn := Integer readFrom: fStream.\r\tm := Integer readFrom: fStream.\r\r\tСтворюємо і заповнюємо матрицю:\r\tmatr := Matrix rows: n columns: m.\r\t1 to: n do: [:i | 1 to: m do: [:j | matr at: i at: j put: Integer readFrom: fStream]].\r\tfStream close.\r\r\tЗнаходимо загальний максимум:\r\tmMatr := (1 to: n) inject: 0 into: [:maxRow :i | maxRow max: ((1 to: m) inject: 0 into: [:maxCol :j | maxCol max: (matr at: i at: j)])].\r\t^ mMatr.\r\r======================================================\r\r ------ АДРЕСНА КНИГА\r Приклад створення і використання адресної книги, описаний у одній з лекцій. \r Пригадуєте, спочатку оголошуємо глобальну змінну, що міститиме впорядковану \r колекцію масивів з трьох рядків. Спосіб порівняння описує бінарний блок.    "\r\r    Smalltalk globals at: #AddressBook\r              put:(SortedCollection sortBlock:[:a :b | (a at:1)<=(b at:1)]).\r\r" * --- Тепер до книги можна додавати записи. "\r\r    AddressBook\r            add: #(\'Ruth\' \'Babe\' \'456 Mudville Flats\');\r            add: #(\'Smith\' \'John\' \'12/5 Park Ave\');\r            add: #(\'Jexon\' \'John\' \'5 Baverli Hills\');\r            add: #(\'Adams\' \'John\' \'1 Hell str\');\r            add: #(\'Taylor\' \'Babe\' \'2a/35 Deribas str\');\r            add: #(\'Greg\' \'Voss\' \'12345 the USA\')."<-- #(\'Greg\' \'Voss\' \'12345 the USA\')"\r\r" * --- Додайте власні записи. Видрукуйте вміст книги (код запропоновано нижче)."\r   | s w |  s := WriteStream on: String new.\r\r    AddressBook do:[:x | x do:\r        [ :y | s nextPutAll: y; tab; tab.].\r        s cr. ]. "<-- a SortedCollection(#(\'Adams\' \'John\' \'1 Hell str\') \r\t\t\t\t\t  #(\'Greg\' \'Voss\' \'12345 the USA\') #(\'Jexon\' \'John\' \'5 Baverli Hills\') \r\t\t\t\t\t  #(\'Ruth\' \'Babe\' \'456 Mudville Flats\') #(\'Smith\' \'John\' \'12/5 Park Ave\') \r\t\t\t\t\t  #(\'Taylor\' \'Babe\' \'2a/35 Deribas str\'))"\r\r\tAddressBook\r    add: #(\'Brown\' \'Alice\' \'7 Cherry Lane\');\r    add: #(\'White\' \'Bob\' \'15 Oak Street\');\r    add: #(\'Green\' \'Clara\' \'9 Pine Avenue\').\r\r\t  \r\ts := WriteStream on: String new.\r\tAddressBook do: [ :x | x do: [ :y | s nextPutAll: y; tab; tab. ] ] \r\t\r\t\r  w := Workspace openLabel: \'My Address Book\'.\r  w contents: s contents.\r\r" * ----  Наступне завдання - надрукувати список прізвищ людей з однаковими іменами. \r              Приклад демонструє різні способи перебору та перетворення колекцій."\r\r | firstNames duplicates |\r    firstNames:=Bag new.        "утворимо торбу імен"\r    AddressBook do: [ :entry | firstNames add: (entry at: 2) ]. "<-- a SortedCollection(#(\'Adams\' \'John\' \'1 Hell str\') #(\'Greg\' \'Voss\' \'12345 the USA\') \r\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t#(\'Jexon\' \'John\' \'5 Baverli Hills\') #(\'Ruth\' \'Babe\' \'456 Mudville Flats\') #(\'Smith\' \'John\' \'12/5 Park Ave\')\r\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t#(\'Taylor\' \'Babe\' \'2a/35 Deribas str\'))"\r\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r        "виберемо ті імена, які зустрічаються більше одного разу"\r    duplicates:=firstNames select:\r        [ :name | (firstNames occurrencesOf: name)>1 ]. "<-- a Bag(\'John\' \'John\' \'John\' \'Babe\' \'Babe\')"\r            "і впорядкуємо їх"\r    duplicates:=duplicates asSet asSortedCollection. "<-- a SortedCollection(\'Babe\' \'John\')"\r        "друкуємо імена та відповідні їм прізвища"\r    duplicates do: [ :first | first printOn: Transcript. Transcript show:\'==>\'.\r        AddressBook do: [ :entry | (entry at: 2)=first\r            ifTrue: [ Transcript show:\' \'. (entry at: 1) printOn: Transcript ] ].\r        Transcript cr ]. Transcript show:\' \'.\r\r" Поясніть перетворення, що відбуваються в цьому фрагменті:\r\tBag — дозволяє зберігати елементи з повтореннями.\r\tselect: — фільтрує колекцію, залишаючи тільки елементи, що задовольняють умові (тут, occurrencesOf: > 1).\r\tasSet — видаляє дублікати після фільтрації.\r\tasSortedCollection — сортує результати для зручного виводу.\r\tdo: — ітерує колекцію і виконує дію (друк у Transcript).\r\r   Запропонуйте власні варіанти використання та перетворення колекцій. \r \r  Оформіть запропоновані вище фрагменти як методи навчального класу:\r\tObject subclass: #AddressBookUtils\r    \tinstanceVariableNames: \'\'\r    \tclassVariableNames: \'\'\r    \tpoolDictionaries: \'\'\r    \tcategory: \'Training-Examples\'.\r\r"\r\r\r" ------ ДОДАВАННЯ АДРЕС\r  Можливо, додавання записів до AddressBook за допомогою явного програмування \r  виглядає не надто привабливо. Використайте з цією метою діалоги "\r\r| a b c | \ra := UIManager default request: \'Input first name\'.\rb := UIManager default request: \'Input second name\'.\rc := UIManager default request: \'Input address\'.\ra isNil | b isNil | c isNil ifFalse: [ AddressBook add: (Array with:a with:b with:c)]. "<-- #(\'Oleh\' \'Chyzhov\' \'MyAddress 23\')"\r\r" Додайте до книги декілька нових записів, знову видрукуйте її. "\r"Через це в книзі так багато записів:"\r[\r    | a b c |\r    a := UIManager default request: \'Input first name\'.\r    a isNil ifTrue: [ ^self ].  "Cancel завершує цикл"\r\r    b := UIManager default request: \'Input second name\'.\r    b isNil ifTrue: [ ^self ].\r\r    c := UIManager default request: \'Input address\'.\r    c isNil ifTrue: [ ^self ].\r\r    AddressBook add: (Array with: a with: b with: c).\r] repeat.\r\r\ts := WriteStream on: String new.\r\tAddressBook do: [ :x | x do: [ :y | s nextPutAll: y; tab; tab. ] ]\r\r" Поміркуйте, як зробити зручнішим звертання до діалогу додавання адрес та друку адресної книги. "\r\r" Що станеться, якщо виконати наступний код? Випробуйте. "\r    Smalltalk globals removeKey:#AddressBook. "<-- з глобального словника Smalltalk globals буде видалено ключ #AddressBook і, відповідно, саму твою колекцію (адресну книгу)."\r\r "------ ПЕРЕТВОРЕННЯ (ПЕРЕВТІЛЕННЯ) ОБ\'ЄКТІВ\r   Виконайте за допомогою Do It. "\r\r | a b c|\r    a := OrderedCollection new.\r    b := Cylinder new.\r    c := Array with: a with: b with: b.\r    Transcript show: \'Old Array is = \'.\r    c do: [ :x | Transcript show: \'     \'. x printOn: Transcript ].\r    Transcript cr.\r    a become: b.\r    Transcript show: \'New Array is = \'.\r    c do: [ :x | Transcript show: \'     \'. x printOn: Transcript ].\r    Transcript cr; show:\' \'. "<-- Unknown variable"\r\r" Поясніть дію методу become:. Чи можна замість нього користуватися звичайним присвоєнням? Наведіть власні приклади. "\r\r" Він міняє всі посилання на два об’єкти місцями у всій системі.  \r  Це відрізняється від простого присвоєння, яке змінює лише одну змінну.  \r  У прикладі масив c до become: містив [OrderedCollection, Cylinder, Cylinder],  \r  а після become: став [Cylinder, OrderedCollection, OrderedCollection].  \r  Звичайним присвоєнням такого ефекту не досягти. "\r\r\r\r\r\r\r\r'
}OmEntry {
	#tags : {
		#timestamp : DateAndTime [ '2025-10-04T22:23:15.383+03:00' ],
		#self : OmReference [ '12' ]
	},
	#content : '"--------------------------------------------------------------------------------------\r*                      ЛАБОРОТОРНА РОБОТА 3\r*                 Тема: КЛАСИ ТА МЕТОДИ. КОЛЕКЦІЇ\r*\r*  Завдання до лабораторної роботи:\r*     1. Виконайте наведені нижче приклади, збережіть і поясніть отримані результати.\r*     2. Випробуйте різноманітні способи додавання нових класів до системи.\r*     3. Навчіться доповнювати функціональність класів.\r*     4. Випробуйте методи опрацювання колекцій.\r*\r\r    Виконайте за допомогою <Print it> \r\r ------ ПРИНАЛЕЖНІСТЬ КЛАСОВІ, ІЄРАРХІЯ КЛАСІВ\r"\r    #(Francesca Jackie Marisa Bree) class. "Array"\r    (#(Francesca Jackie Marisa Bree) at:2) class. "ByteSymbol"\r    \'Rakesh Vijay Charles Daniel Tyler\' class. "ByteString"\r    (\'Rakesh Vijay Charles Daniel Tyler\' at:2) class. "Character (a)"\r    World class . "WorldMorph"\r    Magnitude class. "Magnitude class"\r    Magnitude class class. "Metaclass"\r    nil class. "UndefinedObject"\r    5 species. "SmallInteger"\r    123456789000 species. "SmallInteger"\r    #aName species. "ByteString"\r " Яка різниця між повідомленнями class i species ? \r\r    Випробуйте різні способи відкривання браузера класів: за допомогою меню чи програмно \r     Виконайте за допомогою <Do it>\r"\r    ClyFullBrowserMorph open. \r    ClyFullBrowserMorph openOnClass: Date. \r    ClyFullBrowserMorph openOnClass: VolumeShape  selector:  #volume. \r\r" ------ МЕТОДИ КЛАСУ, КОНСТРУКТОРИ\r  Виконайте за допомогою <Print It>. Запропонуйте власні приклади. "\r\r    Array new: 10. "#(nil nil nil nil nil nil nil nil nil nil)"        \r    OrderedCollection  new. "an OrderedCollection()"\r    Date today. "29 September 2025"\r    Time now. "10:28:52.422 am"\r    UIManager default  request:\'How are you?\' initialAnswer:\'I\'\'m fine!\'. "\'I\'\'m fine!\'"\r    Integer readFrom: \'2013  1925\'. "2013"\r    Integer primesUpTo: 100. "#(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97)"\r    Rectangle origin:0@0 corner:200@100. "(0@0) corner: (200@100)"\r    Date nameOfMonth:12. "#December"\r    Date dayOfWeek: #Friday. "6"\r    Date orthodoxEasterDateFor: 2022. "24 April 2022"\r\r\r   \r"Інсталюйте вказані нижче МЕТОДИ КЛАСУ Date:\r  перенесіть копію тексту визначення методу з робочого вікна в браузер класів.\r\r""!Date class methodsFor: \'specific inquiries\' stamp: \'CamilloBruni 8/22/2013 19:47\'!""\r\rorthodoxEasterDateFor: year\r ""  compute the easter date according to the rules of the orthodox calendar.\r    source:       http://www.smart.net/~mmontes/ortheast.html   ""\r     | r1 r2 r3 r4 ra rb r5 rc date |\r\r    r1 := year \\\\ 19.\r    r2 := year \\\\ 4.\r    r3 := year \\\\ 7.\r    ra := 19*r1 + 16.\r    r4 := ra \\\\ 30.\r    rb := r2 + r2 + (4*r3) + (6*r4).\r    r5 := rb \\\\ 7.\r    rc := r4 + r5.\r    date := self year: year month: 4 day: 3.\r    ^date addDays: rc.\r""--------------------------------------------------------------------------------------""\r""!Date class methodsFor: \'specific inquiries\' stamp: \'CamilloBruni 8/22/2013 19:48\'!""\r\reasterDateFor: year\r ""  compute the easter date.\r    source: Physikalisch-Technische Bundesanstalt Braunschweig.\r    Lichtenberg, H.: Zur Interpretation der Gaussschen Osterformel und ihrer Ausnahmeregeln, Historia Mathematica 24 (1997), pp. 441-444\r      http://www.ptb.de/de/org/4/44/441/oste.htm  ""\r\r  | k m s a d r og sz oe day |\r\r  k := year // 100.\r  m := 15 + (3*k + 3//4) - (8*k + 13//25).\r   s := 2 - (3*k + 3// 4).\r  a := year \\\\ 19.\r  d := 19*a + m \\\\ 30.\r  r := d//29 + ((d//28) - (d//29)* (a// 11)).\r\r  og := 21 + d - r.\r  sz := 7 - (year//4 + year + s\\\\7).\r  oe := 7 - (og - sz\\\\7).\r  day := og + oe.\r  ^day <= 31\r    ifTrue: [ Date year: year month: 3 day: day ]\r    ifFalse: [ Date year: year month: 4 day: day - 31 ].\r"\r\r"Знайдіть роки, коли святкування припадають на один день."\r\ryearsWithMatchingEasterFrom: startYear to: endYear\r\r    | matchingYears orthodoxDate catholicDate |\r    matchingYears := OrderedCollection new.\r    (startYear to: endYear) do: [:year |\r        orthodoxDate := self orthodoxEasterDateFor: year.\r        catholicDate := self easterDateFor: year.\r        (orthodoxDate = catholicDate) ifTrue: [\r            matchingYears add: year\r        ].\r    ].\r    ^matchingYears asArray\r\rDate yearsWithMatchingEasterFrom: 2000 to: 2050. "#(2001 2004 2007 2010 2011 2014 2017 2025 2028 2031 2034 2037 2038 2041 2045 2048)"\r\r" ------ РЕКУРСІЯ\r  Додайте до класу Integer і випробуйте різні методи обчислення чисел  Фібоначчі.\r  Запропонуйте власні. Порівняйте їхню ефективність.      \r  Перед випробуванням fibonacci ЗБЕРЕЖІТЬ ІМІДЖ СИСТЕМИ! Він може зайняти Ваш комп на тиждень.  "\r\r3 fibStart: 1 with: 10  "<-- 12"\r4 fibo "<-- 5"\r12 fibonacci "<-- 233"\r\r\r"\r==============\rВласні методи:\r==============\r\r- Метод 1:\rInteger >> factorial\r    ""Обчислення факторіалу числа""\r    ^ self <= 1 ifTrue: [1] ifFalse: [self * (self - 1) factorial].\r\r- Метод 2:\rInteger >> sumTo\r    ""Сума всіх чисел від 1 до self""\r    | sum i |\r    sum := 0.\r    1 to: self do: [:i | sum := sum + i].\r    ^ sum.\r"\r\r"\rПояснення: <fibStart:with:>\rРекурсивний метод, який обчислює n-те число Фібоначчі, використовуючи два акумулятори: n1 (попереднє) і n2 (пред-попереднє).\rРекурсія: (self - 1) fibStart: n1+n2 with: n1 → наступний крок отримує нове попереднє число як суму двох попередніх.\r\rДуже швидкий для будь-якого n, навіть великого. Не обчислює одні й ті ж значення повторно → O(n). \rПам’яті потрібно лише для стеку рекурсії (глибина n).\r\rПояснення: <fibo>\rПроста обгортка над <fibStart:with:.>\r\rПовністю така ж, як у fibStart:with:. Зручно викликати без ручного передавання початкових чисел.\r\rПояснення: <fibonacci>\rКласична рекурсія: F(n) = F(n-1) + F(n-2).\r\rДуже повільний для великих n. Обчислює одні й ті ж значення багато разів → експоненційна складність O(2ⁿ). \rМоже сильно навантажити процесор і стек викликів.\r"\r\r"------------------------------------------------------------------------------------\r ------ СТВОРЕННЯ, ОПРАЦЮВАННЯ КОЛЕКЦІЙ\r  У текстовому файлі записано інформацію про матрицю цілих чисел: розміри\r  матриці в першому рядку файла, у всіх наступних рядках - рядки матриці.}\r  Прочитати матрицю, знайти максимальні елементи кожного рядка і зберегти\r  їх у файлі. Надрукувати максимальний елемент цілої матриці."\r\r"Наведений нижче код можна виконати безпосередньо в робочому вікні,\r проте,  доцільно зробити його методом власного навчального класу."\r\r| matr fStream fName n m mMatr mLines |\r        "Вибір файла за допомогою діалогу"\r    (fName:=UIManager default\r\t\t\tchooseFullFileNameMatching: nil \r\t\t\tlabel: \'Виберіть файл з числовими даними\' ) isNil\r        ifTrue: [ ^\'Ви не вибрали файла\' ]. \r        fStream := fName asFileReference readStream.\r\t        "Введення даних"\r \t    n := Integer readFrom: fStream.  \r\t    matr := Array new: n.\r\t    m := Integer readFrom: fStream.\r\t    matr := matr collect: [ :x | Array new: m ]. \r\t    1 to: n do: [ :i |  fStream nextLine.\r \t\t     matr at: i put: (\r\t\t\t\t (matr at: i) collect: [ :x |  \r\t\t\t\t\t\tInteger readFrom: fStream. ]\r\t\t\t\t\t )\t ].\r    fStream close. matr inspect.\r        "Обчислення максимальних елементів"\r    mLines:=matr collect: [ :r | r inject: (r at: 1) into: [ :x :y | x max: y] ].\r    mMatr:=mLines at: 1.\r    mLines do: [ :x | x > mMatr ifTrue: [ mMatr := x ] ].\r        "Побудова імені файла результатів, збереження"\r    fName at: fName size - 4 put: $_ .\r    fStream := fName asFileReference writeStream.\r    mLines do: [ :x | x printOn: fStream. fStream cr ].\r    fStream close.\r    ^mMatr .  \r\r" Поясніть код, наведений вище (кожне повідомлення!):\r\r\t| matr fStream fName n m mMatr mLines | <-- Локальні змінні\r\r\tВідкриваємо діалог вибору файлу. Якщо користувач не вибрав файл – повертаємо повідомлення:\r\t(fName := UIManager default\r\t    chooseFullFileNameMatching: nil\r\t    label: \'Виберіть файл з числовими даними\') isNil\r\t    ifTrue: [ ^\'Ви не вибрали файла\' ].\r\r\tfStream := fName asFileReference readStream. <-- Відкриваємо потік для читання файлу\r\tn := Integer readFrom: fStream. <-- Читаємо перше число з файлу – кількість рядків матриці\r\tmatr := Array new: n. <-- Створюємо масив для рядків матриці:\r\tm := Integer readFrom: fStream. <-- Читаємо друге число з файлу – кількість стовпців матриці\r\tmatr := matr collect: [:x | Array new: m]. <-- Заповнюємо кожен рядок новим масивом стовпців (масив масивів)\r\r\tПроходимо по кожному рядку:\r\t - пропускаємо порожню або заголовочну лінію\r\t - читаємо числа рядка і записуємо у відповідний рядок матриці:\r\t1 to: n do: [:i |\r\t    fStream nextLine.\r\t    matr at: i put: (\r\t        (matr at: i) collect: [:x | Integer readFrom: fStream]\r\t    )].\r\r\tfStream close. <-- Закриваємо потік після читання\r\tmatr inspect. <-- Відкриваємо інспектор для перегляду матриці\r\r\tОбчислюємо максимум у кожному рядку:\r\t - inject: використовується для проходження елементів\r\t - функція x max: y повертає більший елемент\r\tmLines := matr collect: [:r | r inject: (r at: 1) into: [:x :y | x max: y]].\r\r\tЗнаходимо загальний максимум матриці:\r\t - проходимо по максимумам рядків і оновлюємо mMatr:\r\tmMatr := mLines at: 1.\r\tmLines do: [:x | x > mMatr ifTrue: [ mMatr := x ]].\r\r\tfName at: fName size - 4 put: $_. <-- Змінюємо розширення файлу для збереження результатів\r\tfStream := fName asFileReference writeStream. <-- Відкриваємо потік для запису у файл\r\tmLines do: [:x | x printOn: fStream. fStream cr]. <-- Записуємо максимуми рядків у файл, кожен на новий рядок\r\tfStream close. <-- Закриваємо файл після запису\r\t^ mMatr. <-- Повертаємо максимальний елемент всієї матриці\r\r   Як замінити масивмасивів на екземпляр класу Matrix?:\r\tMatrix замінює масив масивів, тобто ми маємо одну структуру n × m. До елементів доступ через at: i at: j.\r\tЦе дозволяє компактно читати дані з файлу, знаходити максимуми і записувати результати, не створюючи додаткових масивів рядків:\r\t\r\t| matr fStream n m mMatr |\r\r\tВідкриваємо файл та читаємо розміри:\r\tfStream := \'file.txt\' asFileReference readStream.\r\tn := Integer readFrom: fStream.\r\tm := Integer readFrom: fStream.\r\r\tСтворюємо і заповнюємо матрицю:\r\tmatr := Matrix rows: n columns: m.\r\t1 to: n do: [:i | 1 to: m do: [:j | matr at: i at: j put: Integer readFrom: fStream]].\r\tfStream close.\r\r\tЗнаходимо загальний максимум:\r\tmMatr := (1 to: n) inject: 0 into: [:maxRow :i | maxRow max: ((1 to: m) inject: 0 into: [:maxCol :j | maxCol max: (matr at: i at: j)])].\r\t^ mMatr.\r\r======================================================\r\r ------ АДРЕСНА КНИГА\r Приклад створення і використання адресної книги, описаний у одній з лекцій. \r Пригадуєте, спочатку оголошуємо глобальну змінну, що міститиме впорядковану \r колекцію масивів з трьох рядків. Спосіб порівняння описує бінарний блок.    "\r\r    Smalltalk globals at: #AddressBook\r              put:(SortedCollection sortBlock:[:a :b | (a at:1)<=(b at:1)]).\r\r" * --- Тепер до книги можна додавати записи. "\r\r    AddressBook\r            add: #(\'Ruth\' \'Babe\' \'456 Mudville Flats\');\r            add: #(\'Smith\' \'John\' \'12/5 Park Ave\');\r            add: #(\'Jexon\' \'John\' \'5 Baverli Hills\');\r            add: #(\'Adams\' \'John\' \'1 Hell str\');\r            add: #(\'Taylor\' \'Babe\' \'2a/35 Deribas str\');\r            add: #(\'Greg\' \'Voss\' \'12345 the USA\')."<-- #(\'Greg\' \'Voss\' \'12345 the USA\')"\r\r" * --- Додайте власні записи. Видрукуйте вміст книги (код запропоновано нижче)."\r   | s w |  s := WriteStream on: String new.\r\r    AddressBook do:[:x | x do:\r        [ :y | s nextPutAll: y; tab; tab.].\r        s cr. ]. "<-- a SortedCollection(#(\'Adams\' \'John\' \'1 Hell str\') \r\t\t\t\t\t  #(\'Greg\' \'Voss\' \'12345 the USA\') #(\'Jexon\' \'John\' \'5 Baverli Hills\') \r\t\t\t\t\t  #(\'Ruth\' \'Babe\' \'456 Mudville Flats\') #(\'Smith\' \'John\' \'12/5 Park Ave\') \r\t\t\t\t\t  #(\'Taylor\' \'Babe\' \'2a/35 Deribas str\'))"\r\r\tAddressBook\r    add: #(\'Brown\' \'Alice\' \'7 Cherry Lane\');\r    add: #(\'White\' \'Bob\' \'15 Oak Street\');\r    add: #(\'Green\' \'Clara\' \'9 Pine Avenue\').\r\r\t  \r\ts := WriteStream on: String new.\r\tAddressBook do: [ :x | x do: [ :y | s nextPutAll: y; tab; tab. ] ] \r\t\r\t\r  w := Workspace openLabel: \'My Address Book\'.\r  w contents: s contents.\r\r" * ----  Наступне завдання - надрукувати список прізвищ людей з однаковими іменами. \r              Приклад демонструє різні способи перебору та перетворення колекцій."\r\r | firstNames duplicates |\r    firstNames:=Bag new.        "утворимо торбу імен"\r    AddressBook do: [ :entry | firstNames add: (entry at: 2) ]. "<-- a SortedCollection(#(\'Adams\' \'John\' \'1 Hell str\') #(\'Greg\' \'Voss\' \'12345 the USA\') \r\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t#(\'Jexon\' \'John\' \'5 Baverli Hills\') #(\'Ruth\' \'Babe\' \'456 Mudville Flats\') #(\'Smith\' \'John\' \'12/5 Park Ave\')\r\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t#(\'Taylor\' \'Babe\' \'2a/35 Deribas str\'))"\r\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r        "виберемо ті імена, які зустрічаються більше одного разу"\r    duplicates:=firstNames select:\r        [ :name | (firstNames occurrencesOf: name)>1 ]. "<-- a Bag(\'John\' \'John\' \'John\' \'Babe\' \'Babe\')"\r            "і впорядкуємо їх"\r    duplicates:=duplicates asSet asSortedCollection. "<-- a SortedCollection(\'Babe\' \'John\')"\r        "друкуємо імена та відповідні їм прізвища"\r    duplicates do: [ :first | first printOn: Transcript. Transcript show:\'==>\'.\r        AddressBook do: [ :entry | (entry at: 2)=first\r            ifTrue: [ Transcript show:\' \'. (entry at: 1) printOn: Transcript ] ].\r        Transcript cr ]. Transcript show:\' \'.\r\r" Поясніть перетворення, що відбуваються в цьому фрагменті:\r\tBag — дозволяє зберігати елементи з повтореннями.\r\tselect: — фільтрує колекцію, залишаючи тільки елементи, що задовольняють умові (тут, occurrencesOf: > 1).\r\tasSet — видаляє дублікати після фільтрації.\r\tasSortedCollection — сортує результати для зручного виводу.\r\tdo: — ітерує колекцію і виконує дію (друк у Transcript).\r\r   Запропонуйте власні варіанти використання та перетворення колекцій. \r \r  Оформіть запропоновані вище фрагменти як методи навчального класу:\r\tObject subclass: #AddressBookUtils\r    \tinstanceVariableNames: \'\'\r    \tclassVariableNames: \'\'\r    \tpoolDictionaries: \'\'\r    \tcategory: \'Training-Examples\'.\r\r"\r\r\r" ------ ДОДАВАННЯ АДРЕС\r  Можливо, додавання записів до AddressBook за допомогою явного програмування \r  виглядає не надто привабливо. Використайте з цією метою діалоги "\r\r| a b c | \ra := UIManager default request: \'Input first name\'.\rb := UIManager default request: \'Input second name\'.\rc := UIManager default request: \'Input address\'.\ra isNil | b isNil | c isNil ifFalse: [ AddressBook add: (Array with:a with:b with:c)]. "<-- #(\'Oleh\' \'Chyzhov\' \'MyAddress 23\')"\r\r" Додайте до книги декілька нових записів, знову видрукуйте її. "\r"Через це в книзі так багато записів:"\r[\r    | a b c |\r    a := UIManager default request: \'Input first name\'.\r    a isNil ifTrue: [ ^self ].  "Cancel завершує цикл"\r\r    b := UIManager default request: \'Input second name\'.\r    b isNil ifTrue: [ ^self ].\r\r    c := UIManager default request: \'Input address\'.\r    c isNil ifTrue: [ ^self ].\r\r    AddressBook add: (Array with: a with: b with: c).\r] repeat.\r\r\ts := WriteStream on: String new.\r\tAddressBook do: [ :x | x do: [ :y | s nextPutAll: y; tab; tab. ] ]\r\r" Поміркуйте, як зробити зручнішим звертання до діалогу додавання адрес та друку адресної книги. "\r\r" Що станеться, якщо виконати наступний код? Випробуйте. "\r    Smalltalk globals removeKey:#AddressBook. "<-- з глобального словника Smalltalk globals буде видалено ключ #AddressBook і, відповідно, саму твою колекцію (адресну книгу)."\r\r "------ ПЕРЕТВОРЕННЯ (ПЕРЕВТІЛЕННЯ) ОБ\'ЄКТІВ\r   Виконайте за допомогою Do It. "\r\r | a b c|\r    a := OrderedCollection new.\r    b := Cylinder new.\r    c := Array with: a with: b with: b.\r    Transcript show: \'Old Array is = \'.\r    c do: [ :x | Transcript show: \'     \'. x printOn: Transcript ].\r    Transcript cr.\r    a become: b.\r    Transcript show: \'New Array is = \'.\r    c do: [ :x | Transcript show: \'     \'. x printOn: Transcript ].\r    Transcript cr; show:\' \'. "<-- Unknown variable"\r\r" Поясніть дію методу become:. Чи можна замість нього користуватися звичайним присвоєнням? Наведіть власні приклади. "\r\r" Він міняє всі посилання на два об’єкти місцями у всій системі.  \r  "\r\r\r\r\r\r\r\r'
}OmEntry {
	#tags : {
		#timestamp : DateAndTime [ '2025-10-04T22:24:12.009+03:00' ],
		#self : OmReference [ '13' ]
	},
	#content : '"--------------------------------------------------------------------------------------\r*                      ЛАБОРОТОРНА РОБОТА 3\r*                 Тема: КЛАСИ ТА МЕТОДИ. КОЛЕКЦІЇ\r*\r*  Завдання до лабораторної роботи:\r*     1. Виконайте наведені нижче приклади, збережіть і поясніть отримані результати.\r*     2. Випробуйте різноманітні способи додавання нових класів до системи.\r*     3. Навчіться доповнювати функціональність класів.\r*     4. Випробуйте методи опрацювання колекцій.\r*\r\r    Виконайте за допомогою <Print it> \r\r ------ ПРИНАЛЕЖНІСТЬ КЛАСОВІ, ІЄРАРХІЯ КЛАСІВ\r"\r    #(Francesca Jackie Marisa Bree) class. "Array"\r    (#(Francesca Jackie Marisa Bree) at:2) class. "ByteSymbol"\r    \'Rakesh Vijay Charles Daniel Tyler\' class. "ByteString"\r    (\'Rakesh Vijay Charles Daniel Tyler\' at:2) class. "Character (a)"\r    World class . "WorldMorph"\r    Magnitude class. "Magnitude class"\r    Magnitude class class. "Metaclass"\r    nil class. "UndefinedObject"\r    5 species. "SmallInteger"\r    123456789000 species. "SmallInteger"\r    #aName species. "ByteString"\r " Яка різниця між повідомленнями class i species ? \r\r    Випробуйте різні способи відкривання браузера класів: за допомогою меню чи програмно \r     Виконайте за допомогою <Do it>\r"\r    ClyFullBrowserMorph open. \r    ClyFullBrowserMorph openOnClass: Date. \r    ClyFullBrowserMorph openOnClass: VolumeShape  selector:  #volume. \r\r" ------ МЕТОДИ КЛАСУ, КОНСТРУКТОРИ\r  Виконайте за допомогою <Print It>. Запропонуйте власні приклади. "\r\r    Array new: 10. "#(nil nil nil nil nil nil nil nil nil nil)"        \r    OrderedCollection  new. "an OrderedCollection()"\r    Date today. "29 September 2025"\r    Time now. "10:28:52.422 am"\r    UIManager default  request:\'How are you?\' initialAnswer:\'I\'\'m fine!\'. "\'I\'\'m fine!\'"\r    Integer readFrom: \'2013  1925\'. "2013"\r    Integer primesUpTo: 100. "#(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97)"\r    Rectangle origin:0@0 corner:200@100. "(0@0) corner: (200@100)"\r    Date nameOfMonth:12. "#December"\r    Date dayOfWeek: #Friday. "6"\r    Date orthodoxEasterDateFor: 2022. "24 April 2022"\r\r\r   \r"Інсталюйте вказані нижче МЕТОДИ КЛАСУ Date:\r  перенесіть копію тексту визначення методу з робочого вікна в браузер класів.\r\r""!Date class methodsFor: \'specific inquiries\' stamp: \'CamilloBruni 8/22/2013 19:47\'!""\r\rorthodoxEasterDateFor: year\r ""  compute the easter date according to the rules of the orthodox calendar.\r    source:       http://www.smart.net/~mmontes/ortheast.html   ""\r     | r1 r2 r3 r4 ra rb r5 rc date |\r\r    r1 := year \\\\ 19.\r    r2 := year \\\\ 4.\r    r3 := year \\\\ 7.\r    ra := 19*r1 + 16.\r    r4 := ra \\\\ 30.\r    rb := r2 + r2 + (4*r3) + (6*r4).\r    r5 := rb \\\\ 7.\r    rc := r4 + r5.\r    date := self year: year month: 4 day: 3.\r    ^date addDays: rc.\r""--------------------------------------------------------------------------------------""\r""!Date class methodsFor: \'specific inquiries\' stamp: \'CamilloBruni 8/22/2013 19:48\'!""\r\reasterDateFor: year\r ""  compute the easter date.\r    source: Physikalisch-Technische Bundesanstalt Braunschweig.\r    Lichtenberg, H.: Zur Interpretation der Gaussschen Osterformel und ihrer Ausnahmeregeln, Historia Mathematica 24 (1997), pp. 441-444\r      http://www.ptb.de/de/org/4/44/441/oste.htm  ""\r\r  | k m s a d r og sz oe day |\r\r  k := year // 100.\r  m := 15 + (3*k + 3//4) - (8*k + 13//25).\r   s := 2 - (3*k + 3// 4).\r  a := year \\\\ 19.\r  d := 19*a + m \\\\ 30.\r  r := d//29 + ((d//28) - (d//29)* (a// 11)).\r\r  og := 21 + d - r.\r  sz := 7 - (year//4 + year + s\\\\7).\r  oe := 7 - (og - sz\\\\7).\r  day := og + oe.\r  ^day <= 31\r    ifTrue: [ Date year: year month: 3 day: day ]\r    ifFalse: [ Date year: year month: 4 day: day - 31 ].\r"\r\r"Знайдіть роки, коли святкування припадають на один день."\r\ryearsWithMatchingEasterFrom: startYear to: endYear\r\r    | matchingYears orthodoxDate catholicDate |\r    matchingYears := OrderedCollection new.\r    (startYear to: endYear) do: [:year |\r        orthodoxDate := self orthodoxEasterDateFor: year.\r        catholicDate := self easterDateFor: year.\r        (orthodoxDate = catholicDate) ifTrue: [\r            matchingYears add: year\r        ].\r    ].\r    ^matchingYears asArray\r\rDate yearsWithMatchingEasterFrom: 2000 to: 2050. "#(2001 2004 2007 2010 2011 2014 2017 2025 2028 2031 2034 2037 2038 2041 2045 2048)"\r\r" ------ РЕКУРСІЯ\r  Додайте до класу Integer і випробуйте різні методи обчислення чисел  Фібоначчі.\r  Запропонуйте власні. Порівняйте їхню ефективність.      \r  Перед випробуванням fibonacci ЗБЕРЕЖІТЬ ІМІДЖ СИСТЕМИ! Він може зайняти Ваш комп на тиждень.  "\r\r3 fibStart: 1 with: 10  "<-- 12"\r4 fibo "<-- 5"\r12 fibonacci "<-- 233"\r\r\r"\r==============\rВласні методи:\r==============\r\r- Метод 1:\rInteger >> factorial\r    ""Обчислення факторіалу числа""\r    ^ self <= 1 ifTrue: [1] ifFalse: [self * (self - 1) factorial].\r\r- Метод 2:\rInteger >> sumTo\r    ""Сума всіх чисел від 1 до self""\r    | sum i |\r    sum := 0.\r    1 to: self do: [:i | sum := sum + i].\r    ^ sum.\r"\r\r"\rПояснення: <fibStart:with:>\rРекурсивний метод, який обчислює n-те число Фібоначчі, використовуючи два акумулятори: n1 (попереднє) і n2 (пред-попереднє).\rРекурсія: (self - 1) fibStart: n1+n2 with: n1 → наступний крок отримує нове попереднє число як суму двох попередніх.\r\rДуже швидкий для будь-якого n, навіть великого. Не обчислює одні й ті ж значення повторно → O(n). \rПам’яті потрібно лише для стеку рекурсії (глибина n).\r\rПояснення: <fibo>\rПроста обгортка над <fibStart:with:.>\r\rПовністю така ж, як у fibStart:with:. Зручно викликати без ручного передавання початкових чисел.\r\rПояснення: <fibonacci>\rКласична рекурсія: F(n) = F(n-1) + F(n-2).\r\rДуже повільний для великих n. Обчислює одні й ті ж значення багато разів → експоненційна складність O(2ⁿ). \rМоже сильно навантажити процесор і стек викликів.\r"\r\r"------------------------------------------------------------------------------------\r ------ СТВОРЕННЯ, ОПРАЦЮВАННЯ КОЛЕКЦІЙ\r  У текстовому файлі записано інформацію про матрицю цілих чисел: розміри\r  матриці в першому рядку файла, у всіх наступних рядках - рядки матриці.}\r  Прочитати матрицю, знайти максимальні елементи кожного рядка і зберегти\r  їх у файлі. Надрукувати максимальний елемент цілої матриці."\r\r"Наведений нижче код можна виконати безпосередньо в робочому вікні,\r проте,  доцільно зробити його методом власного навчального класу."\r\r| matr fStream fName n m mMatr mLines |\r        "Вибір файла за допомогою діалогу"\r    (fName:=UIManager default\r\t\t\tchooseFullFileNameMatching: nil \r\t\t\tlabel: \'Виберіть файл з числовими даними\' ) isNil\r        ifTrue: [ ^\'Ви не вибрали файла\' ]. \r        fStream := fName asFileReference readStream.\r\t        "Введення даних"\r \t    n := Integer readFrom: fStream.  \r\t    matr := Array new: n.\r\t    m := Integer readFrom: fStream.\r\t    matr := matr collect: [ :x | Array new: m ]. \r\t    1 to: n do: [ :i |  fStream nextLine.\r \t\t     matr at: i put: (\r\t\t\t\t (matr at: i) collect: [ :x |  \r\t\t\t\t\t\tInteger readFrom: fStream. ]\r\t\t\t\t\t )\t ].\r    fStream close. matr inspect.\r        "Обчислення максимальних елементів"\r    mLines:=matr collect: [ :r | r inject: (r at: 1) into: [ :x :y | x max: y] ].\r    mMatr:=mLines at: 1.\r    mLines do: [ :x | x > mMatr ifTrue: [ mMatr := x ] ].\r        "Побудова імені файла результатів, збереження"\r    fName at: fName size - 4 put: $_ .\r    fStream := fName asFileReference writeStream.\r    mLines do: [ :x | x printOn: fStream. fStream cr ].\r    fStream close.\r    ^mMatr .  \r\r" Поясніть код, наведений вище (кожне повідомлення!):\r\r\t| matr fStream fName n m mMatr mLines | <-- Локальні змінні\r\r\tВідкриваємо діалог вибору файлу. Якщо користувач не вибрав файл – повертаємо повідомлення:\r\t(fName := UIManager default\r\t    chooseFullFileNameMatching: nil\r\t    label: \'Виберіть файл з числовими даними\') isNil\r\t    ifTrue: [ ^\'Ви не вибрали файла\' ].\r\r\tfStream := fName asFileReference readStream. <-- Відкриваємо потік для читання файлу\r\tn := Integer readFrom: fStream. <-- Читаємо перше число з файлу – кількість рядків матриці\r\tmatr := Array new: n. <-- Створюємо масив для рядків матриці:\r\tm := Integer readFrom: fStream. <-- Читаємо друге число з файлу – кількість стовпців матриці\r\tmatr := matr collect: [:x | Array new: m]. <-- Заповнюємо кожен рядок новим масивом стовпців (масив масивів)\r\r\tПроходимо по кожному рядку:\r\t - пропускаємо порожню або заголовочну лінію\r\t - читаємо числа рядка і записуємо у відповідний рядок матриці:\r\t1 to: n do: [:i |\r\t    fStream nextLine.\r\t    matr at: i put: (\r\t        (matr at: i) collect: [:x | Integer readFrom: fStream]\r\t    )].\r\r\tfStream close. <-- Закриваємо потік після читання\r\tmatr inspect. <-- Відкриваємо інспектор для перегляду матриці\r\r\tОбчислюємо максимум у кожному рядку:\r\t - inject: використовується для проходження елементів\r\t - функція x max: y повертає більший елемент\r\tmLines := matr collect: [:r | r inject: (r at: 1) into: [:x :y | x max: y]].\r\r\tЗнаходимо загальний максимум матриці:\r\t - проходимо по максимумам рядків і оновлюємо mMatr:\r\tmMatr := mLines at: 1.\r\tmLines do: [:x | x > mMatr ifTrue: [ mMatr := x ]].\r\r\tfName at: fName size - 4 put: $_. <-- Змінюємо розширення файлу для збереження результатів\r\tfStream := fName asFileReference writeStream. <-- Відкриваємо потік для запису у файл\r\tmLines do: [:x | x printOn: fStream. fStream cr]. <-- Записуємо максимуми рядків у файл, кожен на новий рядок\r\tfStream close. <-- Закриваємо файл після запису\r\t^ mMatr. <-- Повертаємо максимальний елемент всієї матриці\r\r   Як замінити масивмасивів на екземпляр класу Matrix?:\r\tMatrix замінює масив масивів, тобто ми маємо одну структуру n × m. До елементів доступ через at: i at: j.\r\tЦе дозволяє компактно читати дані з файлу, знаходити максимуми і записувати результати, не створюючи додаткових масивів рядків:\r\t\r\t| matr fStream n m mMatr |\r\r\tВідкриваємо файл та читаємо розміри:\r\tfStream := \'file.txt\' asFileReference readStream.\r\tn := Integer readFrom: fStream.\r\tm := Integer readFrom: fStream.\r\r\tСтворюємо і заповнюємо матрицю:\r\tmatr := Matrix rows: n columns: m.\r\t1 to: n do: [:i | 1 to: m do: [:j | matr at: i at: j put: Integer readFrom: fStream]].\r\tfStream close.\r\r\tЗнаходимо загальний максимум:\r\tmMatr := (1 to: n) inject: 0 into: [:maxRow :i | maxRow max: ((1 to: m) inject: 0 into: [:maxCol :j | maxCol max: (matr at: i at: j)])].\r\t^ mMatr.\r\r======================================================\r\r ------ АДРЕСНА КНИГА\r Приклад створення і використання адресної книги, описаний у одній з лекцій. \r Пригадуєте, спочатку оголошуємо глобальну змінну, що міститиме впорядковану \r колекцію масивів з трьох рядків. Спосіб порівняння описує бінарний блок.    "\r\r    Smalltalk globals at: #AddressBook\r              put:(SortedCollection sortBlock:[:a :b | (a at:1)<=(b at:1)]).\r\r" * --- Тепер до книги можна додавати записи. "\r\r    AddressBook\r            add: #(\'Ruth\' \'Babe\' \'456 Mudville Flats\');\r            add: #(\'Smith\' \'John\' \'12/5 Park Ave\');\r            add: #(\'Jexon\' \'John\' \'5 Baverli Hills\');\r            add: #(\'Adams\' \'John\' \'1 Hell str\');\r            add: #(\'Taylor\' \'Babe\' \'2a/35 Deribas str\');\r            add: #(\'Greg\' \'Voss\' \'12345 the USA\')."<-- #(\'Greg\' \'Voss\' \'12345 the USA\')"\r\r" * --- Додайте власні записи. Видрукуйте вміст книги (код запропоновано нижче)."\r   | s w |  s := WriteStream on: String new.\r\r    AddressBook do:[:x | x do:\r        [ :y | s nextPutAll: y; tab; tab.].\r        s cr. ]. "<-- a SortedCollection(#(\'Adams\' \'John\' \'1 Hell str\') \r\t\t\t\t\t  #(\'Greg\' \'Voss\' \'12345 the USA\') #(\'Jexon\' \'John\' \'5 Baverli Hills\') \r\t\t\t\t\t  #(\'Ruth\' \'Babe\' \'456 Mudville Flats\') #(\'Smith\' \'John\' \'12/5 Park Ave\') \r\t\t\t\t\t  #(\'Taylor\' \'Babe\' \'2a/35 Deribas str\'))"\r\r\tAddressBook\r    add: #(\'Brown\' \'Alice\' \'7 Cherry Lane\');\r    add: #(\'White\' \'Bob\' \'15 Oak Street\');\r    add: #(\'Green\' \'Clara\' \'9 Pine Avenue\').\r\r\t  \r\ts := WriteStream on: String new.\r\tAddressBook do: [ :x | x do: [ :y | s nextPutAll: y; tab; tab. ] ] \r\t\r\t\r  w := Workspace openLabel: \'My Address Book\'.\r  w contents: s contents.\r\r" * ----  Наступне завдання - надрукувати список прізвищ людей з однаковими іменами. \r              Приклад демонструє різні способи перебору та перетворення колекцій."\r\r | firstNames duplicates |\r    firstNames:=Bag new.        "утворимо торбу імен"\r    AddressBook do: [ :entry | firstNames add: (entry at: 2) ]. "<-- a SortedCollection(#(\'Adams\' \'John\' \'1 Hell str\') #(\'Greg\' \'Voss\' \'12345 the USA\') \r\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t#(\'Jexon\' \'John\' \'5 Baverli Hills\') #(\'Ruth\' \'Babe\' \'456 Mudville Flats\') #(\'Smith\' \'John\' \'12/5 Park Ave\')\r\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t#(\'Taylor\' \'Babe\' \'2a/35 Deribas str\'))"\r\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r        "виберемо ті імена, які зустрічаються більше одного разу"\r    duplicates:=firstNames select:\r        [ :name | (firstNames occurrencesOf: name)>1 ]. "<-- a Bag(\'John\' \'John\' \'John\' \'Babe\' \'Babe\')"\r            "і впорядкуємо їх"\r    duplicates:=duplicates asSet asSortedCollection. "<-- a SortedCollection(\'Babe\' \'John\')"\r        "друкуємо імена та відповідні їм прізвища"\r    duplicates do: [ :first | first printOn: Transcript. Transcript show:\'==>\'.\r        AddressBook do: [ :entry | (entry at: 2)=first\r            ifTrue: [ Transcript show:\' \'. (entry at: 1) printOn: Transcript ] ].\r        Transcript cr ]. Transcript show:\' \'.\r\r" Поясніть перетворення, що відбуваються в цьому фрагменті:\r\tBag — дозволяє зберігати елементи з повтореннями.\r\tselect: — фільтрує колекцію, залишаючи тільки елементи, що задовольняють умові (тут, occurrencesOf: > 1).\r\tasSet — видаляє дублікати після фільтрації.\r\tasSortedCollection — сортує результати для зручного виводу.\r\tdo: — ітерує колекцію і виконує дію (друк у Transcript).\r\r   Запропонуйте власні варіанти використання та перетворення колекцій. \r \r  Оформіть запропоновані вище фрагменти як методи навчального класу:\r\tObject subclass: #AddressBookUtils\r    \tinstanceVariableNames: \'\'\r    \tclassVariableNames: \'\'\r    \tpoolDictionaries: \'\'\r    \tcategory: \'Training-Examples\'.\r\r"\r\r\r" ------ ДОДАВАННЯ АДРЕС\r  Можливо, додавання записів до AddressBook за допомогою явного програмування \r  виглядає не надто привабливо. Використайте з цією метою діалоги "\r\r| a b c | \ra := UIManager default request: \'Input first name\'.\rb := UIManager default request: \'Input second name\'.\rc := UIManager default request: \'Input address\'.\ra isNil | b isNil | c isNil ifFalse: [ AddressBook add: (Array with:a with:b with:c)]. "<-- #(\'Oleh\' \'Chyzhov\' \'MyAddress 23\')"\r\r" Додайте до книги декілька нових записів, знову видрукуйте її. "\r"Через це в книзі так багато записів:"\r[\r    | a b c |\r    a := UIManager default request: \'Input first name\'.\r    a isNil ifTrue: [ ^self ].  "Cancel завершує цикл"\r\r    b := UIManager default request: \'Input second name\'.\r    b isNil ifTrue: [ ^self ].\r\r    c := UIManager default request: \'Input address\'.\r    c isNil ifTrue: [ ^self ].\r\r    AddressBook add: (Array with: a with: b with: c).\r] repeat.\r\r\ts := WriteStream on: String new.\r\tAddressBook do: [ :x | x do: [ :y | s nextPutAll: y; tab; tab. ] ]\r\r" Поміркуйте, як зробити зручнішим звертання до діалогу додавання адрес та друку адресної книги. "\r\r" Що станеться, якщо виконати наступний код? Випробуйте. "\r    Smalltalk globals removeKey:#AddressBook. "<-- з глобального словника Smalltalk globals буде видалено ключ #AddressBook і, відповідно, саму твою колекцію (адресну книгу)."\r\r "------ ПЕРЕТВОРЕННЯ (ПЕРЕВТІЛЕННЯ) ОБ\'ЄКТІВ\r   Виконайте за допомогою Do It. "\r\r | a b c|\r    a := OrderedCollection new.\r    b := Cylinder new.\r    c := Array with: a with: b with: b.\r    Transcript show: \'Old Array is = \'.\r    c do: [ :x | Transcript show: \'     \'. x printOn: Transcript ].\r    Transcript cr.\r    a become: b.\r    Transcript show: \'New Array is = \'.\r    c do: [ :x | Transcript show: \'     \'. x printOn: Transcript ].\r    Transcript cr; show:\' \'. "<-- Unknown variable"\r\r" Поясніть дію методу become:. Чи можна замість нього користуватися звичайним присвоєнням? Наведіть власні приклади. "\r\r" Він міняє всі посилання на два об’єкти місцями у всій системі.  \r  Не можна замість become використовувати звичайне присвоєння, адже такого ефекту не можливо буде досягнути."\r\r\r\r\r\r\r\r'
}OmEntry {
	#tags : {
		#timestamp : DateAndTime [ '2025-10-04T22:24:40.905+03:00' ],
		#self : OmReference [ '14' ]
	},
	#content : '"--------------------------------------------------------------------------------------\r*                      ЛАБОРОТОРНА РОБОТА 3\r*                 Тема: КЛАСИ ТА МЕТОДИ. КОЛЕКЦІЇ\r*\r*  Завдання до лабораторної роботи:\r*     1. Виконайте наведені нижче приклади, збережіть і поясніть отримані результати.\r*     2. Випробуйте різноманітні способи додавання нових класів до системи.\r*     3. Навчіться доповнювати функціональність класів.\r*     4. Випробуйте методи опрацювання колекцій.\r*\r\r    Виконайте за допомогою <Print it> \r\r ------ ПРИНАЛЕЖНІСТЬ КЛАСОВІ, ІЄРАРХІЯ КЛАСІВ\r"\r    #(Francesca Jackie Marisa Bree) class. "Array"\r    (#(Francesca Jackie Marisa Bree) at:2) class. "ByteSymbol"\r    \'Rakesh Vijay Charles Daniel Tyler\' class. "ByteString"\r    (\'Rakesh Vijay Charles Daniel Tyler\' at:2) class. "Character (a)"\r    World class . "WorldMorph"\r    Magnitude class. "Magnitude class"\r    Magnitude class class. "Metaclass"\r    nil class. "UndefinedObject"\r    5 species. "SmallInteger"\r    123456789000 species. "SmallInteger"\r    #aName species. "ByteString"\r " Яка різниця між повідомленнями class i species ? \r\r    Випробуйте різні способи відкривання браузера класів: за допомогою меню чи програмно \r     Виконайте за допомогою <Do it>\r"\r    ClyFullBrowserMorph open. \r    ClyFullBrowserMorph openOnClass: Date. \r    ClyFullBrowserMorph openOnClass: VolumeShape  selector:  #volume. \r\r" ------ МЕТОДИ КЛАСУ, КОНСТРУКТОРИ\r  Виконайте за допомогою <Print It>. Запропонуйте власні приклади. "\r\r    Array new: 10. "#(nil nil nil nil nil nil nil nil nil nil)"        \r    OrderedCollection  new. "an OrderedCollection()"\r    Date today. "29 September 2025"\r    Time now. "10:28:52.422 am"\r    UIManager default  request:\'How are you?\' initialAnswer:\'I\'\'m fine!\'. "\'I\'\'m fine!\'"\r    Integer readFrom: \'2013  1925\'. "2013"\r    Integer primesUpTo: 100. "#(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97)"\r    Rectangle origin:0@0 corner:200@100. "(0@0) corner: (200@100)"\r    Date nameOfMonth:12. "#December"\r    Date dayOfWeek: #Friday. "6"\r    Date orthodoxEasterDateFor: 2022. "24 April 2022"\r\r\r   \r"Інсталюйте вказані нижче МЕТОДИ КЛАСУ Date:\r  перенесіть копію тексту визначення методу з робочого вікна в браузер класів.\r\r""!Date class methodsFor: \'specific inquiries\' stamp: \'CamilloBruni 8/22/2013 19:47\'!""\r\rorthodoxEasterDateFor: year\r ""  compute the easter date according to the rules of the orthodox calendar.\r    source:       http://www.smart.net/~mmontes/ortheast.html   ""\r     | r1 r2 r3 r4 ra rb r5 rc date |\r\r    r1 := year \\\\ 19.\r    r2 := year \\\\ 4.\r    r3 := year \\\\ 7.\r    ra := 19*r1 + 16.\r    r4 := ra \\\\ 30.\r    rb := r2 + r2 + (4*r3) + (6*r4).\r    r5 := rb \\\\ 7.\r    rc := r4 + r5.\r    date := self year: year month: 4 day: 3.\r    ^date addDays: rc.\r""--------------------------------------------------------------------------------------""\r""!Date class methodsFor: \'specific inquiries\' stamp: \'CamilloBruni 8/22/2013 19:48\'!""\r\reasterDateFor: year\r ""  compute the easter date.\r    source: Physikalisch-Technische Bundesanstalt Braunschweig.\r    Lichtenberg, H.: Zur Interpretation der Gaussschen Osterformel und ihrer Ausnahmeregeln, Historia Mathematica 24 (1997), pp. 441-444\r      http://www.ptb.de/de/org/4/44/441/oste.htm  ""\r\r  | k m s a d r og sz oe day |\r\r  k := year // 100.\r  m := 15 + (3*k + 3//4) - (8*k + 13//25).\r   s := 2 - (3*k + 3// 4).\r  a := year \\\\ 19.\r  d := 19*a + m \\\\ 30.\r  r := d//29 + ((d//28) - (d//29)* (a// 11)).\r\r  og := 21 + d - r.\r  sz := 7 - (year//4 + year + s\\\\7).\r  oe := 7 - (og - sz\\\\7).\r  day := og + oe.\r  ^day <= 31\r    ifTrue: [ Date year: year month: 3 day: day ]\r    ifFalse: [ Date year: year month: 4 day: day - 31 ].\r"\r\r"Знайдіть роки, коли святкування припадають на один день."\r\ryearsWithMatchingEasterFrom: startYear to: endYear\r\r    | matchingYears orthodoxDate catholicDate |\r    matchingYears := OrderedCollection new.\r    (startYear to: endYear) do: [:year |\r        orthodoxDate := self orthodoxEasterDateFor: year.\r        catholicDate := self easterDateFor: year.\r        (orthodoxDate = catholicDate) ifTrue: [\r            matchingYears add: year\r        ].\r    ].\r    ^matchingYears asArray\r\rDate yearsWithMatchingEasterFrom: 2000 to: 2050. "#(2001 2004 2007 2010 2011 2014 2017 2025 2028 2031 2034 2037 2038 2041 2045 2048)"\r\r" ------ РЕКУРСІЯ\r  Додайте до класу Integer і випробуйте різні методи обчислення чисел  Фібоначчі.\r  Запропонуйте власні. Порівняйте їхню ефективність.      \r  Перед випробуванням fibonacci ЗБЕРЕЖІТЬ ІМІДЖ СИСТЕМИ! Він може зайняти Ваш комп на тиждень.  "\r\r3 fibStart: 1 with: 10  "<-- 12"\r4 fibo "<-- 5"\r12 fibonacci "<-- 233"\r\r\r"\r==============\rВласні методи:\r==============\r\r- Метод 1:\rInteger >> factorial\r    ""Обчислення факторіалу числа""\r    ^ self <= 1 ifTrue: [1] ifFalse: [self * (self - 1) factorial].\r\r- Метод 2:\rInteger >> sumTo\r    ""Сума всіх чисел від 1 до self""\r    | sum i |\r    sum := 0.\r    1 to: self do: [:i | sum := sum + i].\r    ^ sum.\r"\r\r"\rПояснення: <fibStart:with:>\rРекурсивний метод, який обчислює n-те число Фібоначчі, використовуючи два акумулятори: n1 (попереднє) і n2 (пред-попереднє).\rРекурсія: (self - 1) fibStart: n1+n2 with: n1 → наступний крок отримує нове попереднє число як суму двох попередніх.\r\rДуже швидкий для будь-якого n, навіть великого. Не обчислює одні й ті ж значення повторно → O(n). \rПам’яті потрібно лише для стеку рекурсії (глибина n).\r\rПояснення: <fibo>\rПроста обгортка над <fibStart:with:.>\r\rПовністю така ж, як у fibStart:with:. Зручно викликати без ручного передавання початкових чисел.\r\rПояснення: <fibonacci>\rКласична рекурсія: F(n) = F(n-1) + F(n-2).\r\rДуже повільний для великих n. Обчислює одні й ті ж значення багато разів → експоненційна складність O(2ⁿ). \rМоже сильно навантажити процесор і стек викликів.\r"\r\r"------------------------------------------------------------------------------------\r ------ СТВОРЕННЯ, ОПРАЦЮВАННЯ КОЛЕКЦІЙ\r  У текстовому файлі записано інформацію про матрицю цілих чисел: розміри\r  матриці в першому рядку файла, у всіх наступних рядках - рядки матриці.}\r  Прочитати матрицю, знайти максимальні елементи кожного рядка і зберегти\r  їх у файлі. Надрукувати максимальний елемент цілої матриці."\r\r"Наведений нижче код можна виконати безпосередньо в робочому вікні,\r проте,  доцільно зробити його методом власного навчального класу."\r\r| matr fStream fName n m mMatr mLines |\r        "Вибір файла за допомогою діалогу"\r    (fName:=UIManager default\r\t\t\tchooseFullFileNameMatching: nil \r\t\t\tlabel: \'Виберіть файл з числовими даними\' ) isNil\r        ifTrue: [ ^\'Ви не вибрали файла\' ]. \r        fStream := fName asFileReference readStream.\r\t        "Введення даних"\r \t    n := Integer readFrom: fStream.  \r\t    matr := Array new: n.\r\t    m := Integer readFrom: fStream.\r\t    matr := matr collect: [ :x | Array new: m ]. \r\t    1 to: n do: [ :i |  fStream nextLine.\r \t\t     matr at: i put: (\r\t\t\t\t (matr at: i) collect: [ :x |  \r\t\t\t\t\t\tInteger readFrom: fStream. ]\r\t\t\t\t\t )\t ].\r    fStream close. matr inspect.\r        "Обчислення максимальних елементів"\r    mLines:=matr collect: [ :r | r inject: (r at: 1) into: [ :x :y | x max: y] ].\r    mMatr:=mLines at: 1.\r    mLines do: [ :x | x > mMatr ifTrue: [ mMatr := x ] ].\r        "Побудова імені файла результатів, збереження"\r    fName at: fName size - 4 put: $_ .\r    fStream := fName asFileReference writeStream.\r    mLines do: [ :x | x printOn: fStream. fStream cr ].\r    fStream close.\r    ^mMatr .  \r\r" Поясніть код, наведений вище (кожне повідомлення!):\r\r\t| matr fStream fName n m mMatr mLines | <-- Локальні змінні\r\r\tВідкриваємо діалог вибору файлу. Якщо користувач не вибрав файл – повертаємо повідомлення:\r\t(fName := UIManager default\r\t    chooseFullFileNameMatching: nil\r\t    label: \'Виберіть файл з числовими даними\') isNil\r\t    ifTrue: [ ^\'Ви не вибрали файла\' ].\r\r\tfStream := fName asFileReference readStream. <-- Відкриваємо потік для читання файлу\r\tn := Integer readFrom: fStream. <-- Читаємо перше число з файлу – кількість рядків матриці\r\tmatr := Array new: n. <-- Створюємо масив для рядків матриці:\r\tm := Integer readFrom: fStream. <-- Читаємо друге число з файлу – кількість стовпців матриці\r\tmatr := matr collect: [:x | Array new: m]. <-- Заповнюємо кожен рядок новим масивом стовпців (масив масивів)\r\r\tПроходимо по кожному рядку:\r\t - пропускаємо порожню або заголовочну лінію\r\t - читаємо числа рядка і записуємо у відповідний рядок матриці:\r\t1 to: n do: [:i |\r\t    fStream nextLine.\r\t    matr at: i put: (\r\t        (matr at: i) collect: [:x | Integer readFrom: fStream]\r\t    )].\r\r\tfStream close. <-- Закриваємо потік після читання\r\tmatr inspect. <-- Відкриваємо інспектор для перегляду матриці\r\r\tОбчислюємо максимум у кожному рядку:\r\t - inject: використовується для проходження елементів\r\t - функція x max: y повертає більший елемент\r\tmLines := matr collect: [:r | r inject: (r at: 1) into: [:x :y | x max: y]].\r\r\tЗнаходимо загальний максимум матриці:\r\t - проходимо по максимумам рядків і оновлюємо mMatr:\r\tmMatr := mLines at: 1.\r\tmLines do: [:x | x > mMatr ifTrue: [ mMatr := x ]].\r\r\tfName at: fName size - 4 put: $_. <-- Змінюємо розширення файлу для збереження результатів\r\tfStream := fName asFileReference writeStream. <-- Відкриваємо потік для запису у файл\r\tmLines do: [:x | x printOn: fStream. fStream cr]. <-- Записуємо максимуми рядків у файл, кожен на новий рядок\r\tfStream close. <-- Закриваємо файл після запису\r\t^ mMatr. <-- Повертаємо максимальний елемент всієї матриці\r\r   Як замінити масивмасивів на екземпляр класу Matrix?:\r\tMatrix замінює масив масивів, тобто ми маємо одну структуру n × m. До елементів доступ через at: i at: j.\r\tЦе дозволяє компактно читати дані з файлу, знаходити максимуми і записувати результати, не створюючи додаткових масивів рядків:\r\t\r\t| matr fStream n m mMatr |\r\r\tВідкриваємо файл та читаємо розміри:\r\tfStream := \'file.txt\' asFileReference readStream.\r\tn := Integer readFrom: fStream.\r\tm := Integer readFrom: fStream.\r\r\tСтворюємо і заповнюємо матрицю:\r\tmatr := Matrix rows: n columns: m.\r\t1 to: n do: [:i | 1 to: m do: [:j | matr at: i at: j put: Integer readFrom: fStream]].\r\tfStream close.\r\r\tЗнаходимо загальний максимум:\r\tmMatr := (1 to: n) inject: 0 into: [:maxRow :i | maxRow max: ((1 to: m) inject: 0 into: [:maxCol :j | maxCol max: (matr at: i at: j)])].\r\t^ mMatr.\r\r======================================================\r\r ------ АДРЕСНА КНИГА\r Приклад створення і використання адресної книги, описаний у одній з лекцій. \r Пригадуєте, спочатку оголошуємо глобальну змінну, що міститиме впорядковану \r колекцію масивів з трьох рядків. Спосіб порівняння описує бінарний блок.    "\r\r    Smalltalk globals at: #AddressBook\r              put:(SortedCollection sortBlock:[:a :b | (a at:1)<=(b at:1)]).\r\r" * --- Тепер до книги можна додавати записи. "\r\r    AddressBook\r            add: #(\'Ruth\' \'Babe\' \'456 Mudville Flats\');\r            add: #(\'Smith\' \'John\' \'12/5 Park Ave\');\r            add: #(\'Jexon\' \'John\' \'5 Baverli Hills\');\r            add: #(\'Adams\' \'John\' \'1 Hell str\');\r            add: #(\'Taylor\' \'Babe\' \'2a/35 Deribas str\');\r            add: #(\'Greg\' \'Voss\' \'12345 the USA\')."<-- #(\'Greg\' \'Voss\' \'12345 the USA\')"\r\r" * --- Додайте власні записи. Видрукуйте вміст книги (код запропоновано нижче)."\r   | s w |  s := WriteStream on: String new.\r\r    AddressBook do:[:x | x do:\r        [ :y | s nextPutAll: y; tab; tab.].\r        s cr. ]. \r\tAddressBook\r    add: #(\'Brown\' \'Alice\' \'7 Cherry Lane\');\r    add: #(\'White\' \'Bob\' \'15 Oak Street\');\r    add: #(\'Green\' \'Clara\' \'9 Pine Avenue\').\r\r\t  \r\ts := WriteStream on: String new.\r\tAddressBook do: [ :x | x do: [ :y | s nextPutAll: y; tab; tab. ] ] \r\t\r\t\r  w := Workspace openLabel: \'My Address Book\'.\r  w contents: s contents.\r\r" * ----  Наступне завдання - надрукувати список прізвищ людей з однаковими іменами. \r              Приклад демонструє різні способи перебору та перетворення колекцій."\r\r | firstNames duplicates |\r    firstNames:=Bag new.        "утворимо торбу імен"\r    AddressBook do: [ :entry | firstNames add: (entry at: 2) ]. "<-- a SortedCollection(#(\'Adams\' \'John\' \'1 Hell str\') #(\'Greg\' \'Voss\' \'12345 the USA\') \r\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t#(\'Jexon\' \'John\' \'5 Baverli Hills\') #(\'Ruth\' \'Babe\' \'456 Mudville Flats\') #(\'Smith\' \'John\' \'12/5 Park Ave\')\r\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t#(\'Taylor\' \'Babe\' \'2a/35 Deribas str\'))"\r\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r        "виберемо ті імена, які зустрічаються більше одного разу"\r    duplicates:=firstNames select:\r        [ :name | (firstNames occurrencesOf: name)>1 ]. "<-- a Bag(\'John\' \'John\' \'John\' \'Babe\' \'Babe\')"\r            "і впорядкуємо їх"\r    duplicates:=duplicates asSet asSortedCollection. "<-- a SortedCollection(\'Babe\' \'John\')"\r        "друкуємо імена та відповідні їм прізвища"\r    duplicates do: [ :first | first printOn: Transcript. Transcript show:\'==>\'.\r        AddressBook do: [ :entry | (entry at: 2)=first\r            ifTrue: [ Transcript show:\' \'. (entry at: 1) printOn: Transcript ] ].\r        Transcript cr ]. Transcript show:\' \'.\r\r" Поясніть перетворення, що відбуваються в цьому фрагменті:\r\tBag — дозволяє зберігати елементи з повтореннями.\r\tselect: — фільтрує колекцію, залишаючи тільки елементи, що задовольняють умові (тут, occurrencesOf: > 1).\r\tasSet — видаляє дублікати після фільтрації.\r\tasSortedCollection — сортує результати для зручного виводу.\r\tdo: — ітерує колекцію і виконує дію (друк у Transcript).\r\r   Запропонуйте власні варіанти використання та перетворення колекцій. \r \r  Оформіть запропоновані вище фрагменти як методи навчального класу:\r\tObject subclass: #AddressBookUtils\r    \tinstanceVariableNames: \'\'\r    \tclassVariableNames: \'\'\r    \tpoolDictionaries: \'\'\r    \tcategory: \'Training-Examples\'.\r\r"\r\r\r" ------ ДОДАВАННЯ АДРЕС\r  Можливо, додавання записів до AddressBook за допомогою явного програмування \r  виглядає не надто привабливо. Використайте з цією метою діалоги "\r\r| a b c | \ra := UIManager default request: \'Input first name\'.\rb := UIManager default request: \'Input second name\'.\rc := UIManager default request: \'Input address\'.\ra isNil | b isNil | c isNil ifFalse: [ AddressBook add: (Array with:a with:b with:c)]. "<-- #(\'Oleh\' \'Chyzhov\' \'MyAddress 23\')"\r\r" Додайте до книги декілька нових записів, знову видрукуйте її. "\r"Через це в книзі так багато записів:"\r[\r    | a b c |\r    a := UIManager default request: \'Input first name\'.\r    a isNil ifTrue: [ ^self ].  "Cancel завершує цикл"\r\r    b := UIManager default request: \'Input second name\'.\r    b isNil ifTrue: [ ^self ].\r\r    c := UIManager default request: \'Input address\'.\r    c isNil ifTrue: [ ^self ].\r\r    AddressBook add: (Array with: a with: b with: c).\r] repeat.\r\r\ts := WriteStream on: String new.\r\tAddressBook do: [ :x | x do: [ :y | s nextPutAll: y; tab; tab. ] ]\r\r" Поміркуйте, як зробити зручнішим звертання до діалогу додавання адрес та друку адресної книги. "\r\r" Що станеться, якщо виконати наступний код? Випробуйте. "\r    Smalltalk globals removeKey:#AddressBook. "<-- з глобального словника Smalltalk globals буде видалено ключ #AddressBook і, відповідно, саму твою колекцію (адресну книгу)."\r\r "------ ПЕРЕТВОРЕННЯ (ПЕРЕВТІЛЕННЯ) ОБ\'ЄКТІВ\r   Виконайте за допомогою Do It. "\r\r | a b c|\r    a := OrderedCollection new.\r    b := Cylinder new.\r    c := Array with: a with: b with: b.\r    Transcript show: \'Old Array is = \'.\r    c do: [ :x | Transcript show: \'     \'. x printOn: Transcript ].\r    Transcript cr.\r    a become: b.\r    Transcript show: \'New Array is = \'.\r    c do: [ :x | Transcript show: \'     \'. x printOn: Transcript ].\r    Transcript cr; show:\' \'. "<-- Unknown variable"\r\r" Поясніть дію методу become:. Чи можна замість нього користуватися звичайним присвоєнням? Наведіть власні приклади. "\r\r" Він міняє всі посилання на два об’єкти місцями у всій системі.  \r  Не можна замість become використовувати звичайне присвоєння, адже такого ефекту не можливо буде досягнути."\r\r\r\r\r\r\r\r'
}OmEntry {
	#tags : {
		#timestamp : DateAndTime [ '2025-10-04T22:25:52.379+03:00' ],
		#self : OmReference [ '15' ]
	},
	#content : '"--------------------------------------------------------------------------------------\r*                      ЛАБОРОТОРНА РОБОТА 3\r*                 Тема: КЛАСИ ТА МЕТОДИ. КОЛЕКЦІЇ\r*\r*  Завдання до лабораторної роботи:\r*     1. Виконайте наведені нижче приклади, збережіть і поясніть отримані результати.\r*     2. Випробуйте різноманітні способи додавання нових класів до системи.\r*     3. Навчіться доповнювати функціональність класів.\r*     4. Випробуйте методи опрацювання колекцій.\r*\r\r    Виконайте за допомогою <Print it> \r\r ------ ПРИНАЛЕЖНІСТЬ КЛАСОВІ, ІЄРАРХІЯ КЛАСІВ\r"\r    #(Francesca Jackie Marisa Bree) class. "Array"\r    (#(Francesca Jackie Marisa Bree) at:2) class. "ByteSymbol"\r    \'Rakesh Vijay Charles Daniel Tyler\' class. "ByteString"\r    (\'Rakesh Vijay Charles Daniel Tyler\' at:2) class. "Character (a)"\r    World class . "WorldMorph"\r    Magnitude class. "Magnitude class"\r    Magnitude class class. "Metaclass"\r    nil class. "UndefinedObject"\r    5 species. "SmallInteger"\r    123456789000 species. "SmallInteger"\r    #aName species. "ByteString"\r " Яка різниця між повідомленнями class i species ? \r\r    Випробуйте різні способи відкривання браузера класів: за допомогою меню чи програмно \r     Виконайте за допомогою <Do it>\r"\r    ClyFullBrowserMorph open. \r    ClyFullBrowserMorph openOnClass: Date. \r    ClyFullBrowserMorph openOnClass: VolumeShape  selector:  #volume. \r\r" ------ МЕТОДИ КЛАСУ, КОНСТРУКТОРИ\r  Виконайте за допомогою <Print It>. Запропонуйте власні приклади. "\r\r    Array new: 10. "#(nil nil nil nil nil nil nil nil nil nil)"        \r    OrderedCollection  new. "an OrderedCollection()"\r    Date today. "29 September 2025"\r    Time now. "10:28:52.422 am"\r    UIManager default  request:\'How are you?\' initialAnswer:\'I\'\'m fine!\'. "\'I\'\'m fine!\'"\r    Integer readFrom: \'2013  1925\'. "2013"\r    Integer primesUpTo: 100. "#(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97)"\r    Rectangle origin:0@0 corner:200@100. "(0@0) corner: (200@100)"\r    Date nameOfMonth:12. "#December"\r    Date dayOfWeek: #Friday. "6"\r    Date orthodoxEasterDateFor: 2022. "24 April 2022"\r\r\r   \r"Інсталюйте вказані нижче МЕТОДИ КЛАСУ Date:\r  перенесіть копію тексту визначення методу з робочого вікна в браузер класів.\r\r""!Date class methodsFor: \'specific inquiries\' stamp: \'CamilloBruni 8/22/2013 19:47\'!""\r\rorthodoxEasterDateFor: year\r ""  compute the easter date according to the rules of the orthodox calendar.\r    source:       http://www.smart.net/~mmontes/ortheast.html   ""\r     | r1 r2 r3 r4 ra rb r5 rc date |\r\r    r1 := year \\\\ 19.\r    r2 := year \\\\ 4.\r    r3 := year \\\\ 7.\r    ra := 19*r1 + 16.\r    r4 := ra \\\\ 30.\r    rb := r2 + r2 + (4*r3) + (6*r4).\r    r5 := rb \\\\ 7.\r    rc := r4 + r5.\r    date := self year: year month: 4 day: 3.\r    ^date addDays: rc.\r""--------------------------------------------------------------------------------------""\r""!Date class methodsFor: \'specific inquiries\' stamp: \'CamilloBruni 8/22/2013 19:48\'!""\r\reasterDateFor: year\r ""  compute the easter date.\r    source: Physikalisch-Technische Bundesanstalt Braunschweig.\r    Lichtenberg, H.: Zur Interpretation der Gaussschen Osterformel und ihrer Ausnahmeregeln, Historia Mathematica 24 (1997), pp. 441-444\r      http://www.ptb.de/de/org/4/44/441/oste.htm  ""\r\r  | k m s a d r og sz oe day |\r\r  k := year // 100.\r  m := 15 + (3*k + 3//4) - (8*k + 13//25).\r   s := 2 - (3*k + 3// 4).\r  a := year \\\\ 19.\r  d := 19*a + m \\\\ 30.\r  r := d//29 + ((d//28) - (d//29)* (a// 11)).\r\r  og := 21 + d - r.\r  sz := 7 - (year//4 + year + s\\\\7).\r  oe := 7 - (og - sz\\\\7).\r  day := og + oe.\r  ^day <= 31\r    ifTrue: [ Date year: year month: 3 day: day ]\r    ifFalse: [ Date year: year month: 4 day: day - 31 ].\r"\r\r"Знайдіть роки, коли святкування припадають на один день."\r\ryearsWithMatchingEasterFrom: startYear to: endYear\r\r    | matchingYears orthodoxDate catholicDate |\r    matchingYears := OrderedCollection new.\r    (startYear to: endYear) do: [:year |\r        orthodoxDate := self orthodoxEasterDateFor: year.\r        catholicDate := self easterDateFor: year.\r        (orthodoxDate = catholicDate) ifTrue: [\r            matchingYears add: year\r        ].\r    ].\r    ^matchingYears asArray\r\rDate yearsWithMatchingEasterFrom: 2000 to: 2050. "#(2001 2004 2007 2010 2011 2014 2017 2025 2028 2031 2034 2037 2038 2041 2045 2048)"\r\r" ------ РЕКУРСІЯ\r  Додайте до класу Integer і випробуйте різні методи обчислення чисел  Фібоначчі.\r  Запропонуйте власні. Порівняйте їхню ефективність.      \r  Перед випробуванням fibonacci ЗБЕРЕЖІТЬ ІМІДЖ СИСТЕМИ! Він може зайняти Ваш комп на тиждень.  "\r\r3 fibStart: 1 with: 10  "<-- 12"\r4 fibo "<-- 5"\r12 fibonacci "<-- 233"\r\r\r"\r==============\rВласні методи:\r==============\r\r- Метод 1:\rInteger >> factorial\r    ""Обчислення факторіалу числа""\r    ^ self <= 1 ifTrue: [1] ifFalse: [self * (self - 1) factorial].\r\r- Метод 2:\rInteger >> sumTo\r    ""Сума всіх чисел від 1 до self""\r    | sum i |\r    sum := 0.\r    1 to: self do: [:i | sum := sum + i].\r    ^ sum.\r"\r\r"\rПояснення: <fibStart:with:>\rРекурсивний метод, який обчислює n-те число Фібоначчі, використовуючи два акумулятори: n1 (попереднє) і n2 (пред-попереднє).\rРекурсія: (self - 1) fibStart: n1+n2 with: n1 → наступний крок отримує нове попереднє число як суму двох попередніх.\r\rДуже швидкий для будь-якого n, навіть великого. Не обчислює одні й ті ж значення повторно → O(n). \rПам’яті потрібно лише для стеку рекурсії (глибина n).\r\rПояснення: <fibo>\rПроста обгортка над <fibStart:with:.>\r\rПовністю така ж, як у fibStart:with:. Зручно викликати без ручного передавання початкових чисел.\r\rПояснення: <fibonacci>\rКласична рекурсія: F(n) = F(n-1) + F(n-2).\r\rДуже повільний для великих n. Обчислює одні й ті ж значення багато разів → експоненційна складність O(2ⁿ). \rМоже сильно навантажити процесор і стек викликів.\r"\r\r"------------------------------------------------------------------------------------\r ------ СТВОРЕННЯ, ОПРАЦЮВАННЯ КОЛЕКЦІЙ\r  У текстовому файлі записано інформацію про матрицю цілих чисел: розміри\r  матриці в першому рядку файла, у всіх наступних рядках - рядки матриці.}\r  Прочитати матрицю, знайти максимальні елементи кожного рядка і зберегти\r  їх у файлі. Надрукувати максимальний елемент цілої матриці."\r\r"Наведений нижче код можна виконати безпосередньо в робочому вікні,\r проте,  доцільно зробити його методом власного навчального класу."\r\r| matr fStream fName n m mMatr mLines |\r        "Вибір файла за допомогою діалогу"\r    (fName:=UIManager default\r\t\t\tchooseFullFileNameMatching: nil \r\t\t\tlabel: \'Виберіть файл з числовими даними\' ) isNil\r        ifTrue: [ ^\'Ви не вибрали файла\' ]. \r        fStream := fName asFileReference readStream.\r\t        "Введення даних"\r \t    n := Integer readFrom: fStream.  \r\t    matr := Array new: n.\r\t    m := Integer readFrom: fStream.\r\t    matr := matr collect: [ :x | Array new: m ]. \r\t    1 to: n do: [ :i |  fStream nextLine.\r \t\t     matr at: i put: (\r\t\t\t\t (matr at: i) collect: [ :x |  \r\t\t\t\t\t\tInteger readFrom: fStream. ]\r\t\t\t\t\t )\t ].\r    fStream close. matr inspect.\r        "Обчислення максимальних елементів"\r    mLines:=matr collect: [ :r | r inject: (r at: 1) into: [ :x :y | x max: y] ].\r    mMatr:=mLines at: 1.\r    mLines do: [ :x | x > mMatr ifTrue: [ mMatr := x ] ].\r        "Побудова імені файла результатів, збереження"\r    fName at: fName size - 4 put: $_ .\r    fStream := fName asFileReference writeStream.\r    mLines do: [ :x | x printOn: fStream. fStream cr ].\r    fStream close.\r    ^mMatr .  \r\r" Поясніть код, наведений вище (кожне повідомлення!):\r\r\t| matr fStream fName n m mMatr mLines | <-- Локальні змінні\r\r\tВідкриваємо діалог вибору файлу. Якщо користувач не вибрав файл – повертаємо повідомлення:\r\t(fName := UIManager default\r\t    chooseFullFileNameMatching: nil\r\t    label: \'Виберіть файл з числовими даними\') isNil\r\t    ifTrue: [ ^\'Ви не вибрали файла\' ].\r\r\tfStream := fName asFileReference readStream. <-- Відкриваємо потік для читання файлу\r\tn := Integer readFrom: fStream. <-- Читаємо перше число з файлу – кількість рядків матриці\r\tmatr := Array new: n. <-- Створюємо масив для рядків матриці:\r\tm := Integer readFrom: fStream. <-- Читаємо друге число з файлу – кількість стовпців матриці\r\tmatr := matr collect: [:x | Array new: m]. <-- Заповнюємо кожен рядок новим масивом стовпців (масив масивів)\r\r\tПроходимо по кожному рядку:\r\t - пропускаємо порожню або заголовочну лінію\r\t - читаємо числа рядка і записуємо у відповідний рядок матриці:\r\t1 to: n do: [:i |\r\t    fStream nextLine.\r\t    matr at: i put: (\r\t        (matr at: i) collect: [:x | Integer readFrom: fStream]\r\t    )].\r\r\tfStream close. <-- Закриваємо потік після читання\r\tmatr inspect. <-- Відкриваємо інспектор для перегляду матриці\r\r\tОбчислюємо максимум у кожному рядку:\r\t - inject: використовується для проходження елементів\r\t - функція x max: y повертає більший елемент\r\tmLines := matr collect: [:r | r inject: (r at: 1) into: [:x :y | x max: y]].\r\r\tЗнаходимо загальний максимум матриці:\r\t - проходимо по максимумам рядків і оновлюємо mMatr:\r\tmMatr := mLines at: 1.\r\tmLines do: [:x | x > mMatr ifTrue: [ mMatr := x ]].\r\r\tfName at: fName size - 4 put: $_. <-- Змінюємо розширення файлу для збереження результатів\r\tfStream := fName asFileReference writeStream. <-- Відкриваємо потік для запису у файл\r\tmLines do: [:x | x printOn: fStream. fStream cr]. <-- Записуємо максимуми рядків у файл, кожен на новий рядок\r\tfStream close. <-- Закриваємо файл після запису\r\t^ mMatr. <-- Повертаємо максимальний елемент всієї матриці\r\r   Як замінити масивмасивів на екземпляр класу Matrix?:\r\tMatrix замінює масив масивів, тобто ми маємо одну структуру n × m. До елементів доступ через at: i at: j.\r\tЦе дозволяє компактно читати дані з файлу, знаходити максимуми і записувати результати, не створюючи додаткових масивів рядків:\r\t\r\t| matr fStream n m mMatr |\r\r\tВідкриваємо файл та читаємо розміри:\r\tfStream := \'file.txt\' asFileReference readStream.\r\tn := Integer readFrom: fStream.\r\tm := Integer readFrom: fStream.\r\r\tСтворюємо і заповнюємо матрицю:\r\tmatr := Matrix rows: n columns: m.\r\t1 to: n do: [:i | 1 to: m do: [:j | matr at: i at: j put: Integer readFrom: fStream]].\r\tfStream close.\r\r\tЗнаходимо загальний максимум:\r\tmMatr := (1 to: n) inject: 0 into: [:maxRow :i | maxRow max: ((1 to: m) inject: 0 into: [:maxCol :j | maxCol max: (matr at: i at: j)])].\r\t^ mMatr.\r\r======================================================\r\r ------ АДРЕСНА КНИГА\r Приклад створення і використання адресної книги, описаний у одній з лекцій. \r Пригадуєте, спочатку оголошуємо глобальну змінну, що міститиме впорядковану \r колекцію масивів з трьох рядків. Спосіб порівняння описує бінарний блок.    "\r\r    Smalltalk globals at: #AddressBook\r              put:(SortedCollection sortBlock:[:a :b | (a at:1)<=(b at:1)]).\r\r" * --- Тепер до книги можна додавати записи. "\r\r    AddressBook\r            add: #(\'Ruth\' \'Babe\' \'456 Mudville Flats\');\r            add: #(\'Smith\' \'John\' \'12/5 Park Ave\');\r            add: #(\'Jexon\' \'John\' \'5 Baverli Hills\');\r            add: #(\'Adams\' \'John\' \'1 Hell str\');\r            add: #(\'Taylor\' \'Babe\' \'2a/35 Deribas str\');\r            add: #(\'Greg\' \'Voss\' \'12345 the USA\')."<-- #(\'Greg\' \'Voss\' \'12345 the USA\')"\r\r" * --- Додайте власні записи. Видрукуйте вміст книги (код запропоновано нижче)."\r   | s w |  s := WriteStream on: String new.\r\r    AddressBook do:[:x | x do:\r        [ :y | s nextPutAll: y; tab; tab.].\r        s cr. ]. \r\tAddressBook\r    add: #(\'Brown\' \'Alice\' \'7 Cherry Lane\');\r    add: #(\'White\' \'Bob\' \'15 Oak Street\');\r    add: #(\'Green\' \'Clara\' \'9 Pine Avenue\').\r\r\t  \r\ts := WriteStream on: String new.\r\tAddressBook do: [ :x | x do: [ :y | s nextPutAll: y; tab; tab. ] ] \r\t\r\t\r  w := Workspace openLabel: \'My Address Book\'.\r  w contents: s contents.\r\r" * ----  Наступне завдання - надрукувати список прізвищ людей з однаковими іменами. \r              Приклад демонструє різні способи перебору та перетворення колекцій."\r\r | firstNames duplicates |\r    firstNames:=Bag new.       \r    AddressBook do: [ :entry | firstNames add: (entry at: 2) ]. \r\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r        "виберемо ті імена, які зустрічаються більше одного разу"\r    duplicates:=firstNames select:\r        [ :name | (firstNames occurrencesOf: name)>1 ]. "<-- a Bag(\'John\' \'John\' \'John\' \'Babe\' \'Babe\')"\r            "і впорядкуємо їх"\r    duplicates:=duplicates asSet asSortedCollection. "<-- a SortedCollection(\'Babe\' \'John\')"\r        "друкуємо імена та відповідні їм прізвища"\r    duplicates do: [ :first | first printOn: Transcript. Transcript show:\'==>\'.\r        AddressBook do: [ :entry | (entry at: 2)=first\r            ifTrue: [ Transcript show:\' \'. (entry at: 1) printOn: Transcript ] ].\r        Transcript cr ]. Transcript show:\' \'.\r\r" Поясніть перетворення, що відбуваються в цьому фрагменті:\r\tBag — зберігає елементи з повтореннями.\r\tselect: — фільтрує колекцію, залишаючи тільки елементи, що задовольняють умові (тут, occurrencesOf: > 1).\r\tasSet — видаляє дублікати після фільтрації.\r\tasSortedCollection — сортує результати для зручного виводу.\r\tdo: — ітерує колекцію і виконує дію (друк у Transcript).\r\r   Запропонуйте власні варіанти використання та перетворення колекцій. \r \r  Оформіть запропоновані вище фрагменти як методи навчального класу:\r\tObject subclass: #AddressBookUtils\r    \tinstanceVariableNames: \'\'\r    \tclassVariableNames: \'\'\r    \tpoolDictionaries: \'\'\r    \tcategory: \'Training-Examples\'.\r\r"\r\r\r" ------ ДОДАВАННЯ АДРЕС\r  Можливо, додавання записів до AddressBook за допомогою явного програмування \r  виглядає не надто привабливо. Використайте з цією метою діалоги "\r\r| a b c | \ra := UIManager default request: \'Input first name\'.\rb := UIManager default request: \'Input second name\'.\rc := UIManager default request: \'Input address\'.\ra isNil | b isNil | c isNil ifFalse: [ AddressBook add: (Array with:a with:b with:c)]. "<-- #(\'Oleh\' \'Chyzhov\' \'MyAddress 23\')"\r\r" Додайте до книги декілька нових записів, знову видрукуйте її. "\r"Через це в книзі так багато записів:"\r[\r    | a b c |\r    a := UIManager default request: \'Input first name\'.\r    a isNil ifTrue: [ ^self ].  "Cancel завершує цикл"\r\r    b := UIManager default request: \'Input second name\'.\r    b isNil ifTrue: [ ^self ].\r\r    c := UIManager default request: \'Input address\'.\r    c isNil ifTrue: [ ^self ].\r\r    AddressBook add: (Array with: a with: b with: c).\r] repeat.\r\r\ts := WriteStream on: String new.\r\tAddressBook do: [ :x | x do: [ :y | s nextPutAll: y; tab; tab. ] ]\r\r" Поміркуйте, як зробити зручнішим звертання до діалогу додавання адрес та друку адресної книги. "\r\r" Що станеться, якщо виконати наступний код? Випробуйте. "\r    Smalltalk globals removeKey:#AddressBook. "<-- з глобального словника Smalltalk globals буде видалено ключ #AddressBook і, відповідно, саму твою колекцію (адресну книгу)."\r\r "------ ПЕРЕТВОРЕННЯ (ПЕРЕВТІЛЕННЯ) ОБ\'ЄКТІВ\r   Виконайте за допомогою Do It. "\r\r | a b c|\r    a := OrderedCollection new.\r    b := Cylinder new.\r    c := Array with: a with: b with: b.\r    Transcript show: \'Old Array is = \'.\r    c do: [ :x | Transcript show: \'     \'. x printOn: Transcript ].\r    Transcript cr.\r    a become: b.\r    Transcript show: \'New Array is = \'.\r    c do: [ :x | Transcript show: \'     \'. x printOn: Transcript ].\r    Transcript cr; show:\' \'. "<-- Unknown variable"\r\r" Поясніть дію методу become:. Чи можна замість нього користуватися звичайним присвоєнням? Наведіть власні приклади. "\r\r" Він міняє всі посилання на два об’єкти місцями у всій системі.  \r  Не можна замість become використовувати звичайне присвоєння, адже такого ефекту не можливо буде досягнути."\r\r\r\r\r\r\r\r'
}OmEntry {
	#tags : {
		#timestamp : DateAndTime [ '2025-10-04T22:26:43.463+03:00' ],
		#self : OmReference [ '16' ]
	},
	#content : '"--------------------------------------------------------------------------------------\r*                      ЛАБОРОТОРНА РОБОТА 3\r*                 Тема: КЛАСИ ТА МЕТОДИ. КОЛЕКЦІЇ\r*\r*  Завдання до лабораторної роботи:\r*     1. Виконайте наведені нижче приклади, збережіть і поясніть отримані результати.\r*     2. Випробуйте різноманітні способи додавання нових класів до системи.\r*     3. Навчіться доповнювати функціональність класів.\r*     4. Випробуйте методи опрацювання колекцій.\r*\r\r    Виконайте за допомогою <Print it> \r\r ------ ПРИНАЛЕЖНІСТЬ КЛАСОВІ, ІЄРАРХІЯ КЛАСІВ\r"\r    #(Francesca Jackie Marisa Bree) class. "Array"\r    (#(Francesca Jackie Marisa Bree) at:2) class. "ByteSymbol"\r    \'Rakesh Vijay Charles Daniel Tyler\' class. "ByteString"\r    (\'Rakesh Vijay Charles Daniel Tyler\' at:2) class. "Character (a)"\r    World class . "WorldMorph"\r    Magnitude class. "Magnitude class"\r    Magnitude class class. "Metaclass"\r    nil class. "UndefinedObject"\r    5 species. "SmallInteger"\r    123456789000 species. "SmallInteger"\r    #aName species. "ByteString"\r " Яка різниця між повідомленнями class i species ? \r\r    Випробуйте різні способи відкривання браузера класів: за допомогою меню чи програмно \r     Виконайте за допомогою <Do it>\r"\r    ClyFullBrowserMorph open. \r    ClyFullBrowserMorph openOnClass: Date. \r    ClyFullBrowserMorph openOnClass: VolumeShape  selector:  #volume. \r\r" ------ МЕТОДИ КЛАСУ, КОНСТРУКТОРИ\r  Виконайте за допомогою <Print It>. Запропонуйте власні приклади. "\r\r    Array new: 10. "#(nil nil nil nil nil nil nil nil nil nil)"        \r    OrderedCollection  new. "an OrderedCollection()"\r    Date today. "29 September 2025"\r    Time now. "10:28:52.422 am"\r    UIManager default  request:\'How are you?\' initialAnswer:\'I\'\'m fine!\'. "\'I\'\'m fine!\'"\r    Integer readFrom: \'2013  1925\'. "2013"\r    Integer primesUpTo: 100. "#(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97)"\r    Rectangle origin:0@0 corner:200@100. "(0@0) corner: (200@100)"\r    Date nameOfMonth:12. "#December"\r    Date dayOfWeek: #Friday. "6"\r    Date orthodoxEasterDateFor: 2022. "24 April 2022"\r\r\r   \r"Інсталюйте вказані нижче МЕТОДИ КЛАСУ Date:\r  перенесіть копію тексту визначення методу з робочого вікна в браузер класів.\r\r""!Date class methodsFor: \'specific inquiries\' stamp: \'CamilloBruni 8/22/2013 19:47\'!""\r\rorthodoxEasterDateFor: year\r ""  compute the easter date according to the rules of the orthodox calendar.\r    source:       http://www.smart.net/~mmontes/ortheast.html   ""\r     | r1 r2 r3 r4 ra rb r5 rc date |\r\r    r1 := year \\\\ 19.\r    r2 := year \\\\ 4.\r    r3 := year \\\\ 7.\r    ra := 19*r1 + 16.\r    r4 := ra \\\\ 30.\r    rb := r2 + r2 + (4*r3) + (6*r4).\r    r5 := rb \\\\ 7.\r    rc := r4 + r5.\r    date := self year: year month: 4 day: 3.\r    ^date addDays: rc.\r""--------------------------------------------------------------------------------------""\r""!Date class methodsFor: \'specific inquiries\' stamp: \'CamilloBruni 8/22/2013 19:48\'!""\r\reasterDateFor: year\r ""  compute the easter date.\r    source: Physikalisch-Technische Bundesanstalt Braunschweig.\r    Lichtenberg, H.: Zur Interpretation der Gaussschen Osterformel und ihrer Ausnahmeregeln, Historia Mathematica 24 (1997), pp. 441-444\r      http://www.ptb.de/de/org/4/44/441/oste.htm  ""\r\r  | k m s a d r og sz oe day |\r\r  k := year // 100.\r  m := 15 + (3*k + 3//4) - (8*k + 13//25).\r   s := 2 - (3*k + 3// 4).\r  a := year \\\\ 19.\r  d := 19*a + m \\\\ 30.\r  r := d//29 + ((d//28) - (d//29)* (a// 11)).\r\r  og := 21 + d - r.\r  sz := 7 - (year//4 + year + s\\\\7).\r  oe := 7 - (og - sz\\\\7).\r  day := og + oe.\r  ^day <= 31\r    ifTrue: [ Date year: year month: 3 day: day ]\r    ifFalse: [ Date year: year month: 4 day: day - 31 ].\r"\r\r"Знайдіть роки, коли святкування припадають на один день."\r\ryearsWithMatchingEasterFrom: startYear to: endYear\r\r    | matchingYears orthodoxDate catholicDate |\r    matchingYears := OrderedCollection new.\r    (startYear to: endYear) do: [:year |\r        orthodoxDate := self orthodoxEasterDateFor: year.\r        catholicDate := self easterDateFor: year.\r        (orthodoxDate = catholicDate) ifTrue: [\r            matchingYears add: year\r        ].\r    ].\r    ^matchingYears asArray\r\rDate yearsWithMatchingEasterFrom: 2000 to: 2050. "#(2001 2004 2007 2010 2011 2014 2017 2025 2028 2031 2034 2037 2038 2041 2045 2048)"\r\r" ------ РЕКУРСІЯ\r  Додайте до класу Integer і випробуйте різні методи обчислення чисел  Фібоначчі.\r  Запропонуйте власні. Порівняйте їхню ефективність.      \r  Перед випробуванням fibonacci ЗБЕРЕЖІТЬ ІМІДЖ СИСТЕМИ! Він може зайняти Ваш комп на тиждень.  "\r\r3 fibStart: 1 with: 10  "<-- 12"\r4 fibo "<-- 5"\r12 fibonacci "<-- 233"\r\r\r"\r==============\rВласні методи:\r==============\r\r- Метод 1:\rInteger >> factorial\r    ""Обчислення факторіалу числа""\r    ^ self <= 1 ifTrue: [1] ifFalse: [self * (self - 1) factorial].\r\r- Метод 2:\rInteger >> sumTo\r    ""Сума всіх чисел від 1 до self""\r    | sum i |\r    sum := 0.\r    1 to: self do: [:i | sum := sum + i].\r    ^ sum.\r"\r\r"\rПояснення: <fibStart:with:>\rРекурсивний метод, який обчислює n-те число Фібоначчі, використовуючи два акумулятори: n1 (попереднє) і n2 (пред-попереднє).\rРекурсія: (self - 1) fibStart: n1+n2 with: n1 → наступний крок отримує нове попереднє число як суму двох попередніх.\r\rДуже швидкий для будь-якого n, навіть великого. Не обчислює одні й ті ж значення повторно → O(n). \rПам’яті потрібно лише для стеку рекурсії (глибина n).\r\rПояснення: <fibo>\rПроста обгортка над <fibStart:with:.>\r\rПовністю така ж, як у fibStart:with:. Зручно викликати без ручного передавання початкових чисел.\r\rПояснення: <fibonacci>\rКласична рекурсія: F(n) = F(n-1) + F(n-2).\r\rДуже повільний для великих n. Обчислює одні й ті ж значення багато разів → експоненційна складність O(2ⁿ). \rМоже сильно навантажити процесор і стек викликів.\r"\r\r"------------------------------------------------------------------------------------\r ------ СТВОРЕННЯ, ОПРАЦЮВАННЯ КОЛЕКЦІЙ\r  У текстовому файлі записано інформацію про матрицю цілих чисел: розміри\r  матриці в першому рядку файла, у всіх наступних рядках - рядки матриці.}\r  Прочитати матрицю, знайти максимальні елементи кожного рядка і зберегти\r  їх у файлі. Надрукувати максимальний елемент цілої матриці."\r\r"Наведений нижче код можна виконати безпосередньо в робочому вікні,\r проте,  доцільно зробити його методом власного навчального класу."\r\r| matr fStream fName n m mMatr mLines |\r        "Вибір файла за допомогою діалогу"\r    (fName:=UIManager default\r\t\t\tchooseFullFileNameMatching: nil \r\t\t\tlabel: \'Виберіть файл з числовими даними\' ) isNil\r        ifTrue: [ ^\'Ви не вибрали файла\' ]. \r        fStream := fName asFileReference readStream.\r\t        "Введення даних"\r \t    n := Integer readFrom: fStream.  \r\t    matr := Array new: n.\r\t    m := Integer readFrom: fStream.\r\t    matr := matr collect: [ :x | Array new: m ]. \r\t    1 to: n do: [ :i |  fStream nextLine.\r \t\t     matr at: i put: (\r\t\t\t\t (matr at: i) collect: [ :x |  \r\t\t\t\t\t\tInteger readFrom: fStream. ]\r\t\t\t\t\t )\t ].\r    fStream close. matr inspect.\r        "Обчислення максимальних елементів"\r    mLines:=matr collect: [ :r | r inject: (r at: 1) into: [ :x :y | x max: y] ].\r    mMatr:=mLines at: 1.\r    mLines do: [ :x | x > mMatr ifTrue: [ mMatr := x ] ].\r        "Побудова імені файла результатів, збереження"\r    fName at: fName size - 4 put: $_ .\r    fStream := fName asFileReference writeStream.\r    mLines do: [ :x | x printOn: fStream. fStream cr ].\r    fStream close.\r    ^mMatr .  \r\r" Поясніть код, наведений вище (кожне повідомлення!):\r\r\t| matr fStream fName n m mMatr mLines | <-- Локальні змінні\r\r\tВідкриваємо діалог вибору файлу. Якщо користувач не вибрав файл – повертаємо повідомлення:\r\t(fName := UIManager default\r\t    chooseFullFileNameMatching: nil\r\t    label: \'Виберіть файл з числовими даними\') isNil\r\t    ifTrue: [ ^\'Ви не вибрали файла\' ].\r\r\tfStream := fName asFileReference readStream. <-- Відкриваємо потік для читання файлу\r\tn := Integer readFrom: fStream. <-- Читаємо перше число з файлу – кількість рядків матриці\r\tmatr := Array new: n. <-- Створюємо масив для рядків матриці:\r\tm := Integer readFrom: fStream. <-- Читаємо друге число з файлу – кількість стовпців матриці\r\tmatr := matr collect: [:x | Array new: m]. <-- Заповнюємо кожен рядок новим масивом стовпців (масив масивів)\r\r\tПроходимо по кожному рядку:\r\t - пропускаємо порожню або заголовочну лінію\r\t - читаємо числа рядка і записуємо у відповідний рядок матриці:\r\t1 to: n do: [:i |\r\t    fStream nextLine.\r\t    matr at: i put: (\r\t        (matr at: i) collect: [:x | Integer readFrom: fStream]\r\t    )].\r\r\tfStream close. <-- Закриваємо потік після читання\r\tmatr inspect. <-- Відкриваємо інспектор для перегляду матриці\r\r\tОбчислюємо максимум у кожному рядку:\r\t - inject: використовується для проходження елементів\r\t - функція x max: y повертає більший елемент\r\tmLines := matr collect: [:r | r inject: (r at: 1) into: [:x :y | x max: y]].\r\r\tЗнаходимо загальний максимум матриці:\r\t - проходимо по максимумам рядків і оновлюємо mMatr:\r\tmMatr := mLines at: 1.\r\tmLines do: [:x | x > mMatr ifTrue: [ mMatr := x ]].\r\r\tfName at: fName size - 4 put: $_. <-- Змінюємо розширення файлу для збереження результатів\r\tfStream := fName asFileReference writeStream. <-- Відкриваємо потік для запису у файл\r\tmLines do: [:x | x printOn: fStream. fStream cr]. <-- Записуємо максимуми рядків у файл, кожен на новий рядок\r\tfStream close. <-- Закриваємо файл після запису\r\t^ mMatr. <-- Повертаємо максимальний елемент всієї матриці\r\r   Як замінити масивмасивів на екземпляр класу Matrix?:\r\tMatrix замінює масив масивів, тобто ми маємо одну структуру n × m. До елементів доступ через at: i at: j.\r\tЦе дозволяє компактно читати дані з файлу, знаходити максимуми і записувати результати, не створюючи додаткових масивів рядків:\r\t\r\t| matr fStream n m mMatr |\r\r\tВідкриваємо файл та читаємо розміри:\r\tfStream := \'file.txt\' asFileReference readStream.\r\tn := Integer readFrom: fStream.\r\tm := Integer readFrom: fStream.\r\r\tСтворюємо і заповнюємо матрицю:\r\tmatr := Matrix rows: n columns: m.\r\t1 to: n do: [:i | 1 to: m do: [:j | matr at: i at: j put: Integer readFrom: fStream]].\r\tfStream close.\r\r\tЗнаходимо загальний максимум:\r\tmMatr := (1 to: n) inject: 0 into: [:maxRow :i | maxRow max: ((1 to: m) inject: 0 into: [:maxCol :j | maxCol max: (matr at: i at: j)])].\r\t^ mMatr.\r\r======================================================\r\r ------ АДРЕСНА КНИГА\r Приклад створення і використання адресної книги, описаний у одній з лекцій. \r Пригадуєте, спочатку оголошуємо глобальну змінну, що міститиме впорядковану \r колекцію масивів з трьох рядків. Спосіб порівняння описує бінарний блок.    "\r\r    Smalltalk globals at: #AddressBook\r              put:(SortedCollection sortBlock:[:a :b | (a at:1)<=(b at:1)]).\r\r" * --- Тепер до книги можна додавати записи. "\r\r    AddressBook\r            add: #(\'Ruth\' \'Babe\' \'456 Mudville Flats\');\r            add: #(\'Smith\' \'John\' \'12/5 Park Ave\');\r            add: #(\'Jexon\' \'John\' \'5 Baverli Hills\');\r            add: #(\'Adams\' \'John\' \'1 Hell str\');\r            add: #(\'Taylor\' \'Babe\' \'2a/35 Deribas str\');\r            add: #(\'Greg\' \'Voss\' \'12345 the USA\')."<-- #(\'Greg\' \'Voss\' \'12345 the USA\')"\r\r" * --- Додайте власні записи. Видрукуйте вміст книги (код запропоновано нижче)."\r   | s w |  s := WriteStream on: String new.\r\r    AddressBook do:[:x | x do:\r        [ :y | s nextPutAll: y; tab; tab.].\r        s cr. ]. \r\tAddressBook\r    add: #(\'Brown\' \'Alice\' \'7 Cherry Lane\');\r    add: #(\'White\' \'Bob\' \'15 Oak Street\');\r    add: #(\'Green\' \'Clara\' \'9 Pine Avenue\').\r\r\t  \r\ts := WriteStream on: String new.\r\tAddressBook do: [ :x | x do: [ :y | s nextPutAll: y; tab; tab. ] ] \r\t\r\t\r  w := Workspace openLabel: \'My Address Book\'.\r  w contents: s contents.\r\r" * ----  Наступне завдання - надрукувати список прізвищ людей з однаковими іменами. \r              Приклад демонструє різні способи перебору та перетворення колекцій."\r\r | firstNames duplicates |\r    firstNames:=Bag new.       \r    AddressBook do: [ :entry | firstNames add: (entry at: 2) ]. \r\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r        \r    duplicates:=firstNames select:\r        [ :name | (firstNames occurrencesOf: name)>1 ].\r    duplicates do: [ :first | first printOn: Transcript. Transcript show:\'==>\'.\r        AddressBook do: [ :entry | (entry at: 2)=first\r            ifTrue: [ Transcript show:\' \'. (entry at: 1) printOn: Transcript ] ].\r        Transcript cr ]. Transcript show:\' \'.\r\r" Поясніть перетворення, що відбуваються в цьому фрагменті:\r\tBag — зберігає елементи з повтореннями.\r\tselect: — фільтрує колекцію, залишаючи тільки елементи, що задовольняють умові (тут, occurrencesOf: > 1).\r\tasSet — видаляє дублікати після фільтрації.\r\tasSortedCollection — сортує результати для зручного виводу.\r\tdo — ітерує колекцію і виконує дію (друк у Transcript).\r\r   Запропонуйте власні варіанти використання та перетворення колекцій. \r \r  Оформіть запропоновані вище фрагменти як методи навчального класу:\r\tObject subclass: #AddressBookUtils\r    \tinstanceVariableNames: \'\'\r    \tclassVariableNames: \'\'\r    \tpoolDictionaries: \'\'\r    \tcategory: \'Training-Examples\'.\r\r"\r\r\r" ------ ДОДАВАННЯ АДРЕС\r  Можливо, додавання записів до AddressBook за допомогою явного програмування \r  виглядає не надто привабливо. Використайте з цією метою діалоги "\r\r| a b c | \ra := UIManager default request: \'Input first name\'.\rb := UIManager default request: \'Input second name\'.\rc := UIManager default request: \'Input address\'.\ra isNil | b isNil | c isNil ifFalse: [ AddressBook add: (Array with:a with:b with:c)]. "<-- #(\'Oleh\' \'Chyzhov\' \'MyAddress 23\')"\r\r" Додайте до книги декілька нових записів, знову видрукуйте її. "\r"Через це в книзі так багато записів:"\r[\r    | a b c |\r    a := UIManager default request: \'Input first name\'.\r    a isNil ifTrue: [ ^self ].  "Cancel завершує цикл"\r\r    b := UIManager default request: \'Input second name\'.\r    b isNil ifTrue: [ ^self ].\r\r    c := UIManager default request: \'Input address\'.\r    c isNil ifTrue: [ ^self ].\r\r    AddressBook add: (Array with: a with: b with: c).\r] repeat.\r\r\ts := WriteStream on: String new.\r\tAddressBook do: [ :x | x do: [ :y | s nextPutAll: y; tab; tab. ] ]\r\r" Поміркуйте, як зробити зручнішим звертання до діалогу додавання адрес та друку адресної книги. "\r\r" Що станеться, якщо виконати наступний код? Випробуйте. "\r    Smalltalk globals removeKey:#AddressBook. "<-- з глобального словника Smalltalk globals буде видалено ключ #AddressBook і, відповідно, саму твою колекцію (адресну книгу)."\r\r "------ ПЕРЕТВОРЕННЯ (ПЕРЕВТІЛЕННЯ) ОБ\'ЄКТІВ\r   Виконайте за допомогою Do It. "\r\r | a b c|\r    a := OrderedCollection new.\r    b := Cylinder new.\r    c := Array with: a with: b with: b.\r    Transcript show: \'Old Array is = \'.\r    c do: [ :x | Transcript show: \'     \'. x printOn: Transcript ].\r    Transcript cr.\r    a become: b.\r    Transcript show: \'New Array is = \'.\r    c do: [ :x | Transcript show: \'     \'. x printOn: Transcript ].\r    Transcript cr; show:\' \'. "<-- Unknown variable"\r\r" Поясніть дію методу become:. Чи можна замість нього користуватися звичайним присвоєнням? Наведіть власні приклади. "\r\r" Він міняє всі посилання на два об’єкти місцями у всій системі.  \r  Не можна замість become використовувати звичайне присвоєння, адже такого ефекту не можливо буде досягнути."\r\r\r\r\r\r\r\r'
}OmEntry {
	#tags : {
		#timestamp : DateAndTime [ '2025-10-04T22:27:06.435+03:00' ],
		#self : OmReference [ '17' ]
	},
	#content : '"--------------------------------------------------------------------------------------\r*                      ЛАБОРОТОРНА РОБОТА 3\r*                 Тема: КЛАСИ ТА МЕТОДИ. КОЛЕКЦІЇ\r*\r*  Завдання до лабораторної роботи:\r*     1. Виконайте наведені нижче приклади, збережіть і поясніть отримані результати.\r*     2. Випробуйте різноманітні способи додавання нових класів до системи.\r*     3. Навчіться доповнювати функціональність класів.\r*     4. Випробуйте методи опрацювання колекцій.\r*\r\r    Виконайте за допомогою <Print it> \r\r ------ ПРИНАЛЕЖНІСТЬ КЛАСОВІ, ІЄРАРХІЯ КЛАСІВ\r"\r    #(Francesca Jackie Marisa Bree) class. "Array"\r    (#(Francesca Jackie Marisa Bree) at:2) class. "ByteSymbol"\r    \'Rakesh Vijay Charles Daniel Tyler\' class. "ByteString"\r    (\'Rakesh Vijay Charles Daniel Tyler\' at:2) class. "Character (a)"\r    World class . "WorldMorph"\r    Magnitude class. "Magnitude class"\r    Magnitude class class. "Metaclass"\r    nil class. "UndefinedObject"\r    5 species. "SmallInteger"\r    123456789000 species. "SmallInteger"\r    #aName species. "ByteString"\r " Яка різниця між повідомленнями class i species ? \r\r    Випробуйте різні способи відкривання браузера класів: за допомогою меню чи програмно \r     Виконайте за допомогою <Do it>\r"\r    ClyFullBrowserMorph open. \r    ClyFullBrowserMorph openOnClass: Date. \r    ClyFullBrowserMorph openOnClass: VolumeShape  selector:  #volume. \r\r" ------ МЕТОДИ КЛАСУ, КОНСТРУКТОРИ\r  Виконайте за допомогою <Print It>. Запропонуйте власні приклади. "\r\r    Array new: 10. "#(nil nil nil nil nil nil nil nil nil nil)"        \r    OrderedCollection  new. "an OrderedCollection()"\r    Date today. "29 September 2025"\r    Time now. "10:28:52.422 am"\r    UIManager default  request:\'How are you?\' initialAnswer:\'I\'\'m fine!\'. "\'I\'\'m fine!\'"\r    Integer readFrom: \'2013  1925\'. "2013"\r    Integer primesUpTo: 100. "#(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97)"\r    Rectangle origin:0@0 corner:200@100. "(0@0) corner: (200@100)"\r    Date nameOfMonth:12. "#December"\r    Date dayOfWeek: #Friday. "6"\r    Date orthodoxEasterDateFor: 2022. "24 April 2022"\r\r\r   \r"Інсталюйте вказані нижче МЕТОДИ КЛАСУ Date:\r  перенесіть копію тексту визначення методу з робочого вікна в браузер класів.\r\r""!Date class methodsFor: \'specific inquiries\' stamp: \'CamilloBruni 8/22/2013 19:47\'!""\r\rorthodoxEasterDateFor: year\r ""  compute the easter date according to the rules of the orthodox calendar.\r    source:       http://www.smart.net/~mmontes/ortheast.html   ""\r     | r1 r2 r3 r4 ra rb r5 rc date |\r\r    r1 := year \\\\ 19.\r    r2 := year \\\\ 4.\r    r3 := year \\\\ 7.\r    ra := 19*r1 + 16.\r    r4 := ra \\\\ 30.\r    rb := r2 + r2 + (4*r3) + (6*r4).\r    r5 := rb \\\\ 7.\r    rc := r4 + r5.\r    date := self year: year month: 4 day: 3.\r    ^date addDays: rc.\r""--------------------------------------------------------------------------------------""\r""!Date class methodsFor: \'specific inquiries\' stamp: \'CamilloBruni 8/22/2013 19:48\'!""\r\reasterDateFor: year\r ""  compute the easter date.\r    source: Physikalisch-Technische Bundesanstalt Braunschweig.\r    Lichtenberg, H.: Zur Interpretation der Gaussschen Osterformel und ihrer Ausnahmeregeln, Historia Mathematica 24 (1997), pp. 441-444\r      http://www.ptb.de/de/org/4/44/441/oste.htm  ""\r\r  | k m s a d r og sz oe day |\r\r  k := year // 100.\r  m := 15 + (3*k + 3//4) - (8*k + 13//25).\r   s := 2 - (3*k + 3// 4).\r  a := year \\\\ 19.\r  d := 19*a + m \\\\ 30.\r  r := d//29 + ((d//28) - (d//29)* (a// 11)).\r\r  og := 21 + d - r.\r  sz := 7 - (year//4 + year + s\\\\7).\r  oe := 7 - (og - sz\\\\7).\r  day := og + oe.\r  ^day <= 31\r    ifTrue: [ Date year: year month: 3 day: day ]\r    ifFalse: [ Date year: year month: 4 day: day - 31 ].\r"\r\r"Знайдіть роки, коли святкування припадають на один день."\r\ryearsWithMatchingEasterFrom: startYear to: endYear\r\r    | matchingYears orthodoxDate catholicDate |\r    matchingYears := OrderedCollection new.\r    (startYear to: endYear) do: [:year |\r        orthodoxDate := self orthodoxEasterDateFor: year.\r        catholicDate := self easterDateFor: year.\r        (orthodoxDate = catholicDate) ifTrue: [\r            matchingYears add: year\r        ].\r    ].\r    ^matchingYears asArray\r\rDate yearsWithMatchingEasterFrom: 2000 to: 2050. "#(2001 2004 2007 2010 2011 2014 2017 2025 2028 2031 2034 2037 2038 2041 2045 2048)"\r\r" ------ РЕКУРСІЯ\r  Додайте до класу Integer і випробуйте різні методи обчислення чисел  Фібоначчі.\r  Запропонуйте власні. Порівняйте їхню ефективність.      \r  Перед випробуванням fibonacci ЗБЕРЕЖІТЬ ІМІДЖ СИСТЕМИ! Він може зайняти Ваш комп на тиждень.  "\r\r3 fibStart: 1 with: 10  "<-- 12"\r4 fibo "<-- 5"\r12 fibonacci "<-- 233"\r\r\r"\r==============\rВласні методи:\r==============\r\r- Метод 1:\rInteger >> factorial\r    ""Обчислення факторіалу числа""\r    ^ self <= 1 ifTrue: [1] ifFalse: [self * (self - 1) factorial].\r\r- Метод 2:\rInteger >> sumTo\r    ""Сума всіх чисел від 1 до self""\r    | sum i |\r    sum := 0.\r    1 to: self do: [:i | sum := sum + i].\r    ^ sum.\r"\r\r"\rПояснення: <fibStart:with:>\rРекурсивний метод, який обчислює n-те число Фібоначчі, використовуючи два акумулятори: n1 (попереднє) і n2 (пред-попереднє).\rРекурсія: (self - 1) fibStart: n1+n2 with: n1 → наступний крок отримує нове попереднє число як суму двох попередніх.\r\rДуже швидкий для будь-якого n, навіть великого. Не обчислює одні й ті ж значення повторно → O(n). \rПам’яті потрібно лише для стеку рекурсії (глибина n).\r\rПояснення: <fibo>\rПроста обгортка над <fibStart:with:.>\r\rПовністю така ж, як у fibStart:with:. Зручно викликати без ручного передавання початкових чисел.\r\rПояснення: <fibonacci>\rКласична рекурсія: F(n) = F(n-1) + F(n-2).\r\rДуже повільний для великих n. Обчислює одні й ті ж значення багато разів → експоненційна складність O(2ⁿ). \rМоже сильно навантажити процесор і стек викликів.\r"\r\r"------------------------------------------------------------------------------------\r ------ СТВОРЕННЯ, ОПРАЦЮВАННЯ КОЛЕКЦІЙ\r  У текстовому файлі записано інформацію про матрицю цілих чисел: розміри\r  матриці в першому рядку файла, у всіх наступних рядках - рядки матриці.}\r  Прочитати матрицю, знайти максимальні елементи кожного рядка і зберегти\r  їх у файлі. Надрукувати максимальний елемент цілої матриці."\r\r"Наведений нижче код можна виконати безпосередньо в робочому вікні,\r проте,  доцільно зробити його методом власного навчального класу."\r\r| matr fStream fName n m mMatr mLines |\r        "Вибір файла за допомогою діалогу"\r    (fName:=UIManager default\r\t\t\tchooseFullFileNameMatching: nil \r\t\t\tlabel: \'Виберіть файл з числовими даними\' ) isNil\r        ifTrue: [ ^\'Ви не вибрали файла\' ]. \r        fStream := fName asFileReference readStream.\r\t        "Введення даних"\r \t    n := Integer readFrom: fStream.  \r\t    matr := Array new: n.\r\t    m := Integer readFrom: fStream.\r\t    matr := matr collect: [ :x | Array new: m ]. \r\t    1 to: n do: [ :i |  fStream nextLine.\r \t\t     matr at: i put: (\r\t\t\t\t (matr at: i) collect: [ :x |  \r\t\t\t\t\t\tInteger readFrom: fStream. ]\r\t\t\t\t\t )\t ].\r    fStream close. matr inspect.\r        "Обчислення максимальних елементів"\r    mLines:=matr collect: [ :r | r inject: (r at: 1) into: [ :x :y | x max: y] ].\r    mMatr:=mLines at: 1.\r    mLines do: [ :x | x > mMatr ifTrue: [ mMatr := x ] ].\r        "Побудова імені файла результатів, збереження"\r    fName at: fName size - 4 put: $_ .\r    fStream := fName asFileReference writeStream.\r    mLines do: [ :x | x printOn: fStream. fStream cr ].\r    fStream close.\r    ^mMatr .  \r\r" Поясніть код, наведений вище (кожне повідомлення!):\r\r\t| matr fStream fName n m mMatr mLines | <-- Локальні змінні\r\r\tВідкриваємо діалог вибору файлу. Якщо користувач не вибрав файл – повертаємо повідомлення:\r\t(fName := UIManager default\r\t    chooseFullFileNameMatching: nil\r\t    label: \'Виберіть файл з числовими даними\') isNil\r\t    ifTrue: [ ^\'Ви не вибрали файла\' ].\r\r\tfStream := fName asFileReference readStream. <-- Відкриваємо потік для читання файлу\r\tn := Integer readFrom: fStream. <-- Читаємо перше число з файлу – кількість рядків матриці\r\tmatr := Array new: n. <-- Створюємо масив для рядків матриці:\r\tm := Integer readFrom: fStream. <-- Читаємо друге число з файлу – кількість стовпців матриці\r\tmatr := matr collect: [:x | Array new: m]. <-- Заповнюємо кожен рядок новим масивом стовпців (масив масивів)\r\r\tПроходимо по кожному рядку:\r\t - пропускаємо порожню або заголовочну лінію\r\t - читаємо числа рядка і записуємо у відповідний рядок матриці:\r\t1 to: n do: [:i |\r\t    fStream nextLine.\r\t    matr at: i put: (\r\t        (matr at: i) collect: [:x | Integer readFrom: fStream]\r\t    )].\r\r\tfStream close. <-- Закриваємо потік після читання\r\tmatr inspect. <-- Відкриваємо інспектор для перегляду матриці\r\r\tОбчислюємо максимум у кожному рядку:\r\t - inject: використовується для проходження елементів\r\t - функція x max: y повертає більший елемент\r\tmLines := matr collect: [:r | r inject: (r at: 1) into: [:x :y | x max: y]].\r\r\tЗнаходимо загальний максимум матриці:\r\t - проходимо по максимумам рядків і оновлюємо mMatr:\r\tmMatr := mLines at: 1.\r\tmLines do: [:x | x > mMatr ifTrue: [ mMatr := x ]].\r\r\tfName at: fName size - 4 put: $_. <-- Змінюємо розширення файлу для збереження результатів\r\tfStream := fName asFileReference writeStream. <-- Відкриваємо потік для запису у файл\r\tmLines do: [:x | x printOn: fStream. fStream cr]. <-- Записуємо максимуми рядків у файл, кожен на новий рядок\r\tfStream close. <-- Закриваємо файл після запису\r\t^ mMatr. <-- Повертаємо максимальний елемент всієї матриці\r\r   Як замінити масивмасивів на екземпляр класу Matrix?:\r\tMatrix замінює масив масивів, тобто ми маємо одну структуру n × m. До елементів доступ через at: i at: j.\r\tЦе дозволяє компактно читати дані з файлу, знаходити максимуми і записувати результати, не створюючи додаткових масивів рядків:\r\t\r\t| matr fStream n m mMatr |\r\r\tВідкриваємо файл та читаємо розміри:\r\tfStream := \'file.txt\' asFileReference readStream.\r\tn := Integer readFrom: fStream.\r\tm := Integer readFrom: fStream.\r\r\tСтворюємо і заповнюємо матрицю:\r\tmatr := Matrix rows: n columns: m.\r\t1 to: n do: [:i | 1 to: m do: [:j | matr at: i at: j put: Integer readFrom: fStream]].\r\tfStream close.\r\r\tЗнаходимо загальний максимум:\r\tmMatr := (1 to: n) inject: 0 into: [:maxRow :i | maxRow max: ((1 to: m) inject: 0 into: [:maxCol :j | maxCol max: (matr at: i at: j)])].\r\t^ mMatr.\r\r======================================================\r\r ------ АДРЕСНА КНИГА\r Приклад створення і використання адресної книги, описаний у одній з лекцій. \r Пригадуєте, спочатку оголошуємо глобальну змінну, що міститиме впорядковану \r колекцію масивів з трьох рядків. Спосіб порівняння описує бінарний блок.    "\r\r    Smalltalk globals at: #AddressBook\r              put:(SortedCollection sortBlock:[:a :b | (a at:1)<=(b at:1)]).\r\r" * --- Тепер до книги можна додавати записи. "\r\r    AddressBook\r            add: #(\'Ruth\' \'Babe\' \'456 Mudville Flats\');\r            add: #(\'Smith\' \'John\' \'12/5 Park Ave\');\r            add: #(\'Jexon\' \'John\' \'5 Baverli Hills\');\r            add: #(\'Adams\' \'John\' \'1 Hell str\');\r            add: #(\'Taylor\' \'Babe\' \'2a/35 Deribas str\');\r            add: #(\'Greg\' \'Voss\' \'12345 the USA\')."<-- #(\'Greg\' \'Voss\' \'12345 the USA\')"\r\r" * --- Додайте власні записи. Видрукуйте вміст книги (код запропоновано нижче)."\r   | s w |  s := WriteStream on: String new.\r\r    AddressBook do:[:x | x do:\r        [ :y | s nextPutAll: y; tab; tab.].\r        s cr. ]. \r\tAddressBook\r    add: #(\'Brown\' \'Alice\' \'7 Cherry Lane\');\r    add: #(\'White\' \'Bob\' \'15 Oak Street\');\r    add: #(\'Green\' \'Clara\' \'9 Pine Avenue\').\r\r\t  \r\ts := WriteStream on: String new.\r\tAddressBook do: [ :x | x do: [ :y | s nextPutAll: y; tab; tab. ] ] \r\t\r\t\r  w := Workspace openLabel: \'My Address Book\'.\r  w contents: s contents.\r\r" * ----  Наступне завдання - надрукувати список прізвищ людей з однаковими іменами. \r              Приклад демонструє різні способи перебору та перетворення колекцій."\r\r | firstNames duplicates |\r    firstNames:=Bag new.       \r    AddressBook do: [ :entry | firstNames add: (entry at: 2) ]. \r\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r        \r    duplicates:=firstNames select:\r        [ :name | (firstNames occurrencesOf: name)>1 ].\r    duplicates do: [ :first | first printOn: Transcript. Transcript show:\'==>\'.\r        AddressBook do: [ :entry | (entry at: 2)=first\r            ifTrue: [ Transcript show:\' \'. (entry at: 1) printOn: Transcript ] ].\r        Transcript cr ]. Transcript show:\' \'.\r\r" Поясніть перетворення, що відбуваються в цьому фрагменті:\r\tBag — зберігає елементи з повтореннями.\r\tselect: — фільтрує колекцію, залишаючи тільки елементи, що задовольняють умові (тут, occurrencesOf: > 1).\r\tasSet — видаляє дублікати після фільтрації.\r\tasSortedCollection — сортує результати для зручного виводу.\r\tdo — ітерує колекцію і виконує дію (друк у Transcript).\r\r   Запропонуйте власні варіанти використання та перетворення колекцій. \r \r  Оформіть запропоновані вище фрагменти як методи навчального класу:\r\tObject subclass: #AddressBookUtils\r    \tinstanceVariableNames: \'\'\r    \tclassVariableNames: \'\'\r    \tpoolDictionaries: \'\'\r    \tcategory: \'Training-Examples\'.\r\r"\r\r\r" ------ ДОДАВАННЯ АДРЕС\r  Можливо, додавання записів до AddressBook за допомогою явного програмування \r  виглядає не надто привабливо. Використайте з цією метою діалоги "\r\r| a b c | \ra := UIManager default request: \'Input first name\'.\rb := UIManager default request: \'Input second name\'.\rc := UIManager default request: \'Input address\'.\ra isNil | b isNil | c isNil ifFalse: [ AddressBook add: (Array with:a with:b with:c)]. \r\r" Додайте до книги декілька нових записів, знову видрукуйте її. "\r"Через це в книзі так багато записів:"\r[\r    | a b c |\r    a := UIManager default request: \'Input first name\'.\r    a isNil ifTrue: [ ^self ].  \r\r    b := UIManager default request: \'Input second name\'.\r    b isNil ifTrue: [ ^self ].\r\r    c := UIManager default request: \'Input address\'.\r    c isNil ifTrue: [ ^self ].\r\r    AddressBook add: (Array with: a with: b with: c).\r] repeat.\r\r\ts := WriteStream on: String new.\r\tAddressBook do: [ :x | x do: [ :y | s nextPutAll: y; tab; tab. ] ]\r\r" Поміркуйте, як зробити зручнішим звертання до діалогу додавання адрес та друку адресної книги. "\r\r" Що станеться, якщо виконати наступний код? Випробуйте. "\r    Smalltalk globals removeKey:#AddressBook. "<-- з глобального словника Smalltalk globals буде видалено ключ #AddressBook і, відповідно, саму твою колекцію (адресну книгу)."\r\r "------ ПЕРЕТВОРЕННЯ (ПЕРЕВТІЛЕННЯ) ОБ\'ЄКТІВ\r   Виконайте за допомогою Do It. "\r\r | a b c|\r    a := OrderedCollection new.\r    b := Cylinder new.\r    c := Array with: a with: b with: b.\r    Transcript show: \'Old Array is = \'.\r    c do: [ :x | Transcript show: \'     \'. x printOn: Transcript ].\r    Transcript cr.\r    a become: b.\r    Transcript show: \'New Array is = \'.\r    c do: [ :x | Transcript show: \'     \'. x printOn: Transcript ].\r    Transcript cr; show:\' \'. "<-- Unknown variable"\r\r" Поясніть дію методу become:. Чи можна замість нього користуватися звичайним присвоєнням? Наведіть власні приклади. "\r\r" Він міняє всі посилання на два об’єкти місцями у всій системі.  \r  Не можна замість become використовувати звичайне присвоєння, адже такого ефекту не можливо буде досягнути."\r\r\r\r\r\r\r\r'
}OmEntry {
	#tags : {
		#timestamp : DateAndTime [ '2025-10-04T22:28:49.961+03:00' ],
		#self : OmReference [ '18' ]
	},
	#content : '"--------------------------------------------------------------------------------------\r*                      ЛАБОРОТОРНА РОБОТА 3\r*                 Тема: КЛАСИ ТА МЕТОДИ. КОЛЕКЦІЇ\r*\r*  Завдання до лабораторної роботи:\r*     1. Виконайте наведені нижче приклади, збережіть і поясніть отримані результати.\r*     2. Випробуйте різноманітні способи додавання нових класів до системи.\r*     3. Навчіться доповнювати функціональність класів.\r*     4. Випробуйте методи опрацювання колекцій.\r*\r\r    Виконайте за допомогою <Print it> \r\r ------ ПРИНАЛЕЖНІСТЬ КЛАСОВІ, ІЄРАРХІЯ КЛАСІВ\r"\r    #(Francesca Jackie Marisa Bree) class. "Array"\r    (#(Francesca Jackie Marisa Bree) at:2) class. "ByteSymbol"\r    \'Rakesh Vijay Charles Daniel Tyler\' class. "ByteString"\r    (\'Rakesh Vijay Charles Daniel Tyler\' at:2) class. "Character (a)"\r    World class . "WorldMorph"\r    Magnitude class. "Magnitude class"\r    Magnitude class class. "Metaclass"\r    nil class. "UndefinedObject"\r    5 species. "SmallInteger"\r    123456789000 species. "SmallInteger"\r    #aName species. "ByteString"\r " Яка різниця між повідомленнями class i species ? \r\r    Випробуйте різні способи відкривання браузера класів: за допомогою меню чи програмно \r     Виконайте за допомогою <Do it>\r"\r    ClyFullBrowserMorph open. \r    ClyFullBrowserMorph openOnClass: Date. \r    ClyFullBrowserMorph openOnClass: VolumeShape  selector:  #volume. \r\r" ------ МЕТОДИ КЛАСУ, КОНСТРУКТОРИ\r  Виконайте за допомогою <Print It>. Запропонуйте власні приклади. "\r\r    Array new: 10. "#(nil nil nil nil nil nil nil nil nil nil)"        \r    OrderedCollection  new. "an OrderedCollection()"\r    Date today. "29 September 2025"\r    Time now. "10:28:52.422 am"\r    UIManager default  request:\'How are you?\' initialAnswer:\'I\'\'m fine!\'. "\'I\'\'m fine!\'"\r    Integer readFrom: \'2013  1925\'. "2013"\r    Integer primesUpTo: 100. "#(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97)"\r    Rectangle origin:0@0 corner:200@100. "(0@0) corner: (200@100)"\r    Date nameOfMonth:12. "#December"\r    Date dayOfWeek: #Friday. "6"\r    Date orthodoxEasterDateFor: 2022. "24 April 2022"\r\r\r   \r"Інсталюйте вказані нижче МЕТОДИ КЛАСУ Date:\r  перенесіть копію тексту визначення методу з робочого вікна в браузер класів.\r\r""!Date class methodsFor: \'specific inquiries\' stamp: \'CamilloBruni 8/22/2013 19:47\'!""\r\rorthodoxEasterDateFor: year\r ""  compute the easter date according to the rules of the orthodox calendar.\r    source:       http://www.smart.net/~mmontes/ortheast.html   ""\r     | r1 r2 r3 r4 ra rb r5 rc date |\r\r    r1 := year \\\\ 19.\r    r2 := year \\\\ 4.\r    r3 := year \\\\ 7.\r    ra := 19*r1 + 16.\r    r4 := ra \\\\ 30.\r    rb := r2 + r2 + (4*r3) + (6*r4).\r    r5 := rb \\\\ 7.\r    rc := r4 + r5.\r    date := self year: year month: 4 day: 3.\r    ^date addDays: rc.\r""--------------------------------------------------------------------------------------""\r""!Date class methodsFor: \'specific inquiries\' stamp: \'CamilloBruni 8/22/2013 19:48\'!""\r\reasterDateFor: year\r ""  compute the easter date.\r    source: Physikalisch-Technische Bundesanstalt Braunschweig.\r    Lichtenberg, H.: Zur Interpretation der Gaussschen Osterformel und ihrer Ausnahmeregeln, Historia Mathematica 24 (1997), pp. 441-444\r      http://www.ptb.de/de/org/4/44/441/oste.htm  ""\r\r  | k m s a d r og sz oe day |\r\r  k := year // 100.\r  m := 15 + (3*k + 3//4) - (8*k + 13//25).\r   s := 2 - (3*k + 3// 4).\r  a := year \\\\ 19.\r  d := 19*a + m \\\\ 30.\r  r := d//29 + ((d//28) - (d//29)* (a// 11)).\r\r  og := 21 + d - r.\r  sz := 7 - (year//4 + year + s\\\\7).\r  oe := 7 - (og - sz\\\\7).\r  day := og + oe.\r  ^day <= 31\r    ifTrue: [ Date year: year month: 3 day: day ]\r    ifFalse: [ Date year: year month: 4 day: day - 31 ].\r"\r\r"Знайдіть роки, коли святкування припадають на один день."\r\ryearsWithMatchingEasterFrom: startYear to: endYear\r\r    | matchingYears orthodoxDate catholicDate |\r    matchingYears := OrderedCollection new.\r    (startYear to: endYear) do: [:year |\r        orthodoxDate := self orthodoxEasterDateFor: year.\r        catholicDate := self easterDateFor: year.\r        (orthodoxDate = catholicDate) ifTrue: [\r            matchingYears add: year\r        ].\r    ].\r    ^matchingYears asArray\r\rDate yearsWithMatchingEasterFrom: 2000 to: 2050. "#(2001 2004 2007 2010 2011 2014 2017 2025 2028 2031 2034 2037 2038 2041 2045 2048)"\r\r" ------ РЕКУРСІЯ\r  Додайте до класу Integer і випробуйте різні методи обчислення чисел  Фібоначчі.\r  Запропонуйте власні. Порівняйте їхню ефективність.      \r  Перед випробуванням fibonacci ЗБЕРЕЖІТЬ ІМІДЖ СИСТЕМИ! Він може зайняти Ваш комп на тиждень.  "\r\r3 fibStart: 1 with: 10  "<-- 12"\r4 fibo "<-- 5"\r12 fibonacci "<-- 233"\r\r\r"\r==============\rВласні методи:\r==============\r\r- Метод 1:\rInteger >> factorial\r    ""Обчислення факторіалу числа""\r    ^ self <= 1 ifTrue: [1] ifFalse: [self * (self - 1) factorial].\r\r- Метод 2:\rInteger >> sumTo\r    ""Сума всіх чисел від 1 до self""\r    | sum i |\r    sum := 0.\r    1 to: self do: [:i | sum := sum + i].\r    ^ sum.\r"\r\r"\rПояснення: <fibStart:with:>\rРекурсивний метод, який обчислює n-те число Фібоначчі, використовуючи два акумулятори: n1 (попереднє) і n2 (пред-попереднє).\rРекурсія: (self - 1) fibStart: n1+n2 with: n1 → наступний крок отримує нове попереднє число як суму двох попередніх.\r\rДуже швидкий для будь-якого n, навіть великого. Не обчислює одні й ті ж значення повторно → O(n). \rПам’яті потрібно лише для стеку рекурсії (глибина n).\r\rПояснення: <fibo>\rПроста обгортка над <fibStart:with:.>\r\rПовністю така ж, як у fibStart:with:. Зручно викликати без ручного передавання початкових чисел.\r\rПояснення: <fibonacci>\rКласична рекурсія: F(n) = F(n-1) + F(n-2).\r\rДуже повільний для великих n. Обчислює одні й ті ж значення багато разів → експоненційна складність O(2ⁿ). \rМоже сильно навантажити процесор і стек викликів.\r"\r\r"------------------------------------------------------------------------------------\r ------ СТВОРЕННЯ, ОПРАЦЮВАННЯ КОЛЕКЦІЙ\r  У текстовому файлі записано інформацію про матрицю цілих чисел: розміри\r  матриці в першому рядку файла, у всіх наступних рядках - рядки матриці.}\r  Прочитати матрицю, знайти максимальні елементи кожного рядка і зберегти\r  їх у файлі. Надрукувати максимальний елемент цілої матриці."\r\r"Наведений нижче код можна виконати безпосередньо в робочому вікні,\r проте,  доцільно зробити його методом власного навчального класу."\r\r| matr fStream fName n m mMatr mLines |\r        "Вибір файла за допомогою діалогу"\r    (fName:=UIManager default\r\t\t\tchooseFullFileNameMatching: nil \r\t\t\tlabel: \'Виберіть файл з числовими даними\' ) isNil\r        ifTrue: [ ^\'Ви не вибрали файла\' ]. \r        fStream := fName asFileReference readStream.\r\t        "Введення даних"\r \t    n := Integer readFrom: fStream.  \r\t    matr := Array new: n.\r\t    m := Integer readFrom: fStream.\r\t    matr := matr collect: [ :x | Array new: m ]. \r\t    1 to: n do: [ :i |  fStream nextLine.\r \t\t     matr at: i put: (\r\t\t\t\t (matr at: i) collect: [ :x |  \r\t\t\t\t\t\tInteger readFrom: fStream. ]\r\t\t\t\t\t )\t ].\r    fStream close. matr inspect.\r        "Обчислення максимальних елементів"\r    mLines:=matr collect: [ :r | r inject: (r at: 1) into: [ :x :y | x max: y] ].\r    mMatr:=mLines at: 1.\r    mLines do: [ :x | x > mMatr ifTrue: [ mMatr := x ] ].\r        "Побудова імені файла результатів, збереження"\r    fName at: fName size - 4 put: $_ .\r    fStream := fName asFileReference writeStream.\r    mLines do: [ :x | x printOn: fStream. fStream cr ].\r    fStream close.\r    ^mMatr .  \r\r" Поясніть код, наведений вище (кожне повідомлення!):\r\r\t| matr fStream fName n m mMatr mLines | <-- Локальні змінні\r\r\tВідкриваємо діалог вибору файлу. Якщо користувач не вибрав файл – повертаємо повідомлення:\r\t(fName := UIManager default\r\t    chooseFullFileNameMatching: nil\r\t    label: \'Виберіть файл з числовими даними\') isNil\r\t    ifTrue: [ ^\'Ви не вибрали файла\' ].\r\r\tfStream := fName asFileReference readStream. Відкривається потік для читання файлу\r\tn := Integer readFrom: fStream. Читається перше число з файлу(кількість рядків матриці)\r\tmatr := Array new: n. Тут створюється масив для рядків матриці:\r\tm := Integer readFrom: fStream. Тут читається друге число з файлу(кількість стовпців матриці)\r\tmatr := matr collect: [:x | Array new: m].Заповнюємо кожен рядок новим масивом стовпців (масив масивів)\r\r\tПроходимо по кожному рядку:\r\t - пропускаємо порожню або заголовочну лінію\r\t - читаємо числа рядка і записуємо у відповідний рядок матриці:\r\t1 to: n do: [:i |\r\t    fStream nextLine.\r\t    matr at: i put: (\r\t        (matr at: i) collect: [:x | Integer readFrom: fStream]\r\t    )].\r\r\tfStream close. <-- Закриваємо потік після читання\r\tmatr inspect. <-- Відкриваємо інспектор для перегляду матриці\r\r\tОбчислюємо максимум у кожному рядку:\r\t - inject: використовується для проходження елементів\r\t - функція x max: y повертає більший елемент\r\tmLines := matr collect: [:r | r inject: (r at: 1) into: [:x :y | x max: y]].\r\r\tЗнаходимо загальний максимум матриці:\r\t - проходимо по максимумам рядків і оновлюємо mMatr:\r\tmMatr := mLines at: 1.\r\tmLines do: [:x | x > mMatr ifTrue: [ mMatr := x ]].\r\r\tfName at: fName size - 4 put: $_. <-- Змінюємо розширення файлу для збереження результатів\r\tfStream := fName asFileReference writeStream. <-- Відкриваємо потік для запису у файл\r\tmLines do: [:x | x printOn: fStream. fStream cr]. <-- Записуємо максимуми рядків у файл, кожен на новий рядок\r\tfStream close. <-- Закриваємо файл після запису\r\t^ mMatr. <-- Повертаємо максимальний елемент всієї матриці\r\r   Як замінити масивмасивів на екземпляр класу Matrix?:\r\tMatrix замінює масив масивів, тобто ми маємо одну структуру n × m. До елементів доступ через at: i at: j.\r\tЦе дозволяє компактно читати дані з файлу, знаходити максимуми і записувати результати, не створюючи додаткових масивів рядків:\r\t\r\t| matr fStream n m mMatr |\r\r\tВідкриваємо файл та читаємо розміри:\r\tfStream := \'file.txt\' asFileReference readStream.\r\tn := Integer readFrom: fStream.\r\tm := Integer readFrom: fStream.\r\r\tСтворюємо і заповнюємо матрицю:\r\tmatr := Matrix rows: n columns: m.\r\t1 to: n do: [:i | 1 to: m do: [:j | matr at: i at: j put: Integer readFrom: fStream]].\r\tfStream close.\r\r\tЗнаходимо загальний максимум:\r\tmMatr := (1 to: n) inject: 0 into: [:maxRow :i | maxRow max: ((1 to: m) inject: 0 into: [:maxCol :j | maxCol max: (matr at: i at: j)])].\r\t^ mMatr.\r\r======================================================\r\r ------ АДРЕСНА КНИГА\r Приклад створення і використання адресної книги, описаний у одній з лекцій. \r Пригадуєте, спочатку оголошуємо глобальну змінну, що міститиме впорядковану \r колекцію масивів з трьох рядків. Спосіб порівняння описує бінарний блок.    "\r\r    Smalltalk globals at: #AddressBook\r              put:(SortedCollection sortBlock:[:a :b | (a at:1)<=(b at:1)]).\r\r" * --- Тепер до книги можна додавати записи. "\r\r    AddressBook\r            add: #(\'Ruth\' \'Babe\' \'456 Mudville Flats\');\r            add: #(\'Smith\' \'John\' \'12/5 Park Ave\');\r            add: #(\'Jexon\' \'John\' \'5 Baverli Hills\');\r            add: #(\'Adams\' \'John\' \'1 Hell str\');\r            add: #(\'Taylor\' \'Babe\' \'2a/35 Deribas str\');\r            add: #(\'Greg\' \'Voss\' \'12345 the USA\')."<-- #(\'Greg\' \'Voss\' \'12345 the USA\')"\r\r" * --- Додайте власні записи. Видрукуйте вміст книги (код запропоновано нижче)."\r   | s w |  s := WriteStream on: String new.\r\r    AddressBook do:[:x | x do:\r        [ :y | s nextPutAll: y; tab; tab.].\r        s cr. ]. \r\tAddressBook\r    add: #(\'Brown\' \'Alice\' \'7 Cherry Lane\');\r    add: #(\'White\' \'Bob\' \'15 Oak Street\');\r    add: #(\'Green\' \'Clara\' \'9 Pine Avenue\').\r\r\t  \r\ts := WriteStream on: String new.\r\tAddressBook do: [ :x | x do: [ :y | s nextPutAll: y; tab; tab. ] ] \r\t\r\t\r  w := Workspace openLabel: \'My Address Book\'.\r  w contents: s contents.\r\r" * ----  Наступне завдання - надрукувати список прізвищ людей з однаковими іменами. \r              Приклад демонструє різні способи перебору та перетворення колекцій."\r\r | firstNames duplicates |\r    firstNames:=Bag new.       \r    AddressBook do: [ :entry | firstNames add: (entry at: 2) ]. \r\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r        \r    duplicates:=firstNames select:\r        [ :name | (firstNames occurrencesOf: name)>1 ].\r    duplicates do: [ :first | first printOn: Transcript. Transcript show:\'==>\'.\r        AddressBook do: [ :entry | (entry at: 2)=first\r            ifTrue: [ Transcript show:\' \'. (entry at: 1) printOn: Transcript ] ].\r        Transcript cr ]. Transcript show:\' \'.\r\r" Поясніть перетворення, що відбуваються в цьому фрагменті:\r\tBag — зберігає елементи з повтореннями.\r\tselect: — фільтрує колекцію, залишаючи тільки елементи, що задовольняють умові (тут, occurrencesOf: > 1).\r\tasSet — видаляє дублікати після фільтрації.\r\tasSortedCollection — сортує результати для зручного виводу.\r\tdo — ітерує колекцію і виконує дію (друк у Transcript).\r\r   Запропонуйте власні варіанти використання та перетворення колекцій. \r \r  Оформіть запропоновані вище фрагменти як методи навчального класу:\r\tObject subclass: #AddressBookUtils\r    \tinstanceVariableNames: \'\'\r    \tclassVariableNames: \'\'\r    \tpoolDictionaries: \'\'\r    \tcategory: \'Training-Examples\'.\r\r"\r\r\r" ------ ДОДАВАННЯ АДРЕС\r  Можливо, додавання записів до AddressBook за допомогою явного програмування \r  виглядає не надто привабливо. Використайте з цією метою діалоги "\r\r| a b c | \ra := UIManager default request: \'Input first name\'.\rb := UIManager default request: \'Input second name\'.\rc := UIManager default request: \'Input address\'.\ra isNil | b isNil | c isNil ifFalse: [ AddressBook add: (Array with:a with:b with:c)]. \r\r" Додайте до книги декілька нових записів, знову видрукуйте її. "\r"Через це в книзі так багато записів:"\r[\r    | a b c |\r    a := UIManager default request: \'Input first name\'.\r    a isNil ifTrue: [ ^self ].  \r\r    b := UIManager default request: \'Input second name\'.\r    b isNil ifTrue: [ ^self ].\r\r    c := UIManager default request: \'Input address\'.\r    c isNil ifTrue: [ ^self ].\r\r    AddressBook add: (Array with: a with: b with: c).\r] repeat.\r\r\ts := WriteStream on: String new.\r\tAddressBook do: [ :x | x do: [ :y | s nextPutAll: y; tab; tab. ] ]\r\r" Поміркуйте, як зробити зручнішим звертання до діалогу додавання адрес та друку адресної книги. "\r\r" Що станеться, якщо виконати наступний код? Випробуйте. "\r    Smalltalk globals removeKey:#AddressBook. "<-- з глобального словника Smalltalk globals буде видалено ключ #AddressBook і, відповідно, саму твою колекцію (адресну книгу)."\r\r "------ ПЕРЕТВОРЕННЯ (ПЕРЕВТІЛЕННЯ) ОБ\'ЄКТІВ\r   Виконайте за допомогою Do It. "\r\r | a b c|\r    a := OrderedCollection new.\r    b := Cylinder new.\r    c := Array with: a with: b with: b.\r    Transcript show: \'Old Array is = \'.\r    c do: [ :x | Transcript show: \'     \'. x printOn: Transcript ].\r    Transcript cr.\r    a become: b.\r    Transcript show: \'New Array is = \'.\r    c do: [ :x | Transcript show: \'     \'. x printOn: Transcript ].\r    Transcript cr; show:\' \'. "<-- Unknown variable"\r\r" Поясніть дію методу become:. Чи можна замість нього користуватися звичайним присвоєнням? Наведіть власні приклади. "\r\r" Він міняє всі посилання на два об’єкти місцями у всій системі.  \r  Не можна замість become використовувати звичайне присвоєння, адже такого ефекту не можливо буде досягнути."\r\r\r\r\r\r\r\r'
}OmEntry {
	#tags : {
		#timestamp : DateAndTime [ '2025-10-04T23:53:16.156+03:00' ],
		#self : OmReference [ '19' ]
	},
	#content : '"--------------------------------------------------------------------------------------\r*                      ЛАБОРОТОРНА РОБОТА 3\r*                 Тема: КЛАСИ ТА МЕТОДИ. КОЛЕКЦІЇ\r*\r*  Завдання до лабораторної роботи:\r*     1. Виконайте наведені нижче приклади, збережіть і поясніть отримані результати.\r*     2. Випробуйте різноманітні способи додавання нових класів до системи.\r*     3. Навчіться доповнювати функціональність класів.\r*     4. Випробуйте методи опрацювання колекцій.\r*\r\r    Виконайте за допомогою <Print it> \r\r ------ ПРИНАЛЕЖНІСТЬ КЛАСОВІ, ІЄРАРХІЯ КЛАСІВ\r"\r    #(Francesca Jackie Marisa Bree) class. "Array"\r    (#(Francesca Jackie Marisa Bree) at:2) class. "ByteSymbol"\r    \'Rakesh Vijay Charles Daniel Tyler\' class. "ByteString"\r    (\'Rakesh Vijay Charles Daniel Tyler\' at:2) class. "Character (a)"\r    World class . "WorldMorph"\r    Magnitude class. "Magnitude class"\r    Magnitude class class. "Metaclass"\r    nil class. "UndefinedObject"\r    5 species. "SmallInteger"\r    123456789000 species. "SmallInteger"\r    #aName species. "ByteString"\r " Яка різниця між повідомленнями class i species ? \r\r    Випробуйте різні способи відкривання браузера класів: за допомогою меню чи програмно \r     Виконайте за допомогою <Do it>\r"\r    ClyFullBrowserMorph open. \r    ClyFullBrowserMorph openOnClass: Date. \r    ClyFullBrowserMorph openOnClass: VolumeShape  selector:  #volume. \r\r" ------ МЕТОДИ КЛАСУ, КОНСТРУКТОРИ\r  Виконайте за допомогою <Print It>. Запропонуйте власні приклади. "\r\r    Array new: 10. "#(nil nil nil nil nil nil nil nil nil nil)"        \r    OrderedCollection  new. "an OrderedCollection()"\r    Date today. "29 September 2025"\r    Time now. "10:28:52.422 am"\r    UIManager default  request:\'How are you?\' initialAnswer:\'I\'\'m fine!\'. "\'I\'\'m fine!\'"\r    Integer readFrom: \'2013  1925\'. "2013"\r    Integer primesUpTo: 100. "#(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97)"\r    Rectangle origin:0@0 corner:200@100. "(0@0) corner: (200@100)"\r    Date nameOfMonth:12. "#December"\r    Date dayOfWeek: #Friday. "6"\r    Date orthodoxEasterDateFor: 2022. "24 April 2022"\r\r\r   \r"Інсталюйте вказані нижче МЕТОДИ КЛАСУ Date:\r  перенесіть копію тексту визначення методу з робочого вікна в браузер класів.\r\r""!Date class methodsFor: \'specific inquiries\' stamp: \'CamilloBruni 8/22/2013 19:47\'!""\r\rorthodoxEasterDateFor: year\r ""  compute the easter date according to the rules of the orthodox calendar.\r    source:       http://www.smart.net/~mmontes/ortheast.html   ""\r     | r1 r2 r3 r4 ra rb r5 rc date |\r\r    r1 := year \\\\ 19.\r    r2 := year \\\\ 4.\r    r3 := year \\\\ 7.\r    ra := 19*r1 + 16.\r    r4 := ra \\\\ 30.\r    rb := r2 + r2 + (4*r3) + (6*r4).\r    r5 := rb \\\\ 7.\r    rc := r4 + r5.\r    date := self year: year month: 4 day: 3.\r    ^date addDays: rc.\r""--------------------------------------------------------------------------------------""\r""!Date class methodsFor: \'specific inquiries\' stamp: \'CamilloBruni 8/22/2013 19:48\'!""\r\reasterDateFor: year\r ""  compute the easter date.\r    source: Physikalisch-Technische Bundesanstalt Braunschweig.\r    Lichtenberg, H.: Zur Interpretation der Gaussschen Osterformel und ihrer Ausnahmeregeln, Historia Mathematica 24 (1997), pp. 441-444\r      http://www.ptb.de/de/org/4/44/441/oste.htm  ""\r\r  | k m s a d r og sz oe day |\r\r  k := year // 100.\r  m := 15 + (3*k + 3//4) - (8*k + 13//25).\r   s := 2 - (3*k + 3// 4).\r  a := year \\\\ 19.\r  d := 19*a + m \\\\ 30.\r  r := d//29 + ((d//28) - (d//29)* (a// 11)).\r\r  og := 21 + d - r.\r  sz := 7 - (year//4 + year + s\\\\7).\r  oe := 7 - (og - sz\\\\7).\r  day := og + oe.\r  ^day <= 31\r    ifTrue: [ Date year: year month: 3 day: day ]\r    ifFalse: [ Date year: year month: 4 day: day - 31 ].\r"\r\r"Знайдіть роки, коли святкування припадають на один день."\r\ryearsWithMatchingEasterFrom: startYear to: endYear\r\r    | matchingYears orthodoxDate catholicDate |\r    matchingYears := OrderedCollection new.\r    (startYear to: endYear) do: [:year |\r        orthodoxDate := self orthodoxEasterDateFor: year.\r        catholicDate := self easterDateFor: year.\r        (orthodoxDate = catholicDate) ifTrue: [\r            matchingYears add: year\r        ].\r    ].\r    ^matchingYears asArray\r\rDate yearsWithMatchingEasterFrom: 2000 to: 2050. "#(2001 2004 2007 2010 2011 2014 2017 2025 2028 2031 2034 2037 2038 2041 2045 2048)"\r\r" ------ РЕКУРСІЯ\r  Додайте до класу Integer і випробуйте різні методи обчислення чисел  Фібоначчі.\r  Запропонуйте власні. Порівняйте їхню ефективність.      \r  Перед випробуванням fibonacci ЗБЕРЕЖІТЬ ІМІДЖ СИСТЕМИ! Він може зайняти Ваш комп на тиждень.  "\r\r3 fibStart: 1 with: 10  "<-- 12"\r4 fibo "<-- 5"\r12 fibonacci "<-- 233"\r\r\r"\r==============\rВласні методи:\r==============\r\r- Метод 1:\rInteger >> factorial\r    ""Обчислення факторіалу числа""\r    ^ self <= 1 ifTrue: [1] ifFalse: [self * (self - 1) factorial].\r\r- Метод 2:\rInteger >> sumTo\r    ""Сума всіх чисел від 1 до self""\r    | sum i |\r    sum := 0.\r    1 to: self do: [:i | sum := sum + i].\r    ^ sum.\r"\r\r"\rПояснення: <fibStart:with:>\rРекурсивний метод, який обчислює n-те число Фібоначчі, використовуючи два акумулятори: n1 (попереднє) і n2 (пред-попереднє).\rРекурсія: (self - 1) fibStart: n1+n2 with: n1 → наступний крок отримує нове попереднє число як суму двох попередніх.\r\rДуже швидкий для будь-якого n, навіть великого. Не обчислює одні й ті ж значення повторно → O(n). \rПам’яті потрібно лише для стеку рекурсії (глибина n).\r\rПояснення: <fibo>\rПроста обгортка над <fibStart:with:.>\r\rПовністю така ж, як у fibStart:with:. Зручно викликати без ручного передавання початкових чисел.\r\rПояснення: <fibonacci>\rКласична рекурсія: F(n) = F(n-1) + F(n-2).\r\rДуже повільний для великих n. Обчислює одні й ті ж значення багато разів → експоненційна складність O(2ⁿ). \rМоже сильно навантажити процесор і стек викликів.\r"\r\r"------------------------------------------------------------------------------------\r ------ СТВОРЕННЯ, ОПРАЦЮВАННЯ КОЛЕКЦІЙ\r  У текстовому файлі записано інформацію про матрицю цілих чисел: розміри\r  матриці в першому рядку файла, у всіх наступних рядках - рядки матриці.}\r  Прочитати матрицю, знайти максимальні елементи кожного рядка і зберегти\r  їх у файлі. Надрукувати максимальний елемент цілої матриці."\r\r"Наведений нижче код можна виконати безпосередньо в робочому вікні,\r проте,  доцільно зробити його методом власного навчального класу."\r\r| matr fStream fName n m mMatr mLines |\r        "Вибір файла за допомогою діалогу"\r    (fName:=UIManager default\r\t\t\tchooseFullFileNameMatching: nil \r\t\t\tlabel: \'Виберіть файл з числовими даними\' ) isNil\r        ifTrue: [ ^\'Ви не вибрали файла\' ]. \r        fStream := fName asFileReference readStream.\r\t        "Введення даних"\r \t    n := Integer readFrom: fStream.  \r\t    matr := Array new: n.\r\t    m := Integer readFrom: fStream.\r\t    matr := matr collect: [ :x | Array new: m ]. \r\t    1 to: n do: [ :i |  fStream nextLine.\r \t\t     matr at: i put: (\r\t\t\t\t (matr at: i) collect: [ :x |  \r\t\t\t\t\t\tInteger readFrom: fStream. ]\r\t\t\t\t\t )\t ].\r    fStream close. matr inspect.\r        "Обчислення максимальних елементів"\r    mLines:=matr collect: [ :r | r inject: (r at: 1) into: [ :x :y | x max: y] ].\r    mMatr:=mLines at: 1.\r    mLines do: [ :x | x > mMatr ifTrue: [ mMatr := x ] ].\r        "Побудова імені файла результатів, збереження"\r    fName at: fName size - 4 put: $_ .\r    fStream := fName asFileReference writeStream.\r    mLines do: [ :x | x printOn: fStream. fStream cr ].\r    fStream close.\r    ^mMatr .  \r\r" Поясніть код, наведений вище (кожне повідомлення!):\r\r\t| matr fStream fName n m mMatr mLines | <-- Локальні змінні\r\r\tВідкриваємо діалог вибору файлу. Якщо користувач не вибрав файл – повертаємо повідомлення:\r\t(fName := UIManager default\r\t    chooseFullFileNameMatching: nil\r\t    label: \'Виберіть файл з числовими даними\') isNil\r\t    ifTrue: [ ^\'Ви не вибрали файла\' ].\r\r\tfStream := fName asFileReference readStream. Відкривається потік для читання файлу\r\tn := Integer readFrom: fStream. Читається перше число з файлу(кількість рядків матриці)\r\tmatr := Array new: n. Тут створюється масив для рядків матриці:\r\tm := Integer readFrom: fStream. Тут читається друге число з файлу(кількість стовпців матриці)\r\tmatr := matr collect: [:x | Array new: m]. Тут заповнюється кожен рядок новим масивом стовпців\r\r\tfStream close. Тут закривається потік після читання\r\tmatr inspect. Тут відкривається інспектор для перегляду матриці\r\tinject використовується для проходження елементів\r\tфункція x max y повертає більший елемент\r\tmLines := matr collect: [:r | r inject: (r at: 1) into: [:x :y | x max: y]].\r\r\t\r\tпроходимо по максимумам рядків і оновлюємо mMatr:\r\tmMatr := mLines at: 1.\r\tmLines do: [:x | x > mMatr ifTrue: [ mMatr := x ]].\r\r\tfName at: fName size - 4 put: $_. Ось тут ми змінюємо розширення файлу для збереження результатів.\r\tfStream := fName asFileReference writeStream. <-- Відкриваємо потік для запису у файл\r\tmLines do: [:x | x printOn: fStream. fStream cr]. <-- Записуємо максимуми рядків у файл, кожен на новий рядок\r\tfStream close. <-- Закриваємо файл після запису\r\t^ mMatr. <-- Повертаємо максимальний елемент всієї матриці\r\r   Як замінити масивмасивів на екземпляр класу Matrix?:\r\tMatrix замінює масив масивів, тобто ми маємо одну структуру n × m. До елементів доступ через at: i at: j.\r\tЦе дозволяє компактно читати дані з файлу, знаходити максимуми і записувати результати, не створюючи додаткових масивів рядків:\r\t\r\t| matr fStream n m mMatr |\r\r\tВідкриваємо файл та читаємо розміри:\r\tfStream := \'file.txt\' asFileReference readStream.\r\tn := Integer readFrom: fStream.\r\tm := Integer readFrom: fStream.\r\r\tСтворюємо і заповнюємо матрицю:\r\tmatr := Matrix rows: n columns: m.\r\t1 to: n do: [:i | 1 to: m do: [:j | matr at: i at: j put: Integer readFrom: fStream]].\r\tfStream close.\r\r\tЗнаходимо загальний максимум:\r\tmMatr := (1 to: n) inject: 0 into: [:maxRow :i | maxRow max: ((1 to: m) inject: 0 into: [:maxCol :j | maxCol max: (matr at: i at: j)])].\r\t^ mMatr.\r\r======================================================\r\r ------ АДРЕСНА КНИГА\r Приклад створення і використання адресної книги, описаний у одній з лекцій. \r Пригадуєте, спочатку оголошуємо глобальну змінну, що міститиме впорядковану \r колекцію масивів з трьох рядків. Спосіб порівняння описує бінарний блок.    "\r\r    Smalltalk globals at: #AddressBook\r              put:(SortedCollection sortBlock:[:a :b | (a at:1)<=(b at:1)]).\r\r" * --- Тепер до книги можна додавати записи. "\r\r    AddressBook\r            add: #(\'Ruth\' \'Babe\' \'456 Mudville Flats\');\r            add: #(\'Smith\' \'John\' \'12/5 Park Ave\');\r            add: #(\'Jexon\' \'John\' \'5 Baverli Hills\');\r            add: #(\'Adams\' \'John\' \'1 Hell str\');\r            add: #(\'Taylor\' \'Babe\' \'2a/35 Deribas str\');\r            add: #(\'Greg\' \'Voss\' \'12345 the USA\')."<-- #(\'Greg\' \'Voss\' \'12345 the USA\')"\r\r" * --- Додайте власні записи. Видрукуйте вміст книги (код запропоновано нижче)."\r   | s w |  s := WriteStream on: String new.\r\r    AddressBook do:[:x | x do:\r        [ :y | s nextPutAll: y; tab; tab.].\r        s cr. ]. \r\tAddressBook\r    add: #(\'Brown\' \'Alice\' \'7 Cherry Lane\');\r    add: #(\'White\' \'Bob\' \'15 Oak Street\');\r    add: #(\'Green\' \'Clara\' \'9 Pine Avenue\').\r\r\t  \r\ts := WriteStream on: String new.\r\tAddressBook do: [ :x | x do: [ :y | s nextPutAll: y; tab; tab. ] ] \r\t\r\t\r  w := Workspace openLabel: \'My Address Book\'.\r  w contents: s contents.\r\r" * ----  Наступне завдання - надрукувати список прізвищ людей з однаковими іменами. \r              Приклад демонструє різні способи перебору та перетворення колекцій."\r\r | firstNames duplicates |\r    firstNames:=Bag new.       \r    AddressBook do: [ :entry | firstNames add: (entry at: 2) ]. \r\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r        \r    duplicates:=firstNames select:\r        [ :name | (firstNames occurrencesOf: name)>1 ].\r    duplicates do: [ :first | first printOn: Transcript. Transcript show:\'==>\'.\r        AddressBook do: [ :entry | (entry at: 2)=first\r            ifTrue: [ Transcript show:\' \'. (entry at: 1) printOn: Transcript ] ].\r        Transcript cr ]. Transcript show:\' \'.\r\r" Поясніть перетворення, що відбуваються в цьому фрагменті:\r\tBag — зберігає елементи з повтореннями.\r\tselect: — фільтрує колекцію, залишаючи тільки елементи, що задовольняють умові (тут, occurrencesOf: > 1).\r\tasSet — видаляє дублікати після фільтрації.\r\tasSortedCollection — сортує результати для зручного виводу.\r\tdo — ітерує колекцію і виконує дію (друк у Transcript).\r\r   Запропонуйте власні варіанти використання та перетворення колекцій. \r \r  Оформіть запропоновані вище фрагменти як методи навчального класу:\r\tObject subclass: #AddressBookUtils\r    \tinstanceVariableNames: \'\'\r    \tclassVariableNames: \'\'\r    \tpoolDictionaries: \'\'\r    \tcategory: \'Training-Examples\'.\r\r"\r\r\r" ------ ДОДАВАННЯ АДРЕС\r  Можливо, додавання записів до AddressBook за допомогою явного програмування \r  виглядає не надто привабливо. Використайте з цією метою діалоги "\r\r| a b c | \ra := UIManager default request: \'Input first name\'.\rb := UIManager default request: \'Input second name\'.\rc := UIManager default request: \'Input address\'.\ra isNil | b isNil | c isNil ifFalse: [ AddressBook add: (Array with:a with:b with:c)]. \r\r" Додайте до книги декілька нових записів, знову видрукуйте її. "\r"Через це в книзі так багато записів:"\r[\r    | a b c |\r    a := UIManager default request: \'Input first name\'.\r    a isNil ifTrue: [ ^self ].  \r\r    b := UIManager default request: \'Input second name\'.\r    b isNil ifTrue: [ ^self ].\r\r    c := UIManager default request: \'Input address\'.\r    c isNil ifTrue: [ ^self ].\r\r    AddressBook add: (Array with: a with: b with: c).\r] repeat.\r\r\ts := WriteStream on: String new.\r\tAddressBook do: [ :x | x do: [ :y | s nextPutAll: y; tab; tab. ] ]\r\r" Поміркуйте, як зробити зручнішим звертання до діалогу додавання адрес та друку адресної книги. "\r\r" Що станеться, якщо виконати наступний код? Випробуйте. "\r    Smalltalk globals removeKey:#AddressBook. "<-- з глобального словника Smalltalk globals буде видалено ключ #AddressBook і, відповідно, саму твою колекцію (адресну книгу)."\r\r "------ ПЕРЕТВОРЕННЯ (ПЕРЕВТІЛЕННЯ) ОБ\'ЄКТІВ\r   Виконайте за допомогою Do It. "\r\r | a b c|\r    a := OrderedCollection new.\r    b := Cylinder new.\r    c := Array with: a with: b with: b.\r    Transcript show: \'Old Array is = \'.\r    c do: [ :x | Transcript show: \'     \'. x printOn: Transcript ].\r    Transcript cr.\r    a become: b.\r    Transcript show: \'New Array is = \'.\r    c do: [ :x | Transcript show: \'     \'. x printOn: Transcript ].\r    Transcript cr; show:\' \'. "<-- Unknown variable"\r\r" Поясніть дію методу become:. Чи можна замість нього користуватися звичайним присвоєнням? Наведіть власні приклади. "\r\r" Він міняє всі посилання на два об’єкти місцями у всій системі.  \r  Не можна замість become використовувати звичайне присвоєння, адже такого ефекту не можливо буде досягнути."\r\r\r\r\r\r\r\r'
}OmEntry {
	#tags : {
		#timestamp : DateAndTime [ '2025-10-05T00:00:09.83+03:00' ],
		#self : OmReference [ '20' ]
	},
	#content : '"--------------------------------------------------------------------------------------\r*                      ЛАБОРОТОРНА РОБОТА 3\r*                 Тема: КЛАСИ ТА МЕТОДИ. КОЛЕКЦІЇ\r*\r*  Завдання до лабораторної роботи:\r*     1. Виконайте наведені нижче приклади, збережіть і поясніть отримані результати.\r*     2. Випробуйте різноманітні способи додавання нових класів до системи.\r*     3. Навчіться доповнювати функціональність класів.\r*     4. Випробуйте методи опрацювання колекцій.\r*\r\r    Виконайте за допомогою <Print it> \r\r ------ ПРИНАЛЕЖНІСТЬ КЛАСОВІ, ІЄРАРХІЯ КЛАСІВ\r"\r    #(Francesca Jackie Marisa Bree) class. "Array"\r    (#(Francesca Jackie Marisa Bree) at:2) class. "ByteSymbol"\r    \'Rakesh Vijay Charles Daniel Tyler\' class. "ByteString"\r    (\'Rakesh Vijay Charles Daniel Tyler\' at:2) class. "Character (a)"\r    World class . "WorldMorph"\r    Magnitude class. "Magnitude class"\r    Magnitude class class. "Metaclass"\r    nil class. "UndefinedObject"\r    5 species. "SmallInteger"\r    123456789000 species. "SmallInteger"\r    #aName species. "ByteString"\r " Яка різниця між повідомленнями class i species ? \r\r    Випробуйте різні способи відкривання браузера класів: за допомогою меню чи програмно \r     Виконайте за допомогою <Do it>\r"\r    ClyFullBrowserMorph open. \r    ClyFullBrowserMorph openOnClass: Date. \r    ClyFullBrowserMorph openOnClass: VolumeShape  selector:  #volume. \r\r" ------ МЕТОДИ КЛАСУ, КОНСТРУКТОРИ\r  Виконайте за допомогою <Print It>. Запропонуйте власні приклади. "\r\r    Array new: 10. "#(nil nil nil nil nil nil nil nil nil nil)"        \r    OrderedCollection  new. "an OrderedCollection()"\r    Date today. "29 September 2025"\r    Time now. "10:28:52.422 am"\r    UIManager default  request:\'How are you?\' initialAnswer:\'I\'\'m fine!\'. "\'I\'\'m fine!\'"\r    Integer readFrom: \'2013  1925\'. "2013"\r    Integer primesUpTo: 100. "#(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97)"\r    Rectangle origin:0@0 corner:200@100. "(0@0) corner: (200@100)"\r    Date nameOfMonth:12. "#December"\r    Date dayOfWeek: #Friday. "6"\r    Date orthodoxEasterDateFor: 2022. "24 April 2022"\r\r\r   \r"Інсталюйте вказані нижче МЕТОДИ КЛАСУ Date:\r  перенесіть копію тексту визначення методу з робочого вікна в браузер класів.\r\r""!Date class methodsFor: \'specific inquiries\' stamp: \'CamilloBruni 8/22/2013 19:47\'!""\r\rorthodoxEasterDateFor: year\r ""  compute the easter date according to the rules of the orthodox calendar.\r    source:       http://www.smart.net/~mmontes/ortheast.html   ""\r     | r1 r2 r3 r4 ra rb r5 rc date |\r\r    r1 := year \\\\ 19.\r    r2 := year \\\\ 4.\r    r3 := year \\\\ 7.\r    ra := 19*r1 + 16.\r    r4 := ra \\\\ 30.\r    rb := r2 + r2 + (4*r3) + (6*r4).\r    r5 := rb \\\\ 7.\r    rc := r4 + r5.\r    date := self year: year month: 4 day: 3.\r    ^date addDays: rc.\r""--------------------------------------------------------------------------------------""\r""!Date class methodsFor: \'specific inquiries\' stamp: \'CamilloBruni 8/22/2013 19:48\'!""\r\reasterDateFor: year\r ""  compute the easter date.\r    source: Physikalisch-Technische Bundesanstalt Braunschweig.\r    Lichtenberg, H.: Zur Interpretation der Gaussschen Osterformel und ihrer Ausnahmeregeln, Historia Mathematica 24 (1997), pp. 441-444\r      http://www.ptb.de/de/org/4/44/441/oste.htm  ""\r\r  | k m s a d r og sz oe day |\r\r  k := year // 100.\r  m := 15 + (3*k + 3//4) - (8*k + 13//25).\r   s := 2 - (3*k + 3// 4).\r  a := year \\\\ 19.\r  d := 19*a + m \\\\ 30.\r  r := d//29 + ((d//28) - (d//29)* (a// 11)).\r\r  og := 21 + d - r.\r  sz := 7 - (year//4 + year + s\\\\7).\r  oe := 7 - (og - sz\\\\7).\r  day := og + oe.\r  ^day <= 31\r    ifTrue: [ Date year: year month: 3 day: day ]\r    ifFalse: [ Date year: year month: 4 day: day - 31 ].\r"\r\r"Знайдіть роки, коли святкування припадають на один день."\r\ryearsWithMatchingEasterFrom: startYear to: endYear\r\r    | matchingYears orthodoxDate catholicDate |\r    matchingYears := OrderedCollection new.\r    (startYear to: endYear) do: [:year |\r        orthodoxDate := self orthodoxEasterDateFor: year.\r        catholicDate := self easterDateFor: year.\r        (orthodoxDate = catholicDate) ifTrue: [\r            matchingYears add: year\r        ].\r    ].\r    ^matchingYears asArray\r\rDate yearsWithMatchingEasterFrom: 2000 to: 2050. "#(2001 2004 2007 2010 2011 2014 2017 2025 2028 2031 2034 2037 2038 2041 2045 2048)"\r\r" ------ РЕКУРСІЯ\r  Додайте до класу Integer і випробуйте різні методи обчислення чисел  Фібоначчі.\r  Запропонуйте власні. Порівняйте їхню ефективність.      \r  Перед випробуванням fibonacci ЗБЕРЕЖІТЬ ІМІДЖ СИСТЕМИ! Він може зайняти Ваш комп на тиждень.  "\r\r3 fibStart: 1 with: 10  "<-- 12"\r4 fibo "<-- 5"\r12 fibonacci "<-- 233"\r\r\r"\r==============\rВласні методи:\r==============\r\r- Метод 1:\rInteger >> factorial\r    ""Обчислення факторіалу числа""\r    ^ self <= 1 ifTrue: [1] ifFalse: [self * (self - 1) factorial].\r\r- Метод 2:\rInteger >> sumTo\r    ""Сума всіх чисел від 1 до self""\r    | sum i |\r    sum := 0.\r    1 to: self do: [:i | sum := sum + i].\r    ^ sum.\r"\r\r"\rПояснення: <fibStart:with:>\rРекурсивний метод, який обчислює n-те число Фібоначчі, використовуючи два акумулятори: n1 (попереднє) і n2 (пред-попереднє).\rРекурсія: (self - 1) fibStart: n1+n2 with: n1 → наступний крок отримує нове попереднє число як суму двох попередніх.\r\rДуже швидкий для будь-якого n, навіть великого. Не обчислює одні й ті ж значення повторно → O(n). \rПам’яті потрібно лише для стеку рекурсії (глибина n).\r\rПояснення: <fibo>\rПроста обгортка над <fibStart:with:.>\r\rПовністю така ж, як у fibStart:with:. Зручно викликати без ручного передавання початкових чисел.\r\rПояснення: <fibonacci>\rКласична рекурсія: F(n) = F(n-1) + F(n-2).\r\rДуже повільний для великих n. Обчислює одні й ті ж значення багато разів → експоненційна складність O(2ⁿ). \rМоже сильно навантажити процесор і стек викликів.\r"\r\r"------------------------------------------------------------------------------------\r ------ СТВОРЕННЯ, ОПРАЦЮВАННЯ КОЛЕКЦІЙ\r  У текстовому файлі записано інформацію про матрицю цілих чисел: розміри\r  матриці в першому рядку файла, у всіх наступних рядках - рядки матриці.}\r  Прочитати матрицю, знайти максимальні елементи кожного рядка і зберегти\r  їх у файлі. Надрукувати максимальний елемент цілої матриці."\r\r"Наведений нижче код можна виконати безпосередньо в робочому вікні,\r проте,  доцільно зробити його методом власного навчального класу."\r\r| matr fStream fName n m mMatr mLines |\r        "Вибір файла за допомогою діалогу"\r    (fName:=UIManager default\r\t\t\tchooseFullFileNameMatching: nil \r\t\t\tlabel: \'Виберіть файл з числовими даними\' ) isNil\r        ifTrue: [ ^\'Ви не вибрали файла\' ]. \r        fStream := fName asFileReference readStream.\r\t        "Введення даних"\r \t    n := Integer readFrom: fStream.  \r\t    matr := Array new: n.\r\t    m := Integer readFrom: fStream.\r\t    matr := matr collect: [ :x | Array new: m ]. \r\t    1 to: n do: [ :i |  fStream nextLine.\r \t\t     matr at: i put: (\r\t\t\t\t (matr at: i) collect: [ :x |  \r\t\t\t\t\t\tInteger readFrom: fStream. ]\r\t\t\t\t\t )\t ].\r    fStream close. matr inspect.\r        "Обчислення максимальних елементів"\r    mLines:=matr collect: [ :r | r inject: (r at: 1) into: [ :x :y | x max: y] ].\r    mMatr:=mLines at: 1.\r    mLines do: [ :x | x > mMatr ifTrue: [ mMatr := x ] ].\r        "Побудова імені файла результатів, збереження"\r    fName at: fName size - 4 put: $_ .\r    fStream := fName asFileReference writeStream.\r    mLines do: [ :x | x printOn: fStream. fStream cr ].\r    fStream close.\r    ^mMatr .  \r\r" Поясніть код, наведений вище (кожне повідомлення!):\r\r\tУ цьому коді ми працюємо з матрицею чисел, зчитаною з файлу. Спершу оголошуємо локальні змінні для зберігання самої матриці, потоку файлу, імені файлу, кількості рядків і стовпців, а також для проміжних результатів. Далі відкривається діалог для вибору файлу користувачем. Якщо файл не обрано, метод одразу повертає повідомлення про це і подальше виконання коду зупиняється.\r\rПісля цього створюється потік для читання файлу. Перше число з файлу визначає кількість рядків матриці, а друге число — кількість стовпців. У початковій версії матриця реалізується як масив масивів: спершу створюємо масив для рядків, а потім кожен рядок заповнюємо окремим масивом стовпців. Потік закривається після зчитування даних, і відкривається інспектор для перегляду структури матриці.\r\rЩоб знайти максимуми рядків, кожен рядок обробляється за допомогою методу inject, який проходить усі елементи рядка і визначає найбільше значення. Потім, перебираючи всі максимуми рядків, знаходиться загальний максимум усієї матриці. Після обробки результатів ім’я файлу змінюється для збереження результатів у новий файл, відкривається потік на запис, і кожен максимум рядка записується в файл на окремий рядок. Потім потік закривається. Нарешті, метод повертає максимальний елемент усієї матриці.\r\rЯкщо використовувати клас Matrix, код можна зробити більш компактним і зручним. Клас Matrix зберігає матрицю як єдину структуру n × m, і доступ до елементів відбувається через at: i at: j, що виключає необхідність створювати масив масивів. Спочатку відкриваємо потік для читання файлу і зчитуємо розміри матриці. Потім створюємо об’єкт Matrix відповідного розміру і заповнюємо його числами з файлу. Далі, перебираючи рядки та стовпці, за допомогою вкладених inject визначаємо максимальні значення для кожного рядка та загальний максимум матриці. Результат повертається як вихідний максимум. Такий підхід дозволяє робити код більш структурованим і компактним, позбавляє зайвих проміжних масивів і робить роботу з матрицею наочнішою.\r\r   Як замінити масивмасивів на екземпляр класу Matrix?:\r\tMatrix замінює масив масивів, тобто ми маємо одну структуру n × m. До елементів доступ через at: i at: j.\r\tЦе дозволяє компактно читати дані з файлу, знаходити максимуми і записувати результати, не створюючи додаткових масивів рядків:\r\t\r\t| matr fStream n m mMatr |\r\r\tВідкриваємо файл та читаємо розміри:\r\tfStream := \'file.txt\' asFileReference readStream.\r\tn := Integer readFrom: fStream.\r\tm := Integer readFrom: fStream.\r\r\tСтворюємо і заповнюємо матрицю:\r\tmatr := Matrix rows: n columns: m.\r\t1 to: n do: [:i | 1 to: m do: [:j | matr at: i at: j put: Integer readFrom: fStream]].\r\tfStream close.\r\r\tЗнаходимо загальний максимум:\r\tmMatr := (1 to: n) inject: 0 into: [:maxRow :i | maxRow max: ((1 to: m) inject: 0 into: [:maxCol :j | maxCol max: (matr at: i at: j)])].\r\t^ mMatr.\r\r======================================================\r\r ------ АДРЕСНА КНИГА\r Приклад створення і використання адресної книги, описаний у одній з лекцій. \r Пригадуєте, спочатку оголошуємо глобальну змінну, що міститиме впорядковану \r колекцію масивів з трьох рядків. Спосіб порівняння описує бінарний блок.    "\r\r    Smalltalk globals at: #AddressBook\r              put:(SortedCollection sortBlock:[:a :b | (a at:1)<=(b at:1)]).\r\r" * --- Тепер до книги можна додавати записи. "\r\r    AddressBook\r            add: #(\'Ruth\' \'Babe\' \'456 Mudville Flats\');\r            add: #(\'Smith\' \'John\' \'12/5 Park Ave\');\r            add: #(\'Jexon\' \'John\' \'5 Baverli Hills\');\r            add: #(\'Adams\' \'John\' \'1 Hell str\');\r            add: #(\'Taylor\' \'Babe\' \'2a/35 Deribas str\');\r            add: #(\'Greg\' \'Voss\' \'12345 the USA\')."<-- #(\'Greg\' \'Voss\' \'12345 the USA\')"\r\r" * --- Додайте власні записи. Видрукуйте вміст книги (код запропоновано нижче)."\r   | s w |  s := WriteStream on: String new.\r\r    AddressBook do:[:x | x do:\r        [ :y | s nextPutAll: y; tab; tab.].\r        s cr. ]. \r\tAddressBook\r    add: #(\'Brown\' \'Alice\' \'7 Cherry Lane\');\r    add: #(\'White\' \'Bob\' \'15 Oak Street\');\r    add: #(\'Green\' \'Clara\' \'9 Pine Avenue\').\r\r\t  \r\ts := WriteStream on: String new.\r\tAddressBook do: [ :x | x do: [ :y | s nextPutAll: y; tab; tab. ] ] \r\t\r\t\r  w := Workspace openLabel: \'My Address Book\'.\r  w contents: s contents.\r\r" * ----  Наступне завдання - надрукувати список прізвищ людей з однаковими іменами. \r              Приклад демонструє різні способи перебору та перетворення колекцій."\r\r | firstNames duplicates |\r    firstNames:=Bag new.       \r    AddressBook do: [ :entry | firstNames add: (entry at: 2) ]. \r\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r        \r    duplicates:=firstNames select:\r        [ :name | (firstNames occurrencesOf: name)>1 ].\r    duplicates do: [ :first | first printOn: Transcript. Transcript show:\'==>\'.\r        AddressBook do: [ :entry | (entry at: 2)=first\r            ifTrue: [ Transcript show:\' \'. (entry at: 1) printOn: Transcript ] ].\r        Transcript cr ]. Transcript show:\' \'.\r\r" Поясніть перетворення, що відбуваються в цьому фрагменті:\r\tBag — зберігає елементи з повтореннями.\r\tselect: — фільтрує колекцію, залишаючи тільки елементи, що задовольняють умові (тут, occurrencesOf: > 1).\r\tasSet — видаляє дублікати після фільтрації.\r\tasSortedCollection — сортує результати для зручного виводу.\r\tdo — ітерує колекцію і виконує дію (друк у Transcript).\r\r   Запропонуйте власні варіанти використання та перетворення колекцій. \r \r  Оформіть запропоновані вище фрагменти як методи навчального класу:\r\tObject subclass: #AddressBookUtils\r    \tinstanceVariableNames: \'\'\r    \tclassVariableNames: \'\'\r    \tpoolDictionaries: \'\'\r    \tcategory: \'Training-Examples\'.\r\r"\r\r\r" ------ ДОДАВАННЯ АДРЕС\r  Можливо, додавання записів до AddressBook за допомогою явного програмування \r  виглядає не надто привабливо. Використайте з цією метою діалоги "\r\r| a b c | \ra := UIManager default request: \'Input first name\'.\rb := UIManager default request: \'Input second name\'.\rc := UIManager default request: \'Input address\'.\ra isNil | b isNil | c isNil ifFalse: [ AddressBook add: (Array with:a with:b with:c)]. \r\r" Додайте до книги декілька нових записів, знову видрукуйте її. "\r"Через це в книзі так багато записів:"\r[\r    | a b c |\r    a := UIManager default request: \'Input first name\'.\r    a isNil ifTrue: [ ^self ].  \r\r    b := UIManager default request: \'Input second name\'.\r    b isNil ifTrue: [ ^self ].\r\r    c := UIManager default request: \'Input address\'.\r    c isNil ifTrue: [ ^self ].\r\r    AddressBook add: (Array with: a with: b with: c).\r] repeat.\r\r\ts := WriteStream on: String new.\r\tAddressBook do: [ :x | x do: [ :y | s nextPutAll: y; tab; tab. ] ]\r\r" Поміркуйте, як зробити зручнішим звертання до діалогу додавання адрес та друку адресної книги. "\r\r" Що станеться, якщо виконати наступний код? Випробуйте. "\r    Smalltalk globals removeKey:#AddressBook. "<-- з глобального словника Smalltalk globals буде видалено ключ #AddressBook і, відповідно, саму твою колекцію (адресну книгу)."\r\r "------ ПЕРЕТВОРЕННЯ (ПЕРЕВТІЛЕННЯ) ОБ\'ЄКТІВ\r   Виконайте за допомогою Do It. "\r\r | a b c|\r    a := OrderedCollection new.\r    b := Cylinder new.\r    c := Array with: a with: b with: b.\r    Transcript show: \'Old Array is = \'.\r    c do: [ :x | Transcript show: \'     \'. x printOn: Transcript ].\r    Transcript cr.\r    a become: b.\r    Transcript show: \'New Array is = \'.\r    c do: [ :x | Transcript show: \'     \'. x printOn: Transcript ].\r    Transcript cr; show:\' \'. "<-- Unknown variable"\r\r" Поясніть дію методу become:. Чи можна замість нього користуватися звичайним присвоєнням? Наведіть власні приклади. "\r\r" Він міняє всі посилання на два об’єкти місцями у всій системі.  \r  Не можна замість become використовувати звичайне присвоєння, адже такого ефекту не можливо буде досягнути."\r\r\r\r\r\r\r\r'
}OmEntry {
	#tags : {
		#timestamp : DateAndTime [ '2025-10-05T00:01:03.224+03:00' ],
		#self : OmReference [ '21' ]
	},
	#content : '"--------------------------------------------------------------------------------------\r*                      ЛАБОРОТОРНА РОБОТА 3\r*                 Тема: КЛАСИ ТА МЕТОДИ. КОЛЕКЦІЇ\r*\r*  Завдання до лабораторної роботи:\r*     1. Виконайте наведені нижче приклади, збережіть і поясніть отримані результати.\r*     2. Випробуйте різноманітні способи додавання нових класів до системи.\r*     3. Навчіться доповнювати функціональність класів.\r*     4. Випробуйте методи опрацювання колекцій.\r*\r\r    Виконайте за допомогою <Print it> \r\r ------ ПРИНАЛЕЖНІСТЬ КЛАСОВІ, ІЄРАРХІЯ КЛАСІВ\r"\r    #(Francesca Jackie Marisa Bree) class. "Array"\r    (#(Francesca Jackie Marisa Bree) at:2) class. "ByteSymbol"\r    \'Rakesh Vijay Charles Daniel Tyler\' class. "ByteString"\r    (\'Rakesh Vijay Charles Daniel Tyler\' at:2) class. "Character (a)"\r    World class . "WorldMorph"\r    Magnitude class. "Magnitude class"\r    Magnitude class class. "Metaclass"\r    nil class. "UndefinedObject"\r    5 species. "SmallInteger"\r    123456789000 species. "SmallInteger"\r    #aName species. "ByteString"\r " Яка різниця між повідомленнями class i species ? \r\r    Випробуйте різні способи відкривання браузера класів: за допомогою меню чи програмно \r     Виконайте за допомогою <Do it>\r"\r    ClyFullBrowserMorph open. \r    ClyFullBrowserMorph openOnClass: Date. \r    ClyFullBrowserMorph openOnClass: VolumeShape  selector:  #volume. \r\r" ------ МЕТОДИ КЛАСУ, КОНСТРУКТОРИ\r  Виконайте за допомогою <Print It>. Запропонуйте власні приклади. "\r\r    Array new: 10. "#(nil nil nil nil nil nil nil nil nil nil)"        \r    OrderedCollection  new. "an OrderedCollection()"\r    Date today. "29 September 2025"\r    Time now. "10:28:52.422 am"\r    UIManager default  request:\'How are you?\' initialAnswer:\'I\'\'m fine!\'. "\'I\'\'m fine!\'"\r    Integer readFrom: \'2013  1925\'. "2013"\r    Integer primesUpTo: 100. "#(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97)"\r    Rectangle origin:0@0 corner:200@100. "(0@0) corner: (200@100)"\r    Date nameOfMonth:12. "#December"\r    Date dayOfWeek: #Friday. "6"\r    Date orthodoxEasterDateFor: 2022. "24 April 2022"\r\r\r   \r"Інсталюйте вказані нижче МЕТОДИ КЛАСУ Date:\r  перенесіть копію тексту визначення методу з робочого вікна в браузер класів.\r\r""!Date class methodsFor: \'specific inquiries\' stamp: \'CamilloBruni 8/22/2013 19:47\'!""\r\rorthodoxEasterDateFor: year\r ""  compute the easter date according to the rules of the orthodox calendar.\r    source:       http://www.smart.net/~mmontes/ortheast.html   ""\r     | r1 r2 r3 r4 ra rb r5 rc date |\r\r    r1 := year \\\\ 19.\r    r2 := year \\\\ 4.\r    r3 := year \\\\ 7.\r    ra := 19*r1 + 16.\r    r4 := ra \\\\ 30.\r    rb := r2 + r2 + (4*r3) + (6*r4).\r    r5 := rb \\\\ 7.\r    rc := r4 + r5.\r    date := self year: year month: 4 day: 3.\r    ^date addDays: rc.\r""--------------------------------------------------------------------------------------""\r""!Date class methodsFor: \'specific inquiries\' stamp: \'CamilloBruni 8/22/2013 19:48\'!""\r\reasterDateFor: year\r ""  compute the easter date.\r    source: Physikalisch-Technische Bundesanstalt Braunschweig.\r    Lichtenberg, H.: Zur Interpretation der Gaussschen Osterformel und ihrer Ausnahmeregeln, Historia Mathematica 24 (1997), pp. 441-444\r      http://www.ptb.de/de/org/4/44/441/oste.htm  ""\r\r  | k m s a d r og sz oe day |\r\r  k := year // 100.\r  m := 15 + (3*k + 3//4) - (8*k + 13//25).\r   s := 2 - (3*k + 3// 4).\r  a := year \\\\ 19.\r  d := 19*a + m \\\\ 30.\r  r := d//29 + ((d//28) - (d//29)* (a// 11)).\r\r  og := 21 + d - r.\r  sz := 7 - (year//4 + year + s\\\\7).\r  oe := 7 - (og - sz\\\\7).\r  day := og + oe.\r  ^day <= 31\r    ifTrue: [ Date year: year month: 3 day: day ]\r    ifFalse: [ Date year: year month: 4 day: day - 31 ].\r"\r\r"Знайдіть роки, коли святкування припадають на один день."\r\ryearsWithMatchingEasterFrom: startYear to: endYear\r\r    | matchingYears orthodoxDate catholicDate |\r    matchingYears := OrderedCollection new.\r    (startYear to: endYear) do: [:year |\r        orthodoxDate := self orthodoxEasterDateFor: year.\r        catholicDate := self easterDateFor: year.\r        (orthodoxDate = catholicDate) ifTrue: [\r            matchingYears add: year\r        ].\r    ].\r    ^matchingYears asArray\r\rDate yearsWithMatchingEasterFrom: 2000 to: 2050. "#(2001 2004 2007 2010 2011 2014 2017 2025 2028 2031 2034 2037 2038 2041 2045 2048)"\r\r" ------ РЕКУРСІЯ\r  Додайте до класу Integer і випробуйте різні методи обчислення чисел  Фібоначчі.\r  Запропонуйте власні. Порівняйте їхню ефективність.      \r  Перед випробуванням fibonacci ЗБЕРЕЖІТЬ ІМІДЖ СИСТЕМИ! Він може зайняти Ваш комп на тиждень.  "\r\r3 fibStart: 1 with: 10  "<-- 12"\r4 fibo "<-- 5"\r12 fibonacci "<-- 233"\r\r\r"\r==============\rВласні методи:\r==============\r\r- Метод 1:\rInteger >> factorial\r    ""Обчислення факторіалу числа""\r    ^ self <= 1 ifTrue: [1] ifFalse: [self * (self - 1) factorial].\r\r- Метод 2:\rInteger >> sumTo\r    ""Сума всіх чисел від 1 до self""\r    | sum i |\r    sum := 0.\r    1 to: self do: [:i | sum := sum + i].\r    ^ sum.\r"\r\r"\rПояснення: <fibStart:with:>\rРекурсивний метод, який обчислює n-те число Фібоначчі, використовуючи два акумулятори: n1 (попереднє) і n2 (пред-попереднє).\rРекурсія: (self - 1) fibStart: n1+n2 with: n1 → наступний крок отримує нове попереднє число як суму двох попередніх.\r\rДуже швидкий для будь-якого n, навіть великого. Не обчислює одні й ті ж значення повторно → O(n). \rПам’яті потрібно лише для стеку рекурсії (глибина n).\r\rПояснення: <fibo>\rПроста обгортка над <fibStart:with:.>\r\rПовністю така ж, як у fibStart:with:. Зручно викликати без ручного передавання початкових чисел.\r\rПояснення: <fibonacci>\rКласична рекурсія: F(n) = F(n-1) + F(n-2).\r\rДуже повільний для великих n. Обчислює одні й ті ж значення багато разів → експоненційна складність O(2ⁿ). \rМоже сильно навантажити процесор і стек викликів.\r"\r\r"------------------------------------------------------------------------------------\r ------ СТВОРЕННЯ, ОПРАЦЮВАННЯ КОЛЕКЦІЙ\r  У текстовому файлі записано інформацію про матрицю цілих чисел: розміри\r  матриці в першому рядку файла, у всіх наступних рядках - рядки матриці.}\r  Прочитати матрицю, знайти максимальні елементи кожного рядка і зберегти\r  їх у файлі. Надрукувати максимальний елемент цілої матриці."\r\r"Наведений нижче код можна виконати безпосередньо в робочому вікні,\r проте,  доцільно зробити його методом власного навчального класу."\r\r| matr fStream fName n m mMatr mLines |\r        "Вибір файла за допомогою діалогу"\r    (fName:=UIManager default\r\t\t\tchooseFullFileNameMatching: nil \r\t\t\tlabel: \'Виберіть файл з числовими даними\' ) isNil\r        ifTrue: [ ^\'Ви не вибрали файла\' ]. \r        fStream := fName asFileReference readStream.\r\t        "Введення даних"\r \t    n := Integer readFrom: fStream.  \r\t    matr := Array new: n.\r\t    m := Integer readFrom: fStream.\r\t    matr := matr collect: [ :x | Array new: m ]. \r\t    1 to: n do: [ :i |  fStream nextLine.\r \t\t     matr at: i put: (\r\t\t\t\t (matr at: i) collect: [ :x |  \r\t\t\t\t\t\tInteger readFrom: fStream. ]\r\t\t\t\t\t )\t ].\r    fStream close. matr inspect.\r        "Обчислення максимальних елементів"\r    mLines:=matr collect: [ :r | r inject: (r at: 1) into: [ :x :y | x max: y] ].\r    mMatr:=mLines at: 1.\r    mLines do: [ :x | x > mMatr ifTrue: [ mMatr := x ] ].\r        "Побудова імені файла результатів, збереження"\r    fName at: fName size - 4 put: $_ .\r    fStream := fName asFileReference writeStream.\r    mLines do: [ :x | x printOn: fStream. fStream cr ].\r    fStream close.\r    ^mMatr .  \r\r" Поясніть код, наведений вище (кожне повідомлення!):\r\r\tУ цьому коді ми працюємо з матрицею чисел, зчитаною з файлу. Спершу оголошуємо локальні змінні для зберігання самої матриці, потоку файлу, імені файлу, кількості рядків і стовпців, а також для проміжних результатів. Далі відкривається діалог для вибору файлу користувачем. Якщо файл не обрано, метод одразу повертає повідомлення про це і подальше виконання коду зупиняється.\r\rПісля цього створюється потік для читання файлу. Перше число з файлу визначає кількість рядків матриці, а друге число — кількість стовпців. У початковій версії матриця реалізується як масив масивів: спершу створюємо масив для рядків, а потім кожен рядок заповнюємо окремим масивом стовпців. Потік закривається після зчитування даних, і відкривається інспектор для перегляду структури матриці.\r\rЩоб знайти максимуми рядків, кожен рядок обробляється за допомогою методу inject, який проходить усі елементи рядка і визначає найбільше значення. Потім, перебираючи всі максимуми рядків, знаходиться загальний максимум усієї матриці. Після обробки результатів ім’я файлу змінюється для збереження результатів у новий файл, відкривається потік на запис, і кожен максимум рядка записується в файл на окремий рядок. Потім потік закривається. Нарешті, метод повертає максимальний елемент усієї матриці.\r\r   Як можна замінити масив масивів на екземпляр класу Matrix?:\r\tЯкщо використовувати клас Matrix, код можна зробити більш компактним і зручним. Клас Matrix зберігає матрицю як єдину структуру n × m, і доступ до елементів відбувається через at: i at: j, що виключає необхідність створювати масив масивів. Спочатку відкриваємо потік для читання файлу і зчитуємо розміри матриці. Потім створюємо об’єкт Matrix відповідного розміру і заповнюємо його числами з файлу. Далі, перебираючи рядки та стовпці, за допомогою вкладених inject визначаємо максимальні значення для кожного рядка та загальний максимум матриці. Результат повертається як вихідний максимум. Такий підхід дозволяє робити код більш структурованим і компактним, позбавляє зайвих проміжних масивів і робить роботу з матрицею наочнішою.\r======================================================\r\r ------ АДРЕСНА КНИГА\r Приклад створення і використання адресної книги, описаний у одній з лекцій. \r Пригадуєте, спочатку оголошуємо глобальну змінну, що міститиме впорядковану \r колекцію масивів з трьох рядків. Спосіб порівняння описує бінарний блок.    "\r\r    Smalltalk globals at: #AddressBook\r              put:(SortedCollection sortBlock:[:a :b | (a at:1)<=(b at:1)]).\r\r" * --- Тепер до книги можна додавати записи. "\r\r    AddressBook\r            add: #(\'Ruth\' \'Babe\' \'456 Mudville Flats\');\r            add: #(\'Smith\' \'John\' \'12/5 Park Ave\');\r            add: #(\'Jexon\' \'John\' \'5 Baverli Hills\');\r            add: #(\'Adams\' \'John\' \'1 Hell str\');\r            add: #(\'Taylor\' \'Babe\' \'2a/35 Deribas str\');\r            add: #(\'Greg\' \'Voss\' \'12345 the USA\')."<-- #(\'Greg\' \'Voss\' \'12345 the USA\')"\r\r" * --- Додайте власні записи. Видрукуйте вміст книги (код запропоновано нижче)."\r   | s w |  s := WriteStream on: String new.\r\r    AddressBook do:[:x | x do:\r        [ :y | s nextPutAll: y; tab; tab.].\r        s cr. ]. \r\tAddressBook\r    add: #(\'Brown\' \'Alice\' \'7 Cherry Lane\');\r    add: #(\'White\' \'Bob\' \'15 Oak Street\');\r    add: #(\'Green\' \'Clara\' \'9 Pine Avenue\').\r\r\t  \r\ts := WriteStream on: String new.\r\tAddressBook do: [ :x | x do: [ :y | s nextPutAll: y; tab; tab. ] ] \r\t\r\t\r  w := Workspace openLabel: \'My Address Book\'.\r  w contents: s contents.\r\r" * ----  Наступне завдання - надрукувати список прізвищ людей з однаковими іменами. \r              Приклад демонструє різні способи перебору та перетворення колекцій."\r\r | firstNames duplicates |\r    firstNames:=Bag new.       \r    AddressBook do: [ :entry | firstNames add: (entry at: 2) ]. \r\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r        \r    duplicates:=firstNames select:\r        [ :name | (firstNames occurrencesOf: name)>1 ].\r    duplicates do: [ :first | first printOn: Transcript. Transcript show:\'==>\'.\r        AddressBook do: [ :entry | (entry at: 2)=first\r            ifTrue: [ Transcript show:\' \'. (entry at: 1) printOn: Transcript ] ].\r        Transcript cr ]. Transcript show:\' \'.\r\r" Поясніть перетворення, що відбуваються в цьому фрагменті:\r\tBag — зберігає елементи з повтореннями.\r\tselect: — фільтрує колекцію, залишаючи тільки елементи, що задовольняють умові (тут, occurrencesOf: > 1).\r\tasSet — видаляє дублікати після фільтрації.\r\tasSortedCollection — сортує результати для зручного виводу.\r\tdo — ітерує колекцію і виконує дію (друк у Transcript).\r\r   Запропонуйте власні варіанти використання та перетворення колекцій. \r \r  Оформіть запропоновані вище фрагменти як методи навчального класу:\r\tObject subclass: #AddressBookUtils\r    \tinstanceVariableNames: \'\'\r    \tclassVariableNames: \'\'\r    \tpoolDictionaries: \'\'\r    \tcategory: \'Training-Examples\'.\r\r"\r\r\r" ------ ДОДАВАННЯ АДРЕС\r  Можливо, додавання записів до AddressBook за допомогою явного програмування \r  виглядає не надто привабливо. Використайте з цією метою діалоги "\r\r| a b c | \ra := UIManager default request: \'Input first name\'.\rb := UIManager default request: \'Input second name\'.\rc := UIManager default request: \'Input address\'.\ra isNil | b isNil | c isNil ifFalse: [ AddressBook add: (Array with:a with:b with:c)]. \r\r" Додайте до книги декілька нових записів, знову видрукуйте її. "\r"Через це в книзі так багато записів:"\r[\r    | a b c |\r    a := UIManager default request: \'Input first name\'.\r    a isNil ifTrue: [ ^self ].  \r\r    b := UIManager default request: \'Input second name\'.\r    b isNil ifTrue: [ ^self ].\r\r    c := UIManager default request: \'Input address\'.\r    c isNil ifTrue: [ ^self ].\r\r    AddressBook add: (Array with: a with: b with: c).\r] repeat.\r\r\ts := WriteStream on: String new.\r\tAddressBook do: [ :x | x do: [ :y | s nextPutAll: y; tab; tab. ] ]\r\r" Поміркуйте, як зробити зручнішим звертання до діалогу додавання адрес та друку адресної книги. "\r\r" Що станеться, якщо виконати наступний код? Випробуйте. "\r    Smalltalk globals removeKey:#AddressBook. "<-- з глобального словника Smalltalk globals буде видалено ключ #AddressBook і, відповідно, саму твою колекцію (адресну книгу)."\r\r "------ ПЕРЕТВОРЕННЯ (ПЕРЕВТІЛЕННЯ) ОБ\'ЄКТІВ\r   Виконайте за допомогою Do It. "\r\r | a b c|\r    a := OrderedCollection new.\r    b := Cylinder new.\r    c := Array with: a with: b with: b.\r    Transcript show: \'Old Array is = \'.\r    c do: [ :x | Transcript show: \'     \'. x printOn: Transcript ].\r    Transcript cr.\r    a become: b.\r    Transcript show: \'New Array is = \'.\r    c do: [ :x | Transcript show: \'     \'. x printOn: Transcript ].\r    Transcript cr; show:\' \'. "<-- Unknown variable"\r\r" Поясніть дію методу become:. Чи можна замість нього користуватися звичайним присвоєнням? Наведіть власні приклади. "\r\r" Він міняє всі посилання на два об’єкти місцями у всій системі.  \r  Не можна замість become використовувати звичайне присвоєння, адже такого ефекту не можливо буде досягнути."\r\r\r\r\r\r\r\r'
}OmEntry {
	#tags : {
		#timestamp : DateAndTime [ '2025-10-05T00:01:52.022+03:00' ],
		#self : OmReference [ '22' ]
	},
	#content : '"--------------------------------------------------------------------------------------\r*                      ЛАБОРОТОРНА РОБОТА 3\r*                 Тема: КЛАСИ ТА МЕТОДИ. КОЛЕКЦІЇ\r*\r*  Завдання до лабораторної роботи:\r*     1. Виконайте наведені нижче приклади, збережіть і поясніть отримані результати.\r*     2. Випробуйте різноманітні способи додавання нових класів до системи.\r*     3. Навчіться доповнювати функціональність класів.\r*     4. Випробуйте методи опрацювання колекцій.\r*\r\r    Виконайте за допомогою <Print it> \r\r ------ ПРИНАЛЕЖНІСТЬ КЛАСОВІ, ІЄРАРХІЯ КЛАСІВ\r"\r    #(Francesca Jackie Marisa Bree) class. "Array"\r    (#(Francesca Jackie Marisa Bree) at:2) class. "ByteSymbol"\r    \'Rakesh Vijay Charles Daniel Tyler\' class. "ByteString"\r    (\'Rakesh Vijay Charles Daniel Tyler\' at:2) class. "Character (a)"\r    World class . "WorldMorph"\r    Magnitude class. "Magnitude class"\r    Magnitude class class. "Metaclass"\r    nil class. "UndefinedObject"\r    5 species. "SmallInteger"\r    123456789000 species. "SmallInteger"\r    #aName species. "ByteString"\r " Яка різниця між повідомленнями class i species ? \r\r    Випробуйте різні способи відкривання браузера класів: за допомогою меню чи програмно \r     Виконайте за допомогою <Do it>\r"\r    ClyFullBrowserMorph open. \r    ClyFullBrowserMorph openOnClass: Date. \r    ClyFullBrowserMorph openOnClass: VolumeShape  selector:  #volume. \r\r" ------ МЕТОДИ КЛАСУ, КОНСТРУКТОРИ\r  Виконайте за допомогою <Print It>. Запропонуйте власні приклади. "\r\r    Array new: 10. "#(nil nil nil nil nil nil nil nil nil nil)"        \r    OrderedCollection  new. "an OrderedCollection()"\r    Date today. "29 September 2025"\r    Time now. "10:28:52.422 am"\r    UIManager default  request:\'How are you?\' initialAnswer:\'I\'\'m fine!\'. "\'I\'\'m fine!\'"\r    Integer readFrom: \'2013  1925\'. "2013"\r    Integer primesUpTo: 100. "#(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97)"\r    Rectangle origin:0@0 corner:200@100. "(0@0) corner: (200@100)"\r    Date nameOfMonth:12. "#December"\r    Date dayOfWeek: #Friday. "6"\r    Date orthodoxEasterDateFor: 2022. "24 April 2022"\r\r\r   \r"Інсталюйте вказані нижче МЕТОДИ КЛАСУ Date:\r  перенесіть копію тексту визначення методу з робочого вікна в браузер класів.\r\r""!Date class methodsFor: \'specific inquiries\' stamp: \'CamilloBruni 8/22/2013 19:47\'!""\r\rorthodoxEasterDateFor: year\r ""  compute the easter date according to the rules of the orthodox calendar.\r    source:       http://www.smart.net/~mmontes/ortheast.html   ""\r     | r1 r2 r3 r4 ra rb r5 rc date |\r\r    r1 := year \\\\ 19.\r    r2 := year \\\\ 4.\r    r3 := year \\\\ 7.\r    ra := 19*r1 + 16.\r    r4 := ra \\\\ 30.\r    rb := r2 + r2 + (4*r3) + (6*r4).\r    r5 := rb \\\\ 7.\r    rc := r4 + r5.\r    date := self year: year month: 4 day: 3.\r    ^date addDays: rc.\r""--------------------------------------------------------------------------------------""\r""!Date class methodsFor: \'specific inquiries\' stamp: \'CamilloBruni 8/22/2013 19:48\'!""\r\reasterDateFor: year\r ""  compute the easter date.\r    source: Physikalisch-Technische Bundesanstalt Braunschweig.\r    Lichtenberg, H.: Zur Interpretation der Gaussschen Osterformel und ihrer Ausnahmeregeln, Historia Mathematica 24 (1997), pp. 441-444\r      http://www.ptb.de/de/org/4/44/441/oste.htm  ""\r\r  | k m s a d r og sz oe day |\r\r  k := year // 100.\r  m := 15 + (3*k + 3//4) - (8*k + 13//25).\r   s := 2 - (3*k + 3// 4).\r  a := year \\\\ 19.\r  d := 19*a + m \\\\ 30.\r  r := d//29 + ((d//28) - (d//29)* (a// 11)).\r\r  og := 21 + d - r.\r  sz := 7 - (year//4 + year + s\\\\7).\r  oe := 7 - (og - sz\\\\7).\r  day := og + oe.\r  ^day <= 31\r    ifTrue: [ Date year: year month: 3 day: day ]\r    ifFalse: [ Date year: year month: 4 day: day - 31 ].\r"\r\r"Знайдіть роки, коли святкування припадають на один день."\r\ryearsWithMatchingEasterFrom: startYear to: endYear\r\r    | matchingYears orthodoxDate catholicDate |\r    matchingYears := OrderedCollection new.\r    (startYear to: endYear) do: [:year |\r        orthodoxDate := self orthodoxEasterDateFor: year.\r        catholicDate := self easterDateFor: year.\r        (orthodoxDate = catholicDate) ifTrue: [\r            matchingYears add: year\r        ].\r    ].\r    ^matchingYears asArray\r\rDate yearsWithMatchingEasterFrom: 2000 to: 2050. "#(2001 2004 2007 2010 2011 2014 2017 2025 2028 2031 2034 2037 2038 2041 2045 2048)"\r\r" ------ РЕКУРСІЯ\r  Додайте до класу Integer і випробуйте різні методи обчислення чисел  Фібоначчі.\r  Запропонуйте власні. Порівняйте їхню ефективність.      \r  Перед випробуванням fibonacci ЗБЕРЕЖІТЬ ІМІДЖ СИСТЕМИ! Він може зайняти Ваш комп на тиждень.  "\r\r3 fibStart: 1 with: 10  "<-- 12"\r4 fibo "<-- 5"\r12 fibonacci "<-- 233"\r\r\r\r\r\r"\r\r\rПояснення: <fibStart:with:>\rРекурсивний метод, який обчислює n-те число Фібоначчі, використовуючи два акумулятори: n1 (попереднє) і n2 (пред-попереднє).\rРекурсія: (self - 1) fibStart: n1+n2 with: n1 → наступний крок отримує нове попереднє число як суму двох попередніх.\r\rДуже швидкий для будь-якого n, навіть великого. Не обчислює одні й ті ж значення повторно → O(n). \rПам’яті потрібно лише для стеку рекурсії (глибина n).\r\rПояснення: <fibo>\rПроста обгортка над <fibStart:with:.>\r\rПовністю така ж, як у fibStart:with:. Зручно викликати без ручного передавання початкових чисел.\r\rПояснення: <fibonacci>\rКласична рекурсія: F(n) = F(n-1) + F(n-2).\r\rДуже повільний для великих n. Обчислює одні й ті ж значення багато разів → експоненційна складність O(2ⁿ). \rМоже сильно навантажити процесор і стек викликів.\r"\r\r"------------------------------------------------------------------------------------\r ------ СТВОРЕННЯ, ОПРАЦЮВАННЯ КОЛЕКЦІЙ\r  У текстовому файлі записано інформацію про матрицю цілих чисел: розміри\r  матриці в першому рядку файла, у всіх наступних рядках - рядки матриці.}\r  Прочитати матрицю, знайти максимальні елементи кожного рядка і зберегти\r  їх у файлі. Надрукувати максимальний елемент цілої матриці."\r\r"Наведений нижче код можна виконати безпосередньо в робочому вікні,\r проте,  доцільно зробити його методом власного навчального класу."\r\r| matr fStream fName n m mMatr mLines |\r        "Вибір файла за допомогою діалогу"\r    (fName:=UIManager default\r\t\t\tchooseFullFileNameMatching: nil \r\t\t\tlabel: \'Виберіть файл з числовими даними\' ) isNil\r        ifTrue: [ ^\'Ви не вибрали файла\' ]. \r        fStream := fName asFileReference readStream.\r\t        "Введення даних"\r \t    n := Integer readFrom: fStream.  \r\t    matr := Array new: n.\r\t    m := Integer readFrom: fStream.\r\t    matr := matr collect: [ :x | Array new: m ]. \r\t    1 to: n do: [ :i |  fStream nextLine.\r \t\t     matr at: i put: (\r\t\t\t\t (matr at: i) collect: [ :x |  \r\t\t\t\t\t\tInteger readFrom: fStream. ]\r\t\t\t\t\t )\t ].\r    fStream close. matr inspect.\r        "Обчислення максимальних елементів"\r    mLines:=matr collect: [ :r | r inject: (r at: 1) into: [ :x :y | x max: y] ].\r    mMatr:=mLines at: 1.\r    mLines do: [ :x | x > mMatr ifTrue: [ mMatr := x ] ].\r        "Побудова імені файла результатів, збереження"\r    fName at: fName size - 4 put: $_ .\r    fStream := fName asFileReference writeStream.\r    mLines do: [ :x | x printOn: fStream. fStream cr ].\r    fStream close.\r    ^mMatr .  \r\r" Поясніть код, наведений вище (кожне повідомлення!):\r\r\tУ цьому коді ми працюємо з матрицею чисел, зчитаною з файлу. Спершу оголошуємо локальні змінні для зберігання самої матриці, потоку файлу, імені файлу, кількості рядків і стовпців, а також для проміжних результатів. Далі відкривається діалог для вибору файлу користувачем. Якщо файл не обрано, метод одразу повертає повідомлення про це і подальше виконання коду зупиняється.\r\rПісля цього створюється потік для читання файлу. Перше число з файлу визначає кількість рядків матриці, а друге число — кількість стовпців. У початковій версії матриця реалізується як масив масивів: спершу створюємо масив для рядків, а потім кожен рядок заповнюємо окремим масивом стовпців. Потік закривається після зчитування даних, і відкривається інспектор для перегляду структури матриці.\r\rЩоб знайти максимуми рядків, кожен рядок обробляється за допомогою методу inject, який проходить усі елементи рядка і визначає найбільше значення. Потім, перебираючи всі максимуми рядків, знаходиться загальний максимум усієї матриці. Після обробки результатів ім’я файлу змінюється для збереження результатів у новий файл, відкривається потік на запис, і кожен максимум рядка записується в файл на окремий рядок. Потім потік закривається. Нарешті, метод повертає максимальний елемент усієї матриці.\r\r   Як можна замінити масив масивів на екземпляр класу Matrix?:\r\tЯкщо використовувати клас Matrix, код можна зробити більш компактним і зручним. Клас Matrix зберігає матрицю як єдину структуру n × m, і доступ до елементів відбувається через at: i at: j, що виключає необхідність створювати масив масивів. Спочатку відкриваємо потік для читання файлу і зчитуємо розміри матриці. Потім створюємо об’єкт Matrix відповідного розміру і заповнюємо його числами з файлу. Далі, перебираючи рядки та стовпці, за допомогою вкладених inject визначаємо максимальні значення для кожного рядка та загальний максимум матриці. Результат повертається як вихідний максимум. Такий підхід дозволяє робити код більш структурованим і компактним, позбавляє зайвих проміжних масивів і робить роботу з матрицею наочнішою.\r======================================================\r\r ------ АДРЕСНА КНИГА\r Приклад створення і використання адресної книги, описаний у одній з лекцій. \r Пригадуєте, спочатку оголошуємо глобальну змінну, що міститиме впорядковану \r колекцію масивів з трьох рядків. Спосіб порівняння описує бінарний блок.    "\r\r    Smalltalk globals at: #AddressBook\r              put:(SortedCollection sortBlock:[:a :b | (a at:1)<=(b at:1)]).\r\r" * --- Тепер до книги можна додавати записи. "\r\r    AddressBook\r            add: #(\'Ruth\' \'Babe\' \'456 Mudville Flats\');\r            add: #(\'Smith\' \'John\' \'12/5 Park Ave\');\r            add: #(\'Jexon\' \'John\' \'5 Baverli Hills\');\r            add: #(\'Adams\' \'John\' \'1 Hell str\');\r            add: #(\'Taylor\' \'Babe\' \'2a/35 Deribas str\');\r            add: #(\'Greg\' \'Voss\' \'12345 the USA\')."<-- #(\'Greg\' \'Voss\' \'12345 the USA\')"\r\r" * --- Додайте власні записи. Видрукуйте вміст книги (код запропоновано нижче)."\r   | s w |  s := WriteStream on: String new.\r\r    AddressBook do:[:x | x do:\r        [ :y | s nextPutAll: y; tab; tab.].\r        s cr. ]. \r\tAddressBook\r    add: #(\'Brown\' \'Alice\' \'7 Cherry Lane\');\r    add: #(\'White\' \'Bob\' \'15 Oak Street\');\r    add: #(\'Green\' \'Clara\' \'9 Pine Avenue\').\r\r\t  \r\ts := WriteStream on: String new.\r\tAddressBook do: [ :x | x do: [ :y | s nextPutAll: y; tab; tab. ] ] \r\t\r\t\r  w := Workspace openLabel: \'My Address Book\'.\r  w contents: s contents.\r\r" * ----  Наступне завдання - надрукувати список прізвищ людей з однаковими іменами. \r              Приклад демонструє різні способи перебору та перетворення колекцій."\r\r | firstNames duplicates |\r    firstNames:=Bag new.       \r    AddressBook do: [ :entry | firstNames add: (entry at: 2) ]. \r\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r        \r    duplicates:=firstNames select:\r        [ :name | (firstNames occurrencesOf: name)>1 ].\r    duplicates do: [ :first | first printOn: Transcript. Transcript show:\'==>\'.\r        AddressBook do: [ :entry | (entry at: 2)=first\r            ifTrue: [ Transcript show:\' \'. (entry at: 1) printOn: Transcript ] ].\r        Transcript cr ]. Transcript show:\' \'.\r\r" Поясніть перетворення, що відбуваються в цьому фрагменті:\r\tBag — зберігає елементи з повтореннями.\r\tselect: — фільтрує колекцію, залишаючи тільки елементи, що задовольняють умові (тут, occurrencesOf: > 1).\r\tasSet — видаляє дублікати після фільтрації.\r\tasSortedCollection — сортує результати для зручного виводу.\r\tdo — ітерує колекцію і виконує дію (друк у Transcript).\r\r   Запропонуйте власні варіанти використання та перетворення колекцій. \r \r  Оформіть запропоновані вище фрагменти як методи навчального класу:\r\tObject subclass: #AddressBookUtils\r    \tinstanceVariableNames: \'\'\r    \tclassVariableNames: \'\'\r    \tpoolDictionaries: \'\'\r    \tcategory: \'Training-Examples\'.\r\r"\r\r\r" ------ ДОДАВАННЯ АДРЕС\r  Можливо, додавання записів до AddressBook за допомогою явного програмування \r  виглядає не надто привабливо. Використайте з цією метою діалоги "\r\r| a b c | \ra := UIManager default request: \'Input first name\'.\rb := UIManager default request: \'Input second name\'.\rc := UIManager default request: \'Input address\'.\ra isNil | b isNil | c isNil ifFalse: [ AddressBook add: (Array with:a with:b with:c)]. \r\r" Додайте до книги декілька нових записів, знову видрукуйте її. "\r"Через це в книзі так багато записів:"\r[\r    | a b c |\r    a := UIManager default request: \'Input first name\'.\r    a isNil ifTrue: [ ^self ].  \r\r    b := UIManager default request: \'Input second name\'.\r    b isNil ifTrue: [ ^self ].\r\r    c := UIManager default request: \'Input address\'.\r    c isNil ifTrue: [ ^self ].\r\r    AddressBook add: (Array with: a with: b with: c).\r] repeat.\r\r\ts := WriteStream on: String new.\r\tAddressBook do: [ :x | x do: [ :y | s nextPutAll: y; tab; tab. ] ]\r\r" Поміркуйте, як зробити зручнішим звертання до діалогу додавання адрес та друку адресної книги. "\r\r" Що станеться, якщо виконати наступний код? Випробуйте. "\r    Smalltalk globals removeKey:#AddressBook. "<-- з глобального словника Smalltalk globals буде видалено ключ #AddressBook і, відповідно, саму твою колекцію (адресну книгу)."\r\r "------ ПЕРЕТВОРЕННЯ (ПЕРЕВТІЛЕННЯ) ОБ\'ЄКТІВ\r   Виконайте за допомогою Do It. "\r\r | a b c|\r    a := OrderedCollection new.\r    b := Cylinder new.\r    c := Array with: a with: b with: b.\r    Transcript show: \'Old Array is = \'.\r    c do: [ :x | Transcript show: \'     \'. x printOn: Transcript ].\r    Transcript cr.\r    a become: b.\r    Transcript show: \'New Array is = \'.\r    c do: [ :x | Transcript show: \'     \'. x printOn: Transcript ].\r    Transcript cr; show:\' \'. "<-- Unknown variable"\r\r" Поясніть дію методу become:. Чи можна замість нього користуватися звичайним присвоєнням? Наведіть власні приклади. "\r\r" Він міняє всі посилання на два об’єкти місцями у всій системі.  \r  Не можна замість become використовувати звичайне присвоєння, адже такого ефекту не можливо буде досягнути."\r\r\r\r\r\r\r\r'
}OmEntry {
	#tags : {
		#timestamp : DateAndTime [ '2025-10-05T00:03:40.308+03:00' ],
		#self : OmReference [ '23' ]
	},
	#content : '"--------------------------------------------------------------------------------------\r*                      ЛАБОРОТОРНА РОБОТА 3\r*                 Тема: КЛАСИ ТА МЕТОДИ. КОЛЕКЦІЇ\r*\r*  Завдання до лабораторної роботи:\r*     1. Виконайте наведені нижче приклади, збережіть і поясніть отримані результати.\r*     2. Випробуйте різноманітні способи додавання нових класів до системи.\r*     3. Навчіться доповнювати функціональність класів.\r*     4. Випробуйте методи опрацювання колекцій.\r*\r\r    Виконайте за допомогою <Print it> \r\r ------ ПРИНАЛЕЖНІСТЬ КЛАСОВІ, ІЄРАРХІЯ КЛАСІВ\r"\r    #(Francesca Jackie Marisa Bree) class. "Array"\r    (#(Francesca Jackie Marisa Bree) at:2) class. "ByteSymbol"\r    \'Rakesh Vijay Charles Daniel Tyler\' class. "ByteString"\r    (\'Rakesh Vijay Charles Daniel Tyler\' at:2) class. "Character (a)"\r    World class . "WorldMorph"\r    Magnitude class. "Magnitude class"\r    Magnitude class class. "Metaclass"\r    nil class. "UndefinedObject"\r    5 species. "SmallInteger"\r    123456789000 species. "SmallInteger"\r    #aName species. "ByteString"\r " Яка різниця між повідомленнями class i species ? \r\r    Випробуйте різні способи відкривання браузера класів: за допомогою меню чи програмно \r     Виконайте за допомогою <Do it>\r"\r    ClyFullBrowserMorph open. \r    ClyFullBrowserMorph openOnClass: Date. \r    ClyFullBrowserMorph openOnClass: VolumeShape  selector:  #volume. \r\r" ------ МЕТОДИ КЛАСУ, КОНСТРУКТОРИ\r  Виконайте за допомогою <Print It>. Запропонуйте власні приклади. "\r\r    Array new: 10. "#(nil nil nil nil nil nil nil nil nil nil)"        \r    OrderedCollection  new. "an OrderedCollection()"\r    Date today. "29 September 2025"\r    Time now. "10:28:52.422 am"\r    UIManager default  request:\'How are you?\' initialAnswer:\'I\'\'m fine!\'. "\'I\'\'m fine!\'"\r    Integer readFrom: \'2013  1925\'. "2013"\r    Integer primesUpTo: 100. "#(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97)"\r    Rectangle origin:0@0 corner:200@100. "(0@0) corner: (200@100)"\r    Date nameOfMonth:12. "#December"\r    Date dayOfWeek: #Friday. "6"\r    Date orthodoxEasterDateFor: 2022. "24 April 2022"\r\r\r   \r"Інсталюйте вказані нижче МЕТОДИ КЛАСУ Date:\r  перенесіть копію тексту визначення методу з робочого вікна в браузер класів.\r\r""!Date class methodsFor: \'specific inquiries\' stamp: \'CamilloBruni 8/22/2013 19:47\'!""\r\rorthodoxEasterDateFor: year\r ""  compute the easter date according to the rules of the orthodox calendar.\r    source:       http://www.smart.net/~mmontes/ortheast.html   ""\r     | r1 r2 r3 r4 ra rb r5 rc date |\r\r    r1 := year \\\\ 19.\r    r2 := year \\\\ 4.\r    r3 := year \\\\ 7.\r    ra := 19*r1 + 16.\r    r4 := ra \\\\ 30.\r    rb := r2 + r2 + (4*r3) + (6*r4).\r    r5 := rb \\\\ 7.\r    rc := r4 + r5.\r    date := self year: year month: 4 day: 3.\r    ^date addDays: rc.\r""--------------------------------------------------------------------------------------""\r""!Date class methodsFor: \'specific inquiries\' stamp: \'CamilloBruni 8/22/2013 19:48\'!""\r\reasterDateFor: year\r ""  compute the easter date.\r    source: Physikalisch-Technische Bundesanstalt Braunschweig.\r    Lichtenberg, H.: Zur Interpretation der Gaussschen Osterformel und ihrer Ausnahmeregeln, Historia Mathematica 24 (1997), pp. 441-444\r      http://www.ptb.de/de/org/4/44/441/oste.htm  ""\r\r  | k m s a d r og sz oe day |\r\r  k := year // 100.\r  m := 15 + (3*k + 3//4) - (8*k + 13//25).\r   s := 2 - (3*k + 3// 4).\r  a := year \\\\ 19.\r  d := 19*a + m \\\\ 30.\r  r := d//29 + ((d//28) - (d//29)* (a// 11)).\r\r  og := 21 + d - r.\r  sz := 7 - (year//4 + year + s\\\\7).\r  oe := 7 - (og - sz\\\\7).\r  day := og + oe.\r  ^day <= 31\r    ifTrue: [ Date year: year month: 3 day: day ]\r    ifFalse: [ Date year: year month: 4 day: day - 31 ].\r"\r\r"Знайдіть роки, коли святкування припадають на один день."\r\ryearsWithMatchingEasterFrom: startYear to: endYear\r\r    | matchingYears orthodoxDate catholicDate |\r    matchingYears := OrderedCollection new.\r    (startYear to: endYear) do: [:year |\r        orthodoxDate := self orthodoxEasterDateFor: year.\r        catholicDate := self easterDateFor: year.\r        (orthodoxDate = catholicDate) ifTrue: [\r            matchingYears add: year\r        ].\r    ].\r    ^matchingYears asArray\r\rDate yearsWithMatchingEasterFrom: 2000 to: 2050. "#(2001 2004 2007 2010 2011 2014 2017 2025 2028 2031 2034 2037 2038 2041 2045 2048)"\r\r" ------ РЕКУРСІЯ\r  Додайте до класу Integer і випробуйте різні методи обчислення чисел  Фібоначчі.\r  Запропонуйте власні. Порівняйте їхню ефективність.      \r  Перед випробуванням fibonacci ЗБЕРЕЖІТЬ ІМІДЖ СИСТЕМИ! Він може зайняти Ваш комп на тиждень.  "\r\r3 fibStart: 1 with: 10  "<-- 12"\r4 fibo "<-- 5"\r12 fibonacci "<-- 233"\r\r\r\r\r\r"\r\r\r<fibStart:with:>\rЦе рекурсивний метод, який обчислює n-те число послідовності Фібоначчі, використовуючи два допоміжні параметри — n1 (попереднє значення) і n2 (передпопереднє значення). На кожному кроці рекурсії відбувається виклик:\r(self - 1) fibStart: n1 + n2 with: n1 — таким чином, наступний етап отримує нові значення, де поточне число стає сумою двох попередніх.\rТакий підхід дозволяє виконувати обчислення без повторних підрахунків уже відомих значень, тому алгоритм має лінійну складність O(n). Він працює швидко навіть для великих n і потребує мінімум пам’яті — лише для рекурсивних викликів (глибина дорівнює n).\r\rПояснення: <fibo>\rПроста обгортка над <fibStart:with:.>\r\rПовністю така ж, як у fibStart:with:. Зручно викликати без ручного передавання початкових чисел.\r\rПояснення: <fibonacci>\rКласична рекурсія: F(n) = F(n-1) + F(n-2).\r\rДуже повільний для великих n. Обчислює одні й ті ж значення багато разів → експоненційна складність O(2ⁿ). \rМоже сильно навантажити процесор і стек викликів.\r"\r\r"------------------------------------------------------------------------------------\r ------ СТВОРЕННЯ, ОПРАЦЮВАННЯ КОЛЕКЦІЙ\r  У текстовому файлі записано інформацію про матрицю цілих чисел: розміри\r  матриці в першому рядку файла, у всіх наступних рядках - рядки матриці.}\r  Прочитати матрицю, знайти максимальні елементи кожного рядка і зберегти\r  їх у файлі. Надрукувати максимальний елемент цілої матриці."\r\r"Наведений нижче код можна виконати безпосередньо в робочому вікні,\r проте,  доцільно зробити його методом власного навчального класу."\r\r| matr fStream fName n m mMatr mLines |\r        "Вибір файла за допомогою діалогу"\r    (fName:=UIManager default\r\t\t\tchooseFullFileNameMatching: nil \r\t\t\tlabel: \'Виберіть файл з числовими даними\' ) isNil\r        ifTrue: [ ^\'Ви не вибрали файла\' ]. \r        fStream := fName asFileReference readStream.\r\t        "Введення даних"\r \t    n := Integer readFrom: fStream.  \r\t    matr := Array new: n.\r\t    m := Integer readFrom: fStream.\r\t    matr := matr collect: [ :x | Array new: m ]. \r\t    1 to: n do: [ :i |  fStream nextLine.\r \t\t     matr at: i put: (\r\t\t\t\t (matr at: i) collect: [ :x |  \r\t\t\t\t\t\tInteger readFrom: fStream. ]\r\t\t\t\t\t )\t ].\r    fStream close. matr inspect.\r        "Обчислення максимальних елементів"\r    mLines:=matr collect: [ :r | r inject: (r at: 1) into: [ :x :y | x max: y] ].\r    mMatr:=mLines at: 1.\r    mLines do: [ :x | x > mMatr ifTrue: [ mMatr := x ] ].\r        "Побудова імені файла результатів, збереження"\r    fName at: fName size - 4 put: $_ .\r    fStream := fName asFileReference writeStream.\r    mLines do: [ :x | x printOn: fStream. fStream cr ].\r    fStream close.\r    ^mMatr .  \r\r" Поясніть код, наведений вище (кожне повідомлення!):\r\r\tУ цьому коді ми працюємо з матрицею чисел, зчитаною з файлу. Спершу оголошуємо локальні змінні для зберігання самої матриці, потоку файлу, імені файлу, кількості рядків і стовпців, а також для проміжних результатів. Далі відкривається діалог для вибору файлу користувачем. Якщо файл не обрано, метод одразу повертає повідомлення про це і подальше виконання коду зупиняється.\r\rПісля цього створюється потік для читання файлу. Перше число з файлу визначає кількість рядків матриці, а друге число — кількість стовпців. У початковій версії матриця реалізується як масив масивів: спершу створюємо масив для рядків, а потім кожен рядок заповнюємо окремим масивом стовпців. Потік закривається після зчитування даних, і відкривається інспектор для перегляду структури матриці.\r\rЩоб знайти максимуми рядків, кожен рядок обробляється за допомогою методу inject, який проходить усі елементи рядка і визначає найбільше значення. Потім, перебираючи всі максимуми рядків, знаходиться загальний максимум усієї матриці. Після обробки результатів ім’я файлу змінюється для збереження результатів у новий файл, відкривається потік на запис, і кожен максимум рядка записується в файл на окремий рядок. Потім потік закривається. Нарешті, метод повертає максимальний елемент усієї матриці.\r\r   Як можна замінити масив масивів на екземпляр класу Matrix?:\r\tЯкщо використовувати клас Matrix, код можна зробити більш компактним і зручним. Клас Matrix зберігає матрицю як єдину структуру n × m, і доступ до елементів відбувається через at: i at: j, що виключає необхідність створювати масив масивів. Спочатку відкриваємо потік для читання файлу і зчитуємо розміри матриці. Потім створюємо об’єкт Matrix відповідного розміру і заповнюємо його числами з файлу. Далі, перебираючи рядки та стовпці, за допомогою вкладених inject визначаємо максимальні значення для кожного рядка та загальний максимум матриці. Результат повертається як вихідний максимум. Такий підхід дозволяє робити код більш структурованим і компактним, позбавляє зайвих проміжних масивів і робить роботу з матрицею наочнішою.\r======================================================\r\r ------ АДРЕСНА КНИГА\r Приклад створення і використання адресної книги, описаний у одній з лекцій. \r Пригадуєте, спочатку оголошуємо глобальну змінну, що міститиме впорядковану \r колекцію масивів з трьох рядків. Спосіб порівняння описує бінарний блок.    "\r\r    Smalltalk globals at: #AddressBook\r              put:(SortedCollection sortBlock:[:a :b | (a at:1)<=(b at:1)]).\r\r" * --- Тепер до книги можна додавати записи. "\r\r    AddressBook\r            add: #(\'Ruth\' \'Babe\' \'456 Mudville Flats\');\r            add: #(\'Smith\' \'John\' \'12/5 Park Ave\');\r            add: #(\'Jexon\' \'John\' \'5 Baverli Hills\');\r            add: #(\'Adams\' \'John\' \'1 Hell str\');\r            add: #(\'Taylor\' \'Babe\' \'2a/35 Deribas str\');\r            add: #(\'Greg\' \'Voss\' \'12345 the USA\')."<-- #(\'Greg\' \'Voss\' \'12345 the USA\')"\r\r" * --- Додайте власні записи. Видрукуйте вміст книги (код запропоновано нижче)."\r   | s w |  s := WriteStream on: String new.\r\r    AddressBook do:[:x | x do:\r        [ :y | s nextPutAll: y; tab; tab.].\r        s cr. ]. \r\tAddressBook\r    add: #(\'Brown\' \'Alice\' \'7 Cherry Lane\');\r    add: #(\'White\' \'Bob\' \'15 Oak Street\');\r    add: #(\'Green\' \'Clara\' \'9 Pine Avenue\').\r\r\t  \r\ts := WriteStream on: String new.\r\tAddressBook do: [ :x | x do: [ :y | s nextPutAll: y; tab; tab. ] ] \r\t\r\t\r  w := Workspace openLabel: \'My Address Book\'.\r  w contents: s contents.\r\r" * ----  Наступне завдання - надрукувати список прізвищ людей з однаковими іменами. \r              Приклад демонструє різні способи перебору та перетворення колекцій."\r\r | firstNames duplicates |\r    firstNames:=Bag new.       \r    AddressBook do: [ :entry | firstNames add: (entry at: 2) ]. \r\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r        \r    duplicates:=firstNames select:\r        [ :name | (firstNames occurrencesOf: name)>1 ].\r    duplicates do: [ :first | first printOn: Transcript. Transcript show:\'==>\'.\r        AddressBook do: [ :entry | (entry at: 2)=first\r            ifTrue: [ Transcript show:\' \'. (entry at: 1) printOn: Transcript ] ].\r        Transcript cr ]. Transcript show:\' \'.\r\r" Поясніть перетворення, що відбуваються в цьому фрагменті:\r\tBag — зберігає елементи з повтореннями.\r\tselect: — фільтрує колекцію, залишаючи тільки елементи, що задовольняють умові (тут, occurrencesOf: > 1).\r\tasSet — видаляє дублікати після фільтрації.\r\tasSortedCollection — сортує результати для зручного виводу.\r\tdo — ітерує колекцію і виконує дію (друк у Transcript).\r\r   Запропонуйте власні варіанти використання та перетворення колекцій. \r \r  Оформіть запропоновані вище фрагменти як методи навчального класу:\r\tObject subclass: #AddressBookUtils\r    \tinstanceVariableNames: \'\'\r    \tclassVariableNames: \'\'\r    \tpoolDictionaries: \'\'\r    \tcategory: \'Training-Examples\'.\r\r"\r\r\r" ------ ДОДАВАННЯ АДРЕС\r  Можливо, додавання записів до AddressBook за допомогою явного програмування \r  виглядає не надто привабливо. Використайте з цією метою діалоги "\r\r| a b c | \ra := UIManager default request: \'Input first name\'.\rb := UIManager default request: \'Input second name\'.\rc := UIManager default request: \'Input address\'.\ra isNil | b isNil | c isNil ifFalse: [ AddressBook add: (Array with:a with:b with:c)]. \r\r" Додайте до книги декілька нових записів, знову видрукуйте її. "\r"Через це в книзі так багато записів:"\r[\r    | a b c |\r    a := UIManager default request: \'Input first name\'.\r    a isNil ifTrue: [ ^self ].  \r\r    b := UIManager default request: \'Input second name\'.\r    b isNil ifTrue: [ ^self ].\r\r    c := UIManager default request: \'Input address\'.\r    c isNil ifTrue: [ ^self ].\r\r    AddressBook add: (Array with: a with: b with: c).\r] repeat.\r\r\ts := WriteStream on: String new.\r\tAddressBook do: [ :x | x do: [ :y | s nextPutAll: y; tab; tab. ] ]\r\r" Поміркуйте, як зробити зручнішим звертання до діалогу додавання адрес та друку адресної книги. "\r\r" Що станеться, якщо виконати наступний код? Випробуйте. "\r    Smalltalk globals removeKey:#AddressBook. "<-- з глобального словника Smalltalk globals буде видалено ключ #AddressBook і, відповідно, саму твою колекцію (адресну книгу)."\r\r "------ ПЕРЕТВОРЕННЯ (ПЕРЕВТІЛЕННЯ) ОБ\'ЄКТІВ\r   Виконайте за допомогою Do It. "\r\r | a b c|\r    a := OrderedCollection new.\r    b := Cylinder new.\r    c := Array with: a with: b with: b.\r    Transcript show: \'Old Array is = \'.\r    c do: [ :x | Transcript show: \'     \'. x printOn: Transcript ].\r    Transcript cr.\r    a become: b.\r    Transcript show: \'New Array is = \'.\r    c do: [ :x | Transcript show: \'     \'. x printOn: Transcript ].\r    Transcript cr; show:\' \'. "<-- Unknown variable"\r\r" Поясніть дію методу become:. Чи можна замість нього користуватися звичайним присвоєнням? Наведіть власні приклади. "\r\r" Він міняє всі посилання на два об’єкти місцями у всій системі.  \r  Не можна замість become використовувати звичайне присвоєння, адже такого ефекту не можливо буде досягнути."\r\r\r\r\r\r\r\r'
}OmEntry {
	#tags : {
		#timestamp : DateAndTime [ '2025-10-05T00:03:55.362+03:00' ],
		#self : OmReference [ '24' ]
	},
	#content : '"--------------------------------------------------------------------------------------\r*                      ЛАБОРОТОРНА РОБОТА 3\r*                 Тема: КЛАСИ ТА МЕТОДИ. КОЛЕКЦІЇ\r*\r*  Завдання до лабораторної роботи:\r*     1. Виконайте наведені нижче приклади, збережіть і поясніть отримані результати.\r*     2. Випробуйте різноманітні способи додавання нових класів до системи.\r*     3. Навчіться доповнювати функціональність класів.\r*     4. Випробуйте методи опрацювання колекцій.\r*\r\r    Виконайте за допомогою <Print it> \r\r ------ ПРИНАЛЕЖНІСТЬ КЛАСОВІ, ІЄРАРХІЯ КЛАСІВ\r"\r    #(Francesca Jackie Marisa Bree) class. "Array"\r    (#(Francesca Jackie Marisa Bree) at:2) class. "ByteSymbol"\r    \'Rakesh Vijay Charles Daniel Tyler\' class. "ByteString"\r    (\'Rakesh Vijay Charles Daniel Tyler\' at:2) class. "Character (a)"\r    World class . "WorldMorph"\r    Magnitude class. "Magnitude class"\r    Magnitude class class. "Metaclass"\r    nil class. "UndefinedObject"\r    5 species. "SmallInteger"\r    123456789000 species. "SmallInteger"\r    #aName species. "ByteString"\r " Яка різниця між повідомленнями class i species ? \r\r    Випробуйте різні способи відкривання браузера класів: за допомогою меню чи програмно \r     Виконайте за допомогою <Do it>\r"\r    ClyFullBrowserMorph open. \r    ClyFullBrowserMorph openOnClass: Date. \r    ClyFullBrowserMorph openOnClass: VolumeShape  selector:  #volume. \r\r" ------ МЕТОДИ КЛАСУ, КОНСТРУКТОРИ\r  Виконайте за допомогою <Print It>. Запропонуйте власні приклади. "\r\r    Array new: 10. "#(nil nil nil nil nil nil nil nil nil nil)"        \r    OrderedCollection  new. "an OrderedCollection()"\r    Date today. "29 September 2025"\r    Time now. "10:28:52.422 am"\r    UIManager default  request:\'How are you?\' initialAnswer:\'I\'\'m fine!\'. "\'I\'\'m fine!\'"\r    Integer readFrom: \'2013  1925\'. "2013"\r    Integer primesUpTo: 100. "#(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97)"\r    Rectangle origin:0@0 corner:200@100. "(0@0) corner: (200@100)"\r    Date nameOfMonth:12. "#December"\r    Date dayOfWeek: #Friday. "6"\r    Date orthodoxEasterDateFor: 2022. "24 April 2022"\r\r\r   \r"Інсталюйте вказані нижче МЕТОДИ КЛАСУ Date:\r  перенесіть копію тексту визначення методу з робочого вікна в браузер класів.\r\r""!Date class methodsFor: \'specific inquiries\' stamp: \'CamilloBruni 8/22/2013 19:47\'!""\r\rorthodoxEasterDateFor: year\r ""  compute the easter date according to the rules of the orthodox calendar.\r    source:       http://www.smart.net/~mmontes/ortheast.html   ""\r     | r1 r2 r3 r4 ra rb r5 rc date |\r\r    r1 := year \\\\ 19.\r    r2 := year \\\\ 4.\r    r3 := year \\\\ 7.\r    ra := 19*r1 + 16.\r    r4 := ra \\\\ 30.\r    rb := r2 + r2 + (4*r3) + (6*r4).\r    r5 := rb \\\\ 7.\r    rc := r4 + r5.\r    date := self year: year month: 4 day: 3.\r    ^date addDays: rc.\r""--------------------------------------------------------------------------------------""\r""!Date class methodsFor: \'specific inquiries\' stamp: \'CamilloBruni 8/22/2013 19:48\'!""\r\reasterDateFor: year\r ""  compute the easter date.\r    source: Physikalisch-Technische Bundesanstalt Braunschweig.\r    Lichtenberg, H.: Zur Interpretation der Gaussschen Osterformel und ihrer Ausnahmeregeln, Historia Mathematica 24 (1997), pp. 441-444\r      http://www.ptb.de/de/org/4/44/441/oste.htm  ""\r\r  | k m s a d r og sz oe day |\r\r  k := year // 100.\r  m := 15 + (3*k + 3//4) - (8*k + 13//25).\r   s := 2 - (3*k + 3// 4).\r  a := year \\\\ 19.\r  d := 19*a + m \\\\ 30.\r  r := d//29 + ((d//28) - (d//29)* (a// 11)).\r\r  og := 21 + d - r.\r  sz := 7 - (year//4 + year + s\\\\7).\r  oe := 7 - (og - sz\\\\7).\r  day := og + oe.\r  ^day <= 31\r    ifTrue: [ Date year: year month: 3 day: day ]\r    ifFalse: [ Date year: year month: 4 day: day - 31 ].\r"\r\r"Знайдіть роки, коли святкування припадають на один день."\r\ryearsWithMatchingEasterFrom: startYear to: endYear\r\r    | matchingYears orthodoxDate catholicDate |\r    matchingYears := OrderedCollection new.\r    (startYear to: endYear) do: [:year |\r        orthodoxDate := self orthodoxEasterDateFor: year.\r        catholicDate := self easterDateFor: year.\r        (orthodoxDate = catholicDate) ifTrue: [\r            matchingYears add: year\r        ].\r    ].\r    ^matchingYears asArray\r\rDate yearsWithMatchingEasterFrom: 2000 to: 2050. "#(2001 2004 2007 2010 2011 2014 2017 2025 2028 2031 2034 2037 2038 2041 2045 2048)"\r\r" ------ РЕКУРСІЯ\r  Додайте до класу Integer і випробуйте різні методи обчислення чисел  Фібоначчі.\r  Запропонуйте власні. Порівняйте їхню ефективність.      \r  Перед випробуванням fibonacci ЗБЕРЕЖІТЬ ІМІДЖ СИСТЕМИ! Він може зайняти Ваш комп на тиждень.  "\r\r3 fibStart: 1 with: 10  "<-- 12"\r4 fibo "<-- 5"\r12 fibonacci "<-- 233"\r\r\r\r\r\r"\r\r\r<fibStart:with:>\rЦе рекурсивний метод, який обчислює n-те число послідовності Фібоначчі, використовуючи два допоміжні параметри — n1 (попереднє значення) і n2 (передпопереднє значення). На кожному кроці рекурсії відбувається виклик:\r(self - 1) fibStart: n1 + n2 with: n1 — таким чином, наступний етап отримує нові значення, де поточне число стає сумою двох попередніх.\rТакий підхід дозволяє виконувати обчислення без повторних підрахунків уже відомих значень, тому алгоритм має лінійну складність O(n). Він працює швидко навіть для великих n і потребує мінімум пам’яті — лише для рекурсивних викликів (глибина дорівнює n).\r\r<fibo>\rЦе допоміжний метод, який просто викликає fibStart:with: із початковими значеннями. Його мета — спростити виклик функції, щоб не потрібно було вручну задавати перші два числа послідовності. Фактично, він працює так само, як і fibStart:with:, але зручніший у використанні, коли потрібно просто отримати n-те число Фібоначчі.\r\rПояснення: <fibonacci>\rКласична рекурсія: F(n) = F(n-1) + F(n-2).\r\rДуже повільний для великих n. Обчислює одні й ті ж значення багато разів → експоненційна складність O(2ⁿ). \rМоже сильно навантажити процесор і стек викликів.\r"\r\r"------------------------------------------------------------------------------------\r ------ СТВОРЕННЯ, ОПРАЦЮВАННЯ КОЛЕКЦІЙ\r  У текстовому файлі записано інформацію про матрицю цілих чисел: розміри\r  матриці в першому рядку файла, у всіх наступних рядках - рядки матриці.}\r  Прочитати матрицю, знайти максимальні елементи кожного рядка і зберегти\r  їх у файлі. Надрукувати максимальний елемент цілої матриці."\r\r"Наведений нижче код можна виконати безпосередньо в робочому вікні,\r проте,  доцільно зробити його методом власного навчального класу."\r\r| matr fStream fName n m mMatr mLines |\r        "Вибір файла за допомогою діалогу"\r    (fName:=UIManager default\r\t\t\tchooseFullFileNameMatching: nil \r\t\t\tlabel: \'Виберіть файл з числовими даними\' ) isNil\r        ifTrue: [ ^\'Ви не вибрали файла\' ]. \r        fStream := fName asFileReference readStream.\r\t        "Введення даних"\r \t    n := Integer readFrom: fStream.  \r\t    matr := Array new: n.\r\t    m := Integer readFrom: fStream.\r\t    matr := matr collect: [ :x | Array new: m ]. \r\t    1 to: n do: [ :i |  fStream nextLine.\r \t\t     matr at: i put: (\r\t\t\t\t (matr at: i) collect: [ :x |  \r\t\t\t\t\t\tInteger readFrom: fStream. ]\r\t\t\t\t\t )\t ].\r    fStream close. matr inspect.\r        "Обчислення максимальних елементів"\r    mLines:=matr collect: [ :r | r inject: (r at: 1) into: [ :x :y | x max: y] ].\r    mMatr:=mLines at: 1.\r    mLines do: [ :x | x > mMatr ifTrue: [ mMatr := x ] ].\r        "Побудова імені файла результатів, збереження"\r    fName at: fName size - 4 put: $_ .\r    fStream := fName asFileReference writeStream.\r    mLines do: [ :x | x printOn: fStream. fStream cr ].\r    fStream close.\r    ^mMatr .  \r\r" Поясніть код, наведений вище (кожне повідомлення!):\r\r\tУ цьому коді ми працюємо з матрицею чисел, зчитаною з файлу. Спершу оголошуємо локальні змінні для зберігання самої матриці, потоку файлу, імені файлу, кількості рядків і стовпців, а також для проміжних результатів. Далі відкривається діалог для вибору файлу користувачем. Якщо файл не обрано, метод одразу повертає повідомлення про це і подальше виконання коду зупиняється.\r\rПісля цього створюється потік для читання файлу. Перше число з файлу визначає кількість рядків матриці, а друге число — кількість стовпців. У початковій версії матриця реалізується як масив масивів: спершу створюємо масив для рядків, а потім кожен рядок заповнюємо окремим масивом стовпців. Потік закривається після зчитування даних, і відкривається інспектор для перегляду структури матриці.\r\rЩоб знайти максимуми рядків, кожен рядок обробляється за допомогою методу inject, який проходить усі елементи рядка і визначає найбільше значення. Потім, перебираючи всі максимуми рядків, знаходиться загальний максимум усієї матриці. Після обробки результатів ім’я файлу змінюється для збереження результатів у новий файл, відкривається потік на запис, і кожен максимум рядка записується в файл на окремий рядок. Потім потік закривається. Нарешті, метод повертає максимальний елемент усієї матриці.\r\r   Як можна замінити масив масивів на екземпляр класу Matrix?:\r\tЯкщо використовувати клас Matrix, код можна зробити більш компактним і зручним. Клас Matrix зберігає матрицю як єдину структуру n × m, і доступ до елементів відбувається через at: i at: j, що виключає необхідність створювати масив масивів. Спочатку відкриваємо потік для читання файлу і зчитуємо розміри матриці. Потім створюємо об’єкт Matrix відповідного розміру і заповнюємо його числами з файлу. Далі, перебираючи рядки та стовпці, за допомогою вкладених inject визначаємо максимальні значення для кожного рядка та загальний максимум матриці. Результат повертається як вихідний максимум. Такий підхід дозволяє робити код більш структурованим і компактним, позбавляє зайвих проміжних масивів і робить роботу з матрицею наочнішою.\r======================================================\r\r ------ АДРЕСНА КНИГА\r Приклад створення і використання адресної книги, описаний у одній з лекцій. \r Пригадуєте, спочатку оголошуємо глобальну змінну, що міститиме впорядковану \r колекцію масивів з трьох рядків. Спосіб порівняння описує бінарний блок.    "\r\r    Smalltalk globals at: #AddressBook\r              put:(SortedCollection sortBlock:[:a :b | (a at:1)<=(b at:1)]).\r\r" * --- Тепер до книги можна додавати записи. "\r\r    AddressBook\r            add: #(\'Ruth\' \'Babe\' \'456 Mudville Flats\');\r            add: #(\'Smith\' \'John\' \'12/5 Park Ave\');\r            add: #(\'Jexon\' \'John\' \'5 Baverli Hills\');\r            add: #(\'Adams\' \'John\' \'1 Hell str\');\r            add: #(\'Taylor\' \'Babe\' \'2a/35 Deribas str\');\r            add: #(\'Greg\' \'Voss\' \'12345 the USA\')."<-- #(\'Greg\' \'Voss\' \'12345 the USA\')"\r\r" * --- Додайте власні записи. Видрукуйте вміст книги (код запропоновано нижче)."\r   | s w |  s := WriteStream on: String new.\r\r    AddressBook do:[:x | x do:\r        [ :y | s nextPutAll: y; tab; tab.].\r        s cr. ]. \r\tAddressBook\r    add: #(\'Brown\' \'Alice\' \'7 Cherry Lane\');\r    add: #(\'White\' \'Bob\' \'15 Oak Street\');\r    add: #(\'Green\' \'Clara\' \'9 Pine Avenue\').\r\r\t  \r\ts := WriteStream on: String new.\r\tAddressBook do: [ :x | x do: [ :y | s nextPutAll: y; tab; tab. ] ] \r\t\r\t\r  w := Workspace openLabel: \'My Address Book\'.\r  w contents: s contents.\r\r" * ----  Наступне завдання - надрукувати список прізвищ людей з однаковими іменами. \r              Приклад демонструє різні способи перебору та перетворення колекцій."\r\r | firstNames duplicates |\r    firstNames:=Bag new.       \r    AddressBook do: [ :entry | firstNames add: (entry at: 2) ]. \r\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r        \r    duplicates:=firstNames select:\r        [ :name | (firstNames occurrencesOf: name)>1 ].\r    duplicates do: [ :first | first printOn: Transcript. Transcript show:\'==>\'.\r        AddressBook do: [ :entry | (entry at: 2)=first\r            ifTrue: [ Transcript show:\' \'. (entry at: 1) printOn: Transcript ] ].\r        Transcript cr ]. Transcript show:\' \'.\r\r" Поясніть перетворення, що відбуваються в цьому фрагменті:\r\tBag — зберігає елементи з повтореннями.\r\tselect: — фільтрує колекцію, залишаючи тільки елементи, що задовольняють умові (тут, occurrencesOf: > 1).\r\tasSet — видаляє дублікати після фільтрації.\r\tasSortedCollection — сортує результати для зручного виводу.\r\tdo — ітерує колекцію і виконує дію (друк у Transcript).\r\r   Запропонуйте власні варіанти використання та перетворення колекцій. \r \r  Оформіть запропоновані вище фрагменти як методи навчального класу:\r\tObject subclass: #AddressBookUtils\r    \tinstanceVariableNames: \'\'\r    \tclassVariableNames: \'\'\r    \tpoolDictionaries: \'\'\r    \tcategory: \'Training-Examples\'.\r\r"\r\r\r" ------ ДОДАВАННЯ АДРЕС\r  Можливо, додавання записів до AddressBook за допомогою явного програмування \r  виглядає не надто привабливо. Використайте з цією метою діалоги "\r\r| a b c | \ra := UIManager default request: \'Input first name\'.\rb := UIManager default request: \'Input second name\'.\rc := UIManager default request: \'Input address\'.\ra isNil | b isNil | c isNil ifFalse: [ AddressBook add: (Array with:a with:b with:c)]. \r\r" Додайте до книги декілька нових записів, знову видрукуйте її. "\r"Через це в книзі так багато записів:"\r[\r    | a b c |\r    a := UIManager default request: \'Input first name\'.\r    a isNil ifTrue: [ ^self ].  \r\r    b := UIManager default request: \'Input second name\'.\r    b isNil ifTrue: [ ^self ].\r\r    c := UIManager default request: \'Input address\'.\r    c isNil ifTrue: [ ^self ].\r\r    AddressBook add: (Array with: a with: b with: c).\r] repeat.\r\r\ts := WriteStream on: String new.\r\tAddressBook do: [ :x | x do: [ :y | s nextPutAll: y; tab; tab. ] ]\r\r" Поміркуйте, як зробити зручнішим звертання до діалогу додавання адрес та друку адресної книги. "\r\r" Що станеться, якщо виконати наступний код? Випробуйте. "\r    Smalltalk globals removeKey:#AddressBook. "<-- з глобального словника Smalltalk globals буде видалено ключ #AddressBook і, відповідно, саму твою колекцію (адресну книгу)."\r\r "------ ПЕРЕТВОРЕННЯ (ПЕРЕВТІЛЕННЯ) ОБ\'ЄКТІВ\r   Виконайте за допомогою Do It. "\r\r | a b c|\r    a := OrderedCollection new.\r    b := Cylinder new.\r    c := Array with: a with: b with: b.\r    Transcript show: \'Old Array is = \'.\r    c do: [ :x | Transcript show: \'     \'. x printOn: Transcript ].\r    Transcript cr.\r    a become: b.\r    Transcript show: \'New Array is = \'.\r    c do: [ :x | Transcript show: \'     \'. x printOn: Transcript ].\r    Transcript cr; show:\' \'. "<-- Unknown variable"\r\r" Поясніть дію методу become:. Чи можна замість нього користуватися звичайним присвоєнням? Наведіть власні приклади. "\r\r" Він міняє всі посилання на два об’єкти місцями у всій системі.  \r  Не можна замість become використовувати звичайне присвоєння, адже такого ефекту не можливо буде досягнути."\r\r\r\r\r\r\r\r'
}OmEntry {
	#tags : {
		#timestamp : DateAndTime [ '2025-10-05T00:04:15.217+03:00' ],
		#self : OmReference [ '25' ]
	},
	#content : '"--------------------------------------------------------------------------------------\r*                      ЛАБОРОТОРНА РОБОТА 3\r*                 Тема: КЛАСИ ТА МЕТОДИ. КОЛЕКЦІЇ\r*\r*  Завдання до лабораторної роботи:\r*     1. Виконайте наведені нижче приклади, збережіть і поясніть отримані результати.\r*     2. Випробуйте різноманітні способи додавання нових класів до системи.\r*     3. Навчіться доповнювати функціональність класів.\r*     4. Випробуйте методи опрацювання колекцій.\r*\r\r    Виконайте за допомогою <Print it> \r\r ------ ПРИНАЛЕЖНІСТЬ КЛАСОВІ, ІЄРАРХІЯ КЛАСІВ\r"\r    #(Francesca Jackie Marisa Bree) class. "Array"\r    (#(Francesca Jackie Marisa Bree) at:2) class. "ByteSymbol"\r    \'Rakesh Vijay Charles Daniel Tyler\' class. "ByteString"\r    (\'Rakesh Vijay Charles Daniel Tyler\' at:2) class. "Character (a)"\r    World class . "WorldMorph"\r    Magnitude class. "Magnitude class"\r    Magnitude class class. "Metaclass"\r    nil class. "UndefinedObject"\r    5 species. "SmallInteger"\r    123456789000 species. "SmallInteger"\r    #aName species. "ByteString"\r " Яка різниця між повідомленнями class i species ? \r\r    Випробуйте різні способи відкривання браузера класів: за допомогою меню чи програмно \r     Виконайте за допомогою <Do it>\r"\r    ClyFullBrowserMorph open. \r    ClyFullBrowserMorph openOnClass: Date. \r    ClyFullBrowserMorph openOnClass: VolumeShape  selector:  #volume. \r\r" ------ МЕТОДИ КЛАСУ, КОНСТРУКТОРИ\r  Виконайте за допомогою <Print It>. Запропонуйте власні приклади. "\r\r    Array new: 10. "#(nil nil nil nil nil nil nil nil nil nil)"        \r    OrderedCollection  new. "an OrderedCollection()"\r    Date today. "29 September 2025"\r    Time now. "10:28:52.422 am"\r    UIManager default  request:\'How are you?\' initialAnswer:\'I\'\'m fine!\'. "\'I\'\'m fine!\'"\r    Integer readFrom: \'2013  1925\'. "2013"\r    Integer primesUpTo: 100. "#(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97)"\r    Rectangle origin:0@0 corner:200@100. "(0@0) corner: (200@100)"\r    Date nameOfMonth:12. "#December"\r    Date dayOfWeek: #Friday. "6"\r    Date orthodoxEasterDateFor: 2022. "24 April 2022"\r\r\r   \r"Інсталюйте вказані нижче МЕТОДИ КЛАСУ Date:\r  перенесіть копію тексту визначення методу з робочого вікна в браузер класів.\r\r""!Date class methodsFor: \'specific inquiries\' stamp: \'CamilloBruni 8/22/2013 19:47\'!""\r\rorthodoxEasterDateFor: year\r ""  compute the easter date according to the rules of the orthodox calendar.\r    source:       http://www.smart.net/~mmontes/ortheast.html   ""\r     | r1 r2 r3 r4 ra rb r5 rc date |\r\r    r1 := year \\\\ 19.\r    r2 := year \\\\ 4.\r    r3 := year \\\\ 7.\r    ra := 19*r1 + 16.\r    r4 := ra \\\\ 30.\r    rb := r2 + r2 + (4*r3) + (6*r4).\r    r5 := rb \\\\ 7.\r    rc := r4 + r5.\r    date := self year: year month: 4 day: 3.\r    ^date addDays: rc.\r""--------------------------------------------------------------------------------------""\r""!Date class methodsFor: \'specific inquiries\' stamp: \'CamilloBruni 8/22/2013 19:48\'!""\r\reasterDateFor: year\r ""  compute the easter date.\r    source: Physikalisch-Technische Bundesanstalt Braunschweig.\r    Lichtenberg, H.: Zur Interpretation der Gaussschen Osterformel und ihrer Ausnahmeregeln, Historia Mathematica 24 (1997), pp. 441-444\r      http://www.ptb.de/de/org/4/44/441/oste.htm  ""\r\r  | k m s a d r og sz oe day |\r\r  k := year // 100.\r  m := 15 + (3*k + 3//4) - (8*k + 13//25).\r   s := 2 - (3*k + 3// 4).\r  a := year \\\\ 19.\r  d := 19*a + m \\\\ 30.\r  r := d//29 + ((d//28) - (d//29)* (a// 11)).\r\r  og := 21 + d - r.\r  sz := 7 - (year//4 + year + s\\\\7).\r  oe := 7 - (og - sz\\\\7).\r  day := og + oe.\r  ^day <= 31\r    ifTrue: [ Date year: year month: 3 day: day ]\r    ifFalse: [ Date year: year month: 4 day: day - 31 ].\r"\r\r"Знайдіть роки, коли святкування припадають на один день."\r\ryearsWithMatchingEasterFrom: startYear to: endYear\r\r    | matchingYears orthodoxDate catholicDate |\r    matchingYears := OrderedCollection new.\r    (startYear to: endYear) do: [:year |\r        orthodoxDate := self orthodoxEasterDateFor: year.\r        catholicDate := self easterDateFor: year.\r        (orthodoxDate = catholicDate) ifTrue: [\r            matchingYears add: year\r        ].\r    ].\r    ^matchingYears asArray\r\rDate yearsWithMatchingEasterFrom: 2000 to: 2050. "#(2001 2004 2007 2010 2011 2014 2017 2025 2028 2031 2034 2037 2038 2041 2045 2048)"\r\r" ------ РЕКУРСІЯ\r  Додайте до класу Integer і випробуйте різні методи обчислення чисел  Фібоначчі.\r  Запропонуйте власні. Порівняйте їхню ефективність.      \r  Перед випробуванням fibonacci ЗБЕРЕЖІТЬ ІМІДЖ СИСТЕМИ! Він може зайняти Ваш комп на тиждень.  "\r\r3 fibStart: 1 with: 10  "<-- 12"\r4 fibo "<-- 5"\r12 fibonacci "<-- 233"\r\r\r\r\r\r"\r\r\r<fibStart:with:>\rЦе рекурсивний метод, який обчислює n-те число послідовності Фібоначчі, використовуючи два допоміжні параметри — n1 (попереднє значення) і n2 (передпопереднє значення). На кожному кроці рекурсії відбувається виклик:\r(self - 1) fibStart: n1 + n2 with: n1 — таким чином, наступний етап отримує нові значення, де поточне число стає сумою двох попередніх.\rТакий підхід дозволяє виконувати обчислення без повторних підрахунків уже відомих значень, тому алгоритм має лінійну складність O(n). Він працює швидко навіть для великих n і потребує мінімум пам’яті — лише для рекурсивних викликів (глибина дорівнює n).\r\r<fibo>\rЦе допоміжний метод, який просто викликає fibStart:with: із початковими значеннями. Його мета — спростити виклик функції, щоб не потрібно було вручну задавати перші два числа послідовності. Фактично, він працює так само, як і fibStart:with:, але зручніший у використанні, коли потрібно просто отримати n-те число Фібоначчі.\r\r<fibonacci>\rЦей варіант використовує класичне рекурсивне визначення:\rF(n) = F(n - 1) + F(n - 2)\rМетод простий у розумінні, але дуже неефективний для великих n, оскільки він не запам’ятовує вже обчислені значення і багаторазово виконує ті самі обчислення. Через це його складність є експоненційною — приблизно O(2ⁿ). При великих значеннях n така реалізація значно навантажує процесор і стек викликів, тому практично використовується лише для навчальних цілей або демонстрацій.\r"\r\r"------------------------------------------------------------------------------------\r ------ СТВОРЕННЯ, ОПРАЦЮВАННЯ КОЛЕКЦІЙ\r  У текстовому файлі записано інформацію про матрицю цілих чисел: розміри\r  матриці в першому рядку файла, у всіх наступних рядках - рядки матриці.}\r  Прочитати матрицю, знайти максимальні елементи кожного рядка і зберегти\r  їх у файлі. Надрукувати максимальний елемент цілої матриці."\r\r"Наведений нижче код можна виконати безпосередньо в робочому вікні,\r проте,  доцільно зробити його методом власного навчального класу."\r\r| matr fStream fName n m mMatr mLines |\r        "Вибір файла за допомогою діалогу"\r    (fName:=UIManager default\r\t\t\tchooseFullFileNameMatching: nil \r\t\t\tlabel: \'Виберіть файл з числовими даними\' ) isNil\r        ifTrue: [ ^\'Ви не вибрали файла\' ]. \r        fStream := fName asFileReference readStream.\r\t        "Введення даних"\r \t    n := Integer readFrom: fStream.  \r\t    matr := Array new: n.\r\t    m := Integer readFrom: fStream.\r\t    matr := matr collect: [ :x | Array new: m ]. \r\t    1 to: n do: [ :i |  fStream nextLine.\r \t\t     matr at: i put: (\r\t\t\t\t (matr at: i) collect: [ :x |  \r\t\t\t\t\t\tInteger readFrom: fStream. ]\r\t\t\t\t\t )\t ].\r    fStream close. matr inspect.\r        "Обчислення максимальних елементів"\r    mLines:=matr collect: [ :r | r inject: (r at: 1) into: [ :x :y | x max: y] ].\r    mMatr:=mLines at: 1.\r    mLines do: [ :x | x > mMatr ifTrue: [ mMatr := x ] ].\r        "Побудова імені файла результатів, збереження"\r    fName at: fName size - 4 put: $_ .\r    fStream := fName asFileReference writeStream.\r    mLines do: [ :x | x printOn: fStream. fStream cr ].\r    fStream close.\r    ^mMatr .  \r\r" Поясніть код, наведений вище (кожне повідомлення!):\r\r\tУ цьому коді ми працюємо з матрицею чисел, зчитаною з файлу. Спершу оголошуємо локальні змінні для зберігання самої матриці, потоку файлу, імені файлу, кількості рядків і стовпців, а також для проміжних результатів. Далі відкривається діалог для вибору файлу користувачем. Якщо файл не обрано, метод одразу повертає повідомлення про це і подальше виконання коду зупиняється.\r\rПісля цього створюється потік для читання файлу. Перше число з файлу визначає кількість рядків матриці, а друге число — кількість стовпців. У початковій версії матриця реалізується як масив масивів: спершу створюємо масив для рядків, а потім кожен рядок заповнюємо окремим масивом стовпців. Потік закривається після зчитування даних, і відкривається інспектор для перегляду структури матриці.\r\rЩоб знайти максимуми рядків, кожен рядок обробляється за допомогою методу inject, який проходить усі елементи рядка і визначає найбільше значення. Потім, перебираючи всі максимуми рядків, знаходиться загальний максимум усієї матриці. Після обробки результатів ім’я файлу змінюється для збереження результатів у новий файл, відкривається потік на запис, і кожен максимум рядка записується в файл на окремий рядок. Потім потік закривається. Нарешті, метод повертає максимальний елемент усієї матриці.\r\r   Як можна замінити масив масивів на екземпляр класу Matrix?:\r\tЯкщо використовувати клас Matrix, код можна зробити більш компактним і зручним. Клас Matrix зберігає матрицю як єдину структуру n × m, і доступ до елементів відбувається через at: i at: j, що виключає необхідність створювати масив масивів. Спочатку відкриваємо потік для читання файлу і зчитуємо розміри матриці. Потім створюємо об’єкт Matrix відповідного розміру і заповнюємо його числами з файлу. Далі, перебираючи рядки та стовпці, за допомогою вкладених inject визначаємо максимальні значення для кожного рядка та загальний максимум матриці. Результат повертається як вихідний максимум. Такий підхід дозволяє робити код більш структурованим і компактним, позбавляє зайвих проміжних масивів і робить роботу з матрицею наочнішою.\r======================================================\r\r ------ АДРЕСНА КНИГА\r Приклад створення і використання адресної книги, описаний у одній з лекцій. \r Пригадуєте, спочатку оголошуємо глобальну змінну, що міститиме впорядковану \r колекцію масивів з трьох рядків. Спосіб порівняння описує бінарний блок.    "\r\r    Smalltalk globals at: #AddressBook\r              put:(SortedCollection sortBlock:[:a :b | (a at:1)<=(b at:1)]).\r\r" * --- Тепер до книги можна додавати записи. "\r\r    AddressBook\r            add: #(\'Ruth\' \'Babe\' \'456 Mudville Flats\');\r            add: #(\'Smith\' \'John\' \'12/5 Park Ave\');\r            add: #(\'Jexon\' \'John\' \'5 Baverli Hills\');\r            add: #(\'Adams\' \'John\' \'1 Hell str\');\r            add: #(\'Taylor\' \'Babe\' \'2a/35 Deribas str\');\r            add: #(\'Greg\' \'Voss\' \'12345 the USA\')."<-- #(\'Greg\' \'Voss\' \'12345 the USA\')"\r\r" * --- Додайте власні записи. Видрукуйте вміст книги (код запропоновано нижче)."\r   | s w |  s := WriteStream on: String new.\r\r    AddressBook do:[:x | x do:\r        [ :y | s nextPutAll: y; tab; tab.].\r        s cr. ]. \r\tAddressBook\r    add: #(\'Brown\' \'Alice\' \'7 Cherry Lane\');\r    add: #(\'White\' \'Bob\' \'15 Oak Street\');\r    add: #(\'Green\' \'Clara\' \'9 Pine Avenue\').\r\r\t  \r\ts := WriteStream on: String new.\r\tAddressBook do: [ :x | x do: [ :y | s nextPutAll: y; tab; tab. ] ] \r\t\r\t\r  w := Workspace openLabel: \'My Address Book\'.\r  w contents: s contents.\r\r" * ----  Наступне завдання - надрукувати список прізвищ людей з однаковими іменами. \r              Приклад демонструє різні способи перебору та перетворення колекцій."\r\r | firstNames duplicates |\r    firstNames:=Bag new.       \r    AddressBook do: [ :entry | firstNames add: (entry at: 2) ]. \r\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r        \r    duplicates:=firstNames select:\r        [ :name | (firstNames occurrencesOf: name)>1 ].\r    duplicates do: [ :first | first printOn: Transcript. Transcript show:\'==>\'.\r        AddressBook do: [ :entry | (entry at: 2)=first\r            ifTrue: [ Transcript show:\' \'. (entry at: 1) printOn: Transcript ] ].\r        Transcript cr ]. Transcript show:\' \'.\r\r" Поясніть перетворення, що відбуваються в цьому фрагменті:\r\tBag — зберігає елементи з повтореннями.\r\tselect: — фільтрує колекцію, залишаючи тільки елементи, що задовольняють умові (тут, occurrencesOf: > 1).\r\tasSet — видаляє дублікати після фільтрації.\r\tasSortedCollection — сортує результати для зручного виводу.\r\tdo — ітерує колекцію і виконує дію (друк у Transcript).\r\r   Запропонуйте власні варіанти використання та перетворення колекцій. \r \r  Оформіть запропоновані вище фрагменти як методи навчального класу:\r\tObject subclass: #AddressBookUtils\r    \tinstanceVariableNames: \'\'\r    \tclassVariableNames: \'\'\r    \tpoolDictionaries: \'\'\r    \tcategory: \'Training-Examples\'.\r\r"\r\r\r" ------ ДОДАВАННЯ АДРЕС\r  Можливо, додавання записів до AddressBook за допомогою явного програмування \r  виглядає не надто привабливо. Використайте з цією метою діалоги "\r\r| a b c | \ra := UIManager default request: \'Input first name\'.\rb := UIManager default request: \'Input second name\'.\rc := UIManager default request: \'Input address\'.\ra isNil | b isNil | c isNil ifFalse: [ AddressBook add: (Array with:a with:b with:c)]. \r\r" Додайте до книги декілька нових записів, знову видрукуйте її. "\r"Через це в книзі так багато записів:"\r[\r    | a b c |\r    a := UIManager default request: \'Input first name\'.\r    a isNil ifTrue: [ ^self ].  \r\r    b := UIManager default request: \'Input second name\'.\r    b isNil ifTrue: [ ^self ].\r\r    c := UIManager default request: \'Input address\'.\r    c isNil ifTrue: [ ^self ].\r\r    AddressBook add: (Array with: a with: b with: c).\r] repeat.\r\r\ts := WriteStream on: String new.\r\tAddressBook do: [ :x | x do: [ :y | s nextPutAll: y; tab; tab. ] ]\r\r" Поміркуйте, як зробити зручнішим звертання до діалогу додавання адрес та друку адресної книги. "\r\r" Що станеться, якщо виконати наступний код? Випробуйте. "\r    Smalltalk globals removeKey:#AddressBook. "<-- з глобального словника Smalltalk globals буде видалено ключ #AddressBook і, відповідно, саму твою колекцію (адресну книгу)."\r\r "------ ПЕРЕТВОРЕННЯ (ПЕРЕВТІЛЕННЯ) ОБ\'ЄКТІВ\r   Виконайте за допомогою Do It. "\r\r | a b c|\r    a := OrderedCollection new.\r    b := Cylinder new.\r    c := Array with: a with: b with: b.\r    Transcript show: \'Old Array is = \'.\r    c do: [ :x | Transcript show: \'     \'. x printOn: Transcript ].\r    Transcript cr.\r    a become: b.\r    Transcript show: \'New Array is = \'.\r    c do: [ :x | Transcript show: \'     \'. x printOn: Transcript ].\r    Transcript cr; show:\' \'. "<-- Unknown variable"\r\r" Поясніть дію методу become:. Чи можна замість нього користуватися звичайним присвоєнням? Наведіть власні приклади. "\r\r" Він міняє всі посилання на два об’єкти місцями у всій системі.  \r  Не можна замість become використовувати звичайне присвоєння, адже такого ефекту не можливо буде досягнути."\r\r\r\r\r\r\r\r'
}OmEntry {
	#tags : {
		#timestamp : DateAndTime [ '2025-10-05T00:04:44.347+03:00' ],
		#self : OmReference [ '26' ]
	},
	#content : '"--------------------------------------------------------------------------------------\r*                      ЛАБОРОТОРНА РОБОТА 3\r*                 Тема: КЛАСИ ТА МЕТОДИ. КОЛЕКЦІЇ\r*\r*  Завдання до лабораторної роботи:\r*     1. Виконайте наведені нижче приклади, збережіть і поясніть отримані результати.\r*     2. Випробуйте різноманітні способи додавання нових класів до системи.\r*     3. Навчіться доповнювати функціональність класів.\r*     4. Випробуйте методи опрацювання колекцій.\r*\r\r    Виконайте за допомогою <Print it> \r\r ------ ПРИНАЛЕЖНІСТЬ КЛАСОВІ, ІЄРАРХІЯ КЛАСІВ\r"\r    #(Francesca Jackie Marisa Bree) class. "Array"\r    (#(Francesca Jackie Marisa Bree) at:2) class. "ByteSymbol"\r    \'Rakesh Vijay Charles Daniel Tyler\' class. "ByteString"\r    (\'Rakesh Vijay Charles Daniel Tyler\' at:2) class. "Character (a)"\r    World class . "WorldMorph"\r    Magnitude class. "Magnitude class"\r    Magnitude class class. "Metaclass"\r    nil class. "UndefinedObject"\r    5 species. "SmallInteger"\r    123456789000 species. "SmallInteger"\r    #aName species. "ByteString"\r " Яка різниця між повідомленнями class i species ? \r\r    Випробуйте різні способи відкривання браузера класів: за допомогою меню чи програмно \r     Виконайте за допомогою <Do it>\r"\r    ClyFullBrowserMorph open. \r    ClyFullBrowserMorph openOnClass: Date. \r    ClyFullBrowserMorph openOnClass: VolumeShape  selector:  #volume. \r\r" ------ МЕТОДИ КЛАСУ, КОНСТРУКТОРИ\r  Виконайте за допомогою <Print It>. Запропонуйте власні приклади. "\r\r    Array new: 10. "#(nil nil nil nil nil nil nil nil nil nil)"        \r    OrderedCollection  new. "an OrderedCollection()"\r    Date today. "29 September 2025"\r    Time now. "10:28:52.422 am"\r    UIManager default  request:\'How are you?\' initialAnswer:\'I\'\'m fine!\'. "\'I\'\'m fine!\'"\r    Integer readFrom: \'2013  1925\'. "2013"\r    Integer primesUpTo: 100. "#(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97)"\r    Rectangle origin:0@0 corner:200@100. "(0@0) corner: (200@100)"\r    Date nameOfMonth:12. "#December"\r    Date dayOfWeek: #Friday. "6"\r    Date orthodoxEasterDateFor: 2022. "24 April 2022"\r\r\r   \r"Інсталюйте вказані нижче МЕТОДИ КЛАСУ Date:\r  перенесіть копію тексту визначення методу з робочого вікна в браузер класів.\r\r""!Date class methodsFor: \'specific inquiries\' stamp: \'CamilloBruni 8/22/2013 19:47\'!""\r\rorthodoxEasterDateFor: year\r ""  compute the easter date according to the rules of the orthodox calendar.\r    source:       http://www.smart.net/~mmontes/ortheast.html   ""\r     | r1 r2 r3 r4 ra rb r5 rc date |\r\r    r1 := year \\\\ 19.\r    r2 := year \\\\ 4.\r    r3 := year \\\\ 7.\r    ra := 19*r1 + 16.\r    r4 := ra \\\\ 30.\r    rb := r2 + r2 + (4*r3) + (6*r4).\r    r5 := rb \\\\ 7.\r    rc := r4 + r5.\r    date := self year: year month: 4 day: 3.\r    ^date addDays: rc.\r""--------------------------------------------------------------------------------------""\r""!Date class methodsFor: \'specific inquiries\' stamp: \'CamilloBruni 8/22/2013 19:48\'!""\r\reasterDateFor: year\r ""  compute the easter date.\r    source: Physikalisch-Technische Bundesanstalt Braunschweig.\r    Lichtenberg, H.: Zur Interpretation der Gaussschen Osterformel und ihrer Ausnahmeregeln, Historia Mathematica 24 (1997), pp. 441-444\r      http://www.ptb.de/de/org/4/44/441/oste.htm  ""\r\r  | k m s a d r og sz oe day |\r\r  k := year // 100.\r  m := 15 + (3*k + 3//4) - (8*k + 13//25).\r   s := 2 - (3*k + 3// 4).\r  a := year \\\\ 19.\r  d := 19*a + m \\\\ 30.\r  r := d//29 + ((d//28) - (d//29)* (a// 11)).\r\r  og := 21 + d - r.\r  sz := 7 - (year//4 + year + s\\\\7).\r  oe := 7 - (og - sz\\\\7).\r  day := og + oe.\r  ^day <= 31\r    ifTrue: [ Date year: year month: 3 day: day ]\r    ifFalse: [ Date year: year month: 4 day: day - 31 ].\r"\r\r"Знайдіть роки, коли святкування припадають на один день."\r\ryearsWithMatchingEasterFrom: startYear to: endYear\r\r    | matchingYears orthodoxDate catholicDate |\r    matchingYears := OrderedCollection new.\r    (startYear to: endYear) do: [:year |\r        orthodoxDate := self orthodoxEasterDateFor: year.\r        catholicDate := self easterDateFor: year.\r        (orthodoxDate = catholicDate) ifTrue: [\r            matchingYears add: year\r        ].\r    ].\r    ^matchingYears asArray\r\rDate yearsWithMatchingEasterFrom: 2000 to: 2050. "#(2001 2004 2007 2010 2011 2014 2017 2025 2028 2031 2034 2037 2038 2041 2045 2048)"\r\r" ------ РЕКУРСІЯ\r  Додайте до класу Integer і випробуйте різні методи обчислення чисел  Фібоначчі.\r  Запропонуйте власні. Порівняйте їхню ефективність.      \r  Перед випробуванням fibonacci ЗБЕРЕЖІТЬ ІМІДЖ СИСТЕМИ! Він може зайняти Ваш комп на тиждень.  "\r\r3 fibStart: 1 with: 10  "12"\r4 fibo "5"\r12 fibonacci "233"\r\r\r\r\r\r"\r\r\r<fibStart:with:>\rЦе рекурсивний метод, який обчислює n-те число послідовності Фібоначчі, використовуючи два допоміжні параметри — n1 (попереднє значення) і n2 (передпопереднє значення). На кожному кроці рекурсії відбувається виклик:\r(self - 1) fibStart: n1 + n2 with: n1 — таким чином, наступний етап отримує нові значення, де поточне число стає сумою двох попередніх.\rТакий підхід дозволяє виконувати обчислення без повторних підрахунків уже відомих значень, тому алгоритм має лінійну складність O(n). Він працює швидко навіть для великих n і потребує мінімум пам’яті — лише для рекурсивних викликів (глибина дорівнює n).\r\r<fibo>\rЦе допоміжний метод, який просто викликає fibStart:with: із початковими значеннями. Його мета — спростити виклик функції, щоб не потрібно було вручну задавати перші два числа послідовності. Фактично, він працює так само, як і fibStart:with:, але зручніший у використанні, коли потрібно просто отримати n-те число Фібоначчі.\r\r<fibonacci>\rЦей варіант використовує класичне рекурсивне визначення:\rF(n) = F(n - 1) + F(n - 2)\rМетод простий у розумінні, але дуже неефективний для великих n, оскільки він не запам’ятовує вже обчислені значення і багаторазово виконує ті самі обчислення. Через це його складність є експоненційною — приблизно O(2ⁿ). При великих значеннях n така реалізація значно навантажує процесор і стек викликів, тому практично використовується лише для навчальних цілей або демонстрацій.\r"\r\r"------------------------------------------------------------------------------------\r ------ СТВОРЕННЯ, ОПРАЦЮВАННЯ КОЛЕКЦІЙ\r  У текстовому файлі записано інформацію про матрицю цілих чисел: розміри\r  матриці в першому рядку файла, у всіх наступних рядках - рядки матриці.}\r  Прочитати матрицю, знайти максимальні елементи кожного рядка і зберегти\r  їх у файлі. Надрукувати максимальний елемент цілої матриці."\r\r"Наведений нижче код можна виконати безпосередньо в робочому вікні,\r проте,  доцільно зробити його методом власного навчального класу."\r\r| matr fStream fName n m mMatr mLines |\r        "Вибір файла за допомогою діалогу"\r    (fName:=UIManager default\r\t\t\tchooseFullFileNameMatching: nil \r\t\t\tlabel: \'Виберіть файл з числовими даними\' ) isNil\r        ifTrue: [ ^\'Ви не вибрали файла\' ]. \r        fStream := fName asFileReference readStream.\r\t        "Введення даних"\r \t    n := Integer readFrom: fStream.  \r\t    matr := Array new: n.\r\t    m := Integer readFrom: fStream.\r\t    matr := matr collect: [ :x | Array new: m ]. \r\t    1 to: n do: [ :i |  fStream nextLine.\r \t\t     matr at: i put: (\r\t\t\t\t (matr at: i) collect: [ :x |  \r\t\t\t\t\t\tInteger readFrom: fStream. ]\r\t\t\t\t\t )\t ].\r    fStream close. matr inspect.\r        "Обчислення максимальних елементів"\r    mLines:=matr collect: [ :r | r inject: (r at: 1) into: [ :x :y | x max: y] ].\r    mMatr:=mLines at: 1.\r    mLines do: [ :x | x > mMatr ifTrue: [ mMatr := x ] ].\r        "Побудова імені файла результатів, збереження"\r    fName at: fName size - 4 put: $_ .\r    fStream := fName asFileReference writeStream.\r    mLines do: [ :x | x printOn: fStream. fStream cr ].\r    fStream close.\r    ^mMatr .  \r\r" Поясніть код, наведений вище (кожне повідомлення!):\r\r\tУ цьому коді ми працюємо з матрицею чисел, зчитаною з файлу. Спершу оголошуємо локальні змінні для зберігання самої матриці, потоку файлу, імені файлу, кількості рядків і стовпців, а також для проміжних результатів. Далі відкривається діалог для вибору файлу користувачем. Якщо файл не обрано, метод одразу повертає повідомлення про це і подальше виконання коду зупиняється.\r\rПісля цього створюється потік для читання файлу. Перше число з файлу визначає кількість рядків матриці, а друге число — кількість стовпців. У початковій версії матриця реалізується як масив масивів: спершу створюємо масив для рядків, а потім кожен рядок заповнюємо окремим масивом стовпців. Потік закривається після зчитування даних, і відкривається інспектор для перегляду структури матриці.\r\rЩоб знайти максимуми рядків, кожен рядок обробляється за допомогою методу inject, який проходить усі елементи рядка і визначає найбільше значення. Потім, перебираючи всі максимуми рядків, знаходиться загальний максимум усієї матриці. Після обробки результатів ім’я файлу змінюється для збереження результатів у новий файл, відкривається потік на запис, і кожен максимум рядка записується в файл на окремий рядок. Потім потік закривається. Нарешті, метод повертає максимальний елемент усієї матриці.\r\r   Як можна замінити масив масивів на екземпляр класу Matrix?:\r\tЯкщо використовувати клас Matrix, код можна зробити більш компактним і зручним. Клас Matrix зберігає матрицю як єдину структуру n × m, і доступ до елементів відбувається через at: i at: j, що виключає необхідність створювати масив масивів. Спочатку відкриваємо потік для читання файлу і зчитуємо розміри матриці. Потім створюємо об’єкт Matrix відповідного розміру і заповнюємо його числами з файлу. Далі, перебираючи рядки та стовпці, за допомогою вкладених inject визначаємо максимальні значення для кожного рядка та загальний максимум матриці. Результат повертається як вихідний максимум. Такий підхід дозволяє робити код більш структурованим і компактним, позбавляє зайвих проміжних масивів і робить роботу з матрицею наочнішою.\r======================================================\r\r ------ АДРЕСНА КНИГА\r Приклад створення і використання адресної книги, описаний у одній з лекцій. \r Пригадуєте, спочатку оголошуємо глобальну змінну, що міститиме впорядковану \r колекцію масивів з трьох рядків. Спосіб порівняння описує бінарний блок.    "\r\r    Smalltalk globals at: #AddressBook\r              put:(SortedCollection sortBlock:[:a :b | (a at:1)<=(b at:1)]).\r\r" * --- Тепер до книги можна додавати записи. "\r\r    AddressBook\r            add: #(\'Ruth\' \'Babe\' \'456 Mudville Flats\');\r            add: #(\'Smith\' \'John\' \'12/5 Park Ave\');\r            add: #(\'Jexon\' \'John\' \'5 Baverli Hills\');\r            add: #(\'Adams\' \'John\' \'1 Hell str\');\r            add: #(\'Taylor\' \'Babe\' \'2a/35 Deribas str\');\r            add: #(\'Greg\' \'Voss\' \'12345 the USA\')."<-- #(\'Greg\' \'Voss\' \'12345 the USA\')"\r\r" * --- Додайте власні записи. Видрукуйте вміст книги (код запропоновано нижче)."\r   | s w |  s := WriteStream on: String new.\r\r    AddressBook do:[:x | x do:\r        [ :y | s nextPutAll: y; tab; tab.].\r        s cr. ]. \r\tAddressBook\r    add: #(\'Brown\' \'Alice\' \'7 Cherry Lane\');\r    add: #(\'White\' \'Bob\' \'15 Oak Street\');\r    add: #(\'Green\' \'Clara\' \'9 Pine Avenue\').\r\r\t  \r\ts := WriteStream on: String new.\r\tAddressBook do: [ :x | x do: [ :y | s nextPutAll: y; tab; tab. ] ] \r\t\r\t\r  w := Workspace openLabel: \'My Address Book\'.\r  w contents: s contents.\r\r" * ----  Наступне завдання - надрукувати список прізвищ людей з однаковими іменами. \r              Приклад демонструє різні способи перебору та перетворення колекцій."\r\r | firstNames duplicates |\r    firstNames:=Bag new.       \r    AddressBook do: [ :entry | firstNames add: (entry at: 2) ]. \r\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r        \r    duplicates:=firstNames select:\r        [ :name | (firstNames occurrencesOf: name)>1 ].\r    duplicates do: [ :first | first printOn: Transcript. Transcript show:\'==>\'.\r        AddressBook do: [ :entry | (entry at: 2)=first\r            ifTrue: [ Transcript show:\' \'. (entry at: 1) printOn: Transcript ] ].\r        Transcript cr ]. Transcript show:\' \'.\r\r" Поясніть перетворення, що відбуваються в цьому фрагменті:\r\tBag — зберігає елементи з повтореннями.\r\tselect: — фільтрує колекцію, залишаючи тільки елементи, що задовольняють умові (тут, occurrencesOf: > 1).\r\tasSet — видаляє дублікати після фільтрації.\r\tasSortedCollection — сортує результати для зручного виводу.\r\tdo — ітерує колекцію і виконує дію (друк у Transcript).\r\r   Запропонуйте власні варіанти використання та перетворення колекцій. \r \r  Оформіть запропоновані вище фрагменти як методи навчального класу:\r\tObject subclass: #AddressBookUtils\r    \tinstanceVariableNames: \'\'\r    \tclassVariableNames: \'\'\r    \tpoolDictionaries: \'\'\r    \tcategory: \'Training-Examples\'.\r\r"\r\r\r" ------ ДОДАВАННЯ АДРЕС\r  Можливо, додавання записів до AddressBook за допомогою явного програмування \r  виглядає не надто привабливо. Використайте з цією метою діалоги "\r\r| a b c | \ra := UIManager default request: \'Input first name\'.\rb := UIManager default request: \'Input second name\'.\rc := UIManager default request: \'Input address\'.\ra isNil | b isNil | c isNil ifFalse: [ AddressBook add: (Array with:a with:b with:c)]. \r\r" Додайте до книги декілька нових записів, знову видрукуйте її. "\r"Через це в книзі так багато записів:"\r[\r    | a b c |\r    a := UIManager default request: \'Input first name\'.\r    a isNil ifTrue: [ ^self ].  \r\r    b := UIManager default request: \'Input second name\'.\r    b isNil ifTrue: [ ^self ].\r\r    c := UIManager default request: \'Input address\'.\r    c isNil ifTrue: [ ^self ].\r\r    AddressBook add: (Array with: a with: b with: c).\r] repeat.\r\r\ts := WriteStream on: String new.\r\tAddressBook do: [ :x | x do: [ :y | s nextPutAll: y; tab; tab. ] ]\r\r" Поміркуйте, як зробити зручнішим звертання до діалогу додавання адрес та друку адресної книги. "\r\r" Що станеться, якщо виконати наступний код? Випробуйте. "\r    Smalltalk globals removeKey:#AddressBook. "<-- з глобального словника Smalltalk globals буде видалено ключ #AddressBook і, відповідно, саму твою колекцію (адресну книгу)."\r\r "------ ПЕРЕТВОРЕННЯ (ПЕРЕВТІЛЕННЯ) ОБ\'ЄКТІВ\r   Виконайте за допомогою Do It. "\r\r | a b c|\r    a := OrderedCollection new.\r    b := Cylinder new.\r    c := Array with: a with: b with: b.\r    Transcript show: \'Old Array is = \'.\r    c do: [ :x | Transcript show: \'     \'. x printOn: Transcript ].\r    Transcript cr.\r    a become: b.\r    Transcript show: \'New Array is = \'.\r    c do: [ :x | Transcript show: \'     \'. x printOn: Transcript ].\r    Transcript cr; show:\' \'. "<-- Unknown variable"\r\r" Поясніть дію методу become:. Чи можна замість нього користуватися звичайним присвоєнням? Наведіть власні приклади. "\r\r" Він міняє всі посилання на два об’єкти місцями у всій системі.  \r  Не можна замість become використовувати звичайне присвоєння, адже такого ефекту не можливо буде досягнути."\r\r\r\r\r\r\r\r'
}OmEntry {
	#tags : {
		#timestamp : DateAndTime [ '2025-10-05T00:05:18.025+03:00' ],
		#self : OmReference [ '27' ]
	},
	#content : '"--------------------------------------------------------------------------------------\r*                      ЛАБОРОТОРНА РОБОТА 3\r*                 Тема: КЛАСИ ТА МЕТОДИ. КОЛЕКЦІЇ\r*\r*  Завдання до лабораторної роботи:\r*     1. Виконайте наведені нижче приклади, збережіть і поясніть отримані результати.\r*     2. Випробуйте різноманітні способи додавання нових класів до системи.\r*     3. Навчіться доповнювати функціональність класів.\r*     4. Випробуйте методи опрацювання колекцій.\r*\r\r    Виконайте за допомогою <Print it> \r\r ------ ПРИНАЛЕЖНІСТЬ КЛАСОВІ, ІЄРАРХІЯ КЛАСІВ\r"\r    #(Francesca Jackie Marisa Bree) class. "Array"\r    (#(Francesca Jackie Marisa Bree) at:2) class. "ByteSymbol"\r    \'Rakesh Vijay Charles Daniel Tyler\' class. "ByteString"\r    (\'Rakesh Vijay Charles Daniel Tyler\' at:2) class. "Character (a)"\r    World class . "WorldMorph"\r    Magnitude class. "Magnitude class"\r    Magnitude class class. "Metaclass"\r    nil class. "UndefinedObject"\r    5 species. "SmallInteger"\r    123456789000 species. "SmallInteger"\r    #aName species. "ByteString"\r " Яка різниця між повідомленнями class i species ? \r\r    Випробуйте різні способи відкривання браузера класів: за допомогою меню чи програмно \r     Виконайте за допомогою <Do it>\r"\r    ClyFullBrowserMorph open. \r    ClyFullBrowserMorph openOnClass: Date. \r    ClyFullBrowserMorph openOnClass: VolumeShape  selector:  #volume. \r\r" ------ МЕТОДИ КЛАСУ, КОНСТРУКТОРИ\r  Виконайте за допомогою <Print It>. Запропонуйте власні приклади. "\r\r    Array new: 10. "#(nil nil nil nil nil nil nil nil nil nil)"        \r    OrderedCollection  new. "an OrderedCollection()"\r    Date today. "29 September 2025"\r    Time now. "10:28:52.422 am"\r    UIManager default  request:\'How are you?\' initialAnswer:\'I\'\'m fine!\'. "\'I\'\'m fine!\'"\r    Integer readFrom: \'2013  1925\'. "2013"\r    Integer primesUpTo: 100. "#(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97)"\r    Rectangle origin:0@0 corner:200@100. "(0@0) corner: (200@100)"\r    Date nameOfMonth:12. "#December"\r    Date dayOfWeek: #Friday. "6"\r    Date orthodoxEasterDateFor: 2022. "24 April 2022"\r\r\r   \r"Інсталюйте вказані нижче МЕТОДИ КЛАСУ Date:\r  перенесіть копію тексту визначення методу з робочого вікна в браузер класів.\r\r""!Date class methodsFor: \'specific inquiries\' stamp: \'CamilloBruni 8/22/2013 19:47\'!""\r\rorthodoxEasterDateFor: year\r ""  compute the easter date according to the rules of the orthodox calendar.\r    source:       http://www.smart.net/~mmontes/ortheast.html   ""\r     | r1 r2 r3 r4 ra rb r5 rc date |\r\r    r1 := year \\\\ 19.\r    r2 := year \\\\ 4.\r    r3 := year \\\\ 7.\r    ra := 19*r1 + 16.\r    r4 := ra \\\\ 30.\r    rb := r2 + r2 + (4*r3) + (6*r4).\r    r5 := rb \\\\ 7.\r    rc := r4 + r5.\r    date := self year: year month: 4 day: 3.\r    ^date addDays: rc.\r""--------------------------------------------------------------------------------------""\r""!Date class methodsFor: \'specific inquiries\' stamp: \'CamilloBruni 8/22/2013 19:48\'!""\r\reasterDateFor: year\r ""  compute the easter date.\r    source: Physikalisch-Technische Bundesanstalt Braunschweig.\r    Lichtenberg, H.: Zur Interpretation der Gaussschen Osterformel und ihrer Ausnahmeregeln, Historia Mathematica 24 (1997), pp. 441-444\r      http://www.ptb.de/de/org/4/44/441/oste.htm  ""\r\r  | k m s a d r og sz oe day |\r\r  k := year // 100.\r  m := 15 + (3*k + 3//4) - (8*k + 13//25).\r   s := 2 - (3*k + 3// 4).\r  a := year \\\\ 19.\r  d := 19*a + m \\\\ 30.\r  r := d//29 + ((d//28) - (d//29)* (a// 11)).\r\r  og := 21 + d - r.\r  sz := 7 - (year//4 + year + s\\\\7).\r  oe := 7 - (og - sz\\\\7).\r  day := og + oe.\r  ^day <= 31\r    ifTrue: [ Date year: year month: 3 day: day ]\r    ifFalse: [ Date year: year month: 4 day: day - 31 ].\r"\r\r"Знайдіть роки, коли святкування припадають на один день."\r\ryearsWithMatchingEasterFrom: startYear to: endYear\r\r    | matchingYears orthodoxDate catholicDate |\r    matchingYears := OrderedCollection new.\r    (startYear to: endYear) do: [:year |\r        orthodoxDate := self orthodoxEasterDateFor: year.\r        catholicDate := self easterDateFor: year.\r        (orthodoxDate = catholicDate) ifTrue: [\r            matchingYears add: year\r        ].\r    ].\r    ^matchingYears asArray\r\rDate yearsWithMatchingEasterFrom: 2000 to: 2050. "#(2001 2004 2007 2010 2011 2014 2017 2025 2028 2031 2034 2037 2038 2041 2045 2048)"\r\r" ------ РЕКУРСІЯ\r  Додайте до класу Integer і випробуйте різні методи обчислення чисел  Фібоначчі.\r  Запропонуйте власні. Порівняйте їхню ефективність.      \r  Перед випробуванням fibonacci ЗБЕРЕЖІТЬ ІМІДЖ СИСТЕМИ! Він може зайняти Ваш комп на тиждень.  "\r\r3 fibStart: 1 with: 10  "12"\r4 fibo "5"\r12 fibonacci "233"\r\r\r\r\r\r"\r\r\r<fibStart:with:>\rЦе рекурсивний метод, який обчислює n-те число послідовності Фібоначчі, використовуючи два допоміжні параметри — n1 (попереднє значення) і n2 (передпопереднє значення). На кожному кроці рекурсії відбувається виклик:\r(self - 1) fibStart: n1 + n2 with: n1 — таким чином, наступний етап отримує нові значення, де поточне число стає сумою двох попередніх.\rТакий підхід дозволяє виконувати обчислення без повторних підрахунків уже відомих значень, тому алгоритм має лінійну складність O(n). Він працює швидко навіть для великих n і потребує мінімум пам’яті — лише для рекурсивних викликів (глибина дорівнює n).\r\r<fibo>\rЦе допоміжний метод, який просто викликає fibStart:with: із початковими значеннями. Його мета — спростити виклик функції, щоб не потрібно було вручну задавати перші два числа послідовності. Фактично, він працює так само, як і fibStart:with:, але зручніший у використанні, коли потрібно просто отримати n-те число Фібоначчі.\r\r<fibonacci>\rЦей варіант використовує класичне рекурсивне визначення:\rF(n) = F(n - 1) + F(n - 2)\rМетод простий у розумінні, але дуже неефективний для великих n, оскільки він не запам’ятовує вже обчислені значення і багаторазово виконує ті самі обчислення. Через це його складність є експоненційною — приблизно O(2ⁿ). При великих значеннях n така реалізація значно навантажує процесор і стек викликів, тому практично використовується лише для навчальних цілей або демонстрацій.\r"\r\r"------------------------------------------------------------------------------------\r ------ СТВОРЕННЯ, ОПРАЦЮВАННЯ КОЛЕКЦІЙ\r  У текстовому файлі записано інформацію про матрицю цілих чисел: розміри\r  матриці в першому рядку файла, у всіх наступних рядках - рядки матриці.}\r  Прочитати матрицю, знайти максимальні елементи кожного рядка і зберегти\r  їх у файлі. Надрукувати максимальний елемент цілої матриці."\r\r"Наведений нижче код можна виконати безпосередньо в робочому вікні,\r проте,  доцільно зробити його методом власного навчального класу."\r\r| matr fStream fName n m mMatr mLines |\r        "Вибір файла за допомогою діалогу"\r    (fName:=UIManager default\r\t\t\tchooseFullFileNameMatching: nil \r\t\t\tlabel: \'Виберіть файл з числовими даними\' ) isNil\r        ifTrue: [ ^\'Ви не вибрали файла\' ]. \r        fStream := fName asFileReference readStream.\r\t        "Введення даних"\r \t    n := Integer readFrom: fStream.  \r\t    matr := Array new: n.\r\t    m := Integer readFrom: fStream.\r\t    matr := matr collect: [ :x | Array new: m ]. \r\t    1 to: n do: [ :i |  fStream nextLine.\r \t\t     matr at: i put: (\r\t\t\t\t (matr at: i) collect: [ :x |  \r\t\t\t\t\t\tInteger readFrom: fStream. ]\r\t\t\t\t\t )\t ].\r    fStream close. matr inspect.\r        "Обчислення максимальних елементів"\r    mLines:=matr collect: [ :r | r inject: (r at: 1) into: [ :x :y | x max: y] ].\r    mMatr:=mLines at: 1.\r    mLines do: [ :x | x > mMatr ifTrue: [ mMatr := x ] ].\r        "Побудова імені файла результатів, збереження"\r    fName at: fName size - 4 put: $_ .\r    fStream := fName asFileReference writeStream.\r    mLines do: [ :x | x printOn: fStream. fStream cr ].\r    fStream close.\r    ^mMatr .  \r\r" Поясніть код, наведений вище (кожне повідомлення!):\r\r\tУ цьому коді ми працюємо з матрицею чисел, зчитаною з файлу. Спершу оголошуємо локальні змінні для зберігання самої матриці, потоку файлу, імені файлу, кількості рядків і стовпців, а також для проміжних результатів. Далі відкривається діалог для вибору файлу користувачем. Якщо файл не обрано, метод одразу повертає повідомлення про це і подальше виконання коду зупиняється.\r\rПісля цього створюється потік для читання файлу. Перше число з файлу визначає кількість рядків матриці, а друге число — кількість стовпців. У початковій версії матриця реалізується як масив масивів: спершу створюємо масив для рядків, а потім кожен рядок заповнюємо окремим масивом стовпців. Потік закривається після зчитування даних, і відкривається інспектор для перегляду структури матриці.\r\rЩоб знайти максимуми рядків, кожен рядок обробляється за допомогою методу inject, який проходить усі елементи рядка і визначає найбільше значення. Потім, перебираючи всі максимуми рядків, знаходиться загальний максимум усієї матриці. Після обробки результатів ім’я файлу змінюється для збереження результатів у новий файл, відкривається потік на запис, і кожен максимум рядка записується в файл на окремий рядок. Потім потік закривається. Нарешті, метод повертає максимальний елемент усієї матриці.\r\r   Як можна замінити масив масивів на екземпляр класу Matrix?:\r\tЯкщо використовувати клас Matrix, код можна зробити більш компактним і зручним. Клас Matrix зберігає матрицю як єдину структуру n × m, і доступ до елементів відбувається через at: i at: j, що виключає необхідність створювати масив масивів. Спочатку відкриваємо потік для читання файлу і зчитуємо розміри матриці. Потім створюємо об’єкт Matrix відповідного розміру і заповнюємо його числами з файлу. Далі, перебираючи рядки та стовпці, за допомогою вкладених inject визначаємо максимальні значення для кожного рядка та загальний максимум матриці. Результат повертається як вихідний максимум. Такий підхід дозволяє робити код більш структурованим і компактним, позбавляє зайвих проміжних масивів і робить роботу з матрицею наочнішою.\r======================================================\r\r ------ АДРЕСНА КНИГА\r Приклад створення і використання адресної книги, описаний у одній з лекцій. \r Пригадуєте, спочатку оголошуємо глобальну змінну, що міститиме впорядковану \r колекцію масивів з трьох рядків. Спосіб порівняння описує бінарний блок.    "\r\r    Smalltalk globals at: #AddressBook\r              put:(SortedCollection sortBlock:[:a :b | (a at:1)<=(b at:1)]).\r\r" * --- Тепер до книги можна додавати записи. "\r\r    AddressBook\r            add: #(\'Ruth\' \'Babe\' \'456 Mudville Flats\');\r            add: #(\'Smith\' \'John\' \'12/5 Park Ave\');\r            add: #(\'Jexon\' \'John\' \'5 Baverli Hills\');\r            add: #(\'Adams\' \'John\' \'1 Hell str\');\r            add: #(\'Taylor\' \'Babe\' \'2a/35 Deribas str\');\r            add: #(\'Greg\' \'Voss\' \'12345 the USA\')."<-- #(\'Greg\' \'Voss\' \'12345 the USA\')"\r\r" * --- Додайте власні записи. Видрукуйте вміст книги (код запропоновано нижче)."\r   | s w |  s := WriteStream on: String new.\r\r    AddressBook do:[:x | x do:\r        [ :y | s nextPutAll: y; tab; tab.].\r        s cr. ]. \r\tAddressBook\r    add: #(\'Brown\' \'Alice\' \'7 Cherry Lane\');\r    add: #(\'White\' \'Bob\' \'15 Oak Street\');\r    add: #(\'Green\' \'Clara\' \'9 Pine Avenue\').\r\r\t  \r\ts := WriteStream on: String new.\r\tAddressBook do: [ :x | x do: [ :y | s nextPutAll: y; tab; tab. ] ] \r\t\r\t\r  w := Workspace openLabel: \'My Address Book\'.\r  w contents: s contents.\r\r" * ----  Наступне завдання - надрукувати список прізвищ людей з однаковими іменами. \r              Приклад демонструє різні способи перебору та перетворення колекцій."\r\r | firstNames duplicates |\r    firstNames:=Bag new.       \r    AddressBook do: [ :entry | firstNames add: (entry at: 2) ]. \r\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r        \r    duplicates:=firstNames select:\r        [ :name | (firstNames occurrencesOf: name)>1 ].\r    duplicates do: [ :first | first printOn: Transcript. Transcript show:\'==>\'.\r        AddressBook do: [ :entry | (entry at: 2)=first\r            ifTrue: [ Transcript show:\' \'. (entry at: 1) printOn: Transcript ] ].\r        Transcript cr ]. Transcript show:\' \'.\r\r" Поясніть перетворення, що відбуваються в цьому фрагменті:\r\tBag — зберігає елементи з повтореннями.\r\tselect: — фільтрує колекцію, залишаючи тільки елементи, що задовольняють умові (тут, occurrencesOf: > 1).\r\tasSet — видаляє дублікати після фільтрації.\r\tasSortedCollection — сортує результати для зручного виводу.\r\tdo — ітерує колекцію і виконує дію (друк у Transcript).\r\r   Запропонуйте власні варіанти використання та перетворення колекцій. \r \r  Оформіть запропоновані вище фрагменти як методи навчального класу:\r\tObject subclass: #AddressBookUtils\r    \tinstanceVariableNames: \'\'\r    \tclassVariableNames: \'\'\r    \tpoolDictionaries: \'\'\r    \tcategory: \'Training-Examples\'.\r\r"\r\r\r" ------ ДОДАВАННЯ АДРЕС\r  Можливо, додавання записів до AddressBook за допомогою явного програмування \r  виглядає не надто привабливо. Використайте з цією метою діалоги "\r\r| a b c | \ra := UIManager default request: \'Input first name\'.\rb := UIManager default request: \'Input second name\'.\rc := UIManager default request: \'Input address\'.\ra isNil | b isNil | c isNil ifFalse: [ AddressBook add: (Array with:a with:b with:c)]. \r\r" Додайте до книги декілька нових записів, знову видрукуйте її. "\r"Через це в книзі так багато записів:"\r[\r    | a b c |\r    a := UIManager default request: \'Input first name\'.\r    a isNil ifTrue: [ ^self ].  \r\r    b := UIManager default request: \'Input second name\'.\r    b isNil ifTrue: [ ^self ].\r\r    c := UIManager default request: \'Input address\'.\r    c isNil ifTrue: [ ^self ].\r\r    AddressBook add: (Array with: a with: b with: c).\r] repeat.\r\r\ts := WriteStream on: String new.\r\tAddressBook do: [ :x | x do: [ :y | s nextPutAll: y; tab; tab. ] ]\r\r" Поміркуйте, як зробити зручнішим звертання до діалогу додавання адрес та друку адресної книги. "\r\r" Що станеться, якщо виконати наступний код? Випробуйте. "\r    Smalltalk globals removeKey:#AddressBook. "з глобального словника Smalltalk globals буде видалено ключ #AddressBook і, відповідно, саму твою колекцію (адресну книгу)."\r\r "------ ПЕРЕТВОРЕННЯ (ПЕРЕВТІЛЕННЯ) ОБ\'ЄКТІВ\r   Виконайте за допомогою Do It. "\r\r | a b c|\r    a := OrderedCollection new.\r    b := Cylinder new.\r    c := Array with: a with: b with: b.\r    Transcript show: \'Old Array is = \'.\r    c do: [ :x | Transcript show: \'     \'. x printOn: Transcript ].\r    Transcript cr.\r    a become: b.\r    Transcript show: \'New Array is = \'.\r    c do: [ :x | Transcript show: \'     \'. x printOn: Transcript ].\r    Transcript cr; show:\' \'. "<-- Unknown variable"\r\r" Поясніть дію методу become:. Чи можна замість нього користуватися звичайним присвоєнням? Наведіть власні приклади. "\r\r" Він міняє всі посилання на два об’єкти місцями у всій системі.  \r  Не можна замість become використовувати звичайне присвоєння, адже такого ефекту не можливо буде досягнути."\r\r\r\r\r\r\r\r'
}OmEntry {
	#tags : {
		#timestamp : DateAndTime [ '2025-10-05T00:09:30.36+03:00' ],
		#self : OmReference [ '28' ]
	},
	#content : '"--------------------------------------------------------------------------------------\r*                      ЛАБОРОТОРНА РОБОТА 3\r*                 Тема: КЛАСИ ТА МЕТОДИ. КОЛЕКЦІЇ\r*\r*  Завдання до лабораторної роботи:\r*     1. Виконайте наведені нижче приклади, збережіть і поясніть отримані результати.\r*     2. Випробуйте різноманітні способи додавання нових класів до системи.\r*     3. Навчіться доповнювати функціональність класів.\r*     4. Випробуйте методи опрацювання колекцій.\r*\r\r    Виконайте за допомогою <Print it> \r\r ------ ПРИНАЛЕЖНІСТЬ КЛАСОВІ, ІЄРАРХІЯ КЛАСІВ\r"\r    #(Francesca Jackie Marisa Bree) class. "Array"\r    (#(Francesca Jackie Marisa Bree) at:2) class. "ByteSymbol"\r    \'Rakesh Vijay Charles Daniel Tyler\' class. "ByteString"\r    (\'Rakesh Vijay Charles Daniel Tyler\' at:2) class. "Character (a)"\r    World class . "WorldMorph"\r    Magnitude class. "Magnitude class"\r    Magnitude class class. "Metaclass"\r    nil class. "UndefinedObject"\r    5 species. "SmallInteger"\r    123456789000 species. "SmallInteger"\r    #aName species. "ByteString"\r " Яка різниця між повідомленнями class i species ? \r\r    Випробуйте різні способи відкривання браузера класів: за допомогою меню чи програмно \r     Виконайте за допомогою <Do it>\r"\r    ClyFullBrowserMorph open. \r    ClyFullBrowserMorph openOnClass: Date. \r    ClyFullBrowserMorph openOnClass: VolumeShape  selector:  #volume. \r\r" ------ МЕТОДИ КЛАСУ, КОНСТРУКТОРИ\r  Виконайте за допомогою <Print It>. Запропонуйте власні приклади. "\r\r    Array new: 10. "#(nil nil nil nil nil nil nil nil nil nil)"        \r    OrderedCollection  new. "an OrderedCollection()"\r    Date today. "29 September 2025"\r    Time now. "10:28:52.422 am"\r    UIManager default  request:\'How are you?\' initialAnswer:\'I\'\'m fine!\'. "\'I\'\'m fine!\'"\r    Integer readFrom: \'2013  1925\'. "2013"\r    Integer primesUpTo: 100. "#(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97)"\r    Rectangle origin:0@0 corner:200@100. "(0@0) corner: (200@100)"\r    Date nameOfMonth:12. "#December"\r    Date dayOfWeek: #Friday. "6"\r    Date orthodoxEasterDateFor: 2022. "24 April 2022"\r\r\r   \r"Інсталюйте вказані нижче МЕТОДИ КЛАСУ Date:\r  перенесіть копію тексту визначення методу з робочого вікна в браузер класів.\r\r""!Date class methodsFor: \'specific inquiries\' stamp: \'CamilloBruni 8/22/2013 19:47\'!""\r\rorthodoxEasterDateFor: year\r ""  compute the easter date according to the rules of the orthodox calendar.\r    source:       http://www.smart.net/~mmontes/ortheast.html   ""\r     | r1 r2 r3 r4 ra rb r5 rc date |\r\r    r1 := year \\\\ 19.\r    r2 := year \\\\ 4.\r    r3 := year \\\\ 7.\r    ra := 19*r1 + 16.\r    r4 := ra \\\\ 30.\r    rb := r2 + r2 + (4*r3) + (6*r4).\r    r5 := rb \\\\ 7.\r    rc := r4 + r5.\r    date := self year: year month: 4 day: 3.\r    ^date addDays: rc.\r""--------------------------------------------------------------------------------------""\r""!Date class methodsFor: \'specific inquiries\' stamp: \'CamilloBruni 8/22/2013 19:48\'!""\r\reasterDateFor: year\r ""  compute the easter date.\r    source: Physikalisch-Technische Bundesanstalt Braunschweig.\r    Lichtenberg, H.: Zur Interpretation der Gaussschen Osterformel und ihrer Ausnahmeregeln, Historia Mathematica 24 (1997), pp. 441-444\r      http://www.ptb.de/de/org/4/44/441/oste.htm  ""\r\r  | k m s a d r og sz oe day |\r\r  k := year // 100.\r  m := 15 + (3*k + 3//4) - (8*k + 13//25).\r   s := 2 - (3*k + 3// 4).\r  a := year \\\\ 19.\r  d := 19*a + m \\\\ 30.\r  r := d//29 + ((d//28) - (d//29)* (a// 11)).\r\r  og := 21 + d - r.\r  sz := 7 - (year//4 + year + s\\\\7).\r  oe := 7 - (og - sz\\\\7).\r  day := og + oe.\r  ^day <= 31\r    ifTrue: [ Date year: year month: 3 day: day ]\r    ifFalse: [ Date year: year month: 4 day: day - 31 ].\r"\r\r"Знайдіть роки, коли святкування припадають на один день."\r\ryearsWithMatchingEasterFrom: startYear to: endYear\r\r    | matchingYears orthodoxDate catholicDate |\r    matchingYears := OrderedCollection new.\r    (startYear to: endYear) do: [:year |\r        orthodoxDate := self orthodoxEasterDateFor: year.\r        catholicDate := self easterDateFor: year.\r        (orthodoxDate = catholicDate) ifTrue: [\r            matchingYears add: year\r        ].\r    ].\r    ^matchingYears asArray\r\rDate yearsWithMatchingEasterFrom: 2000 to: 2050. "#(2001 2004 2007 2010 2011 2014 2017 2025 2028 2031 2034 2037 2038 2041 2045 2048)"\r\r" ------ РЕКУРСІЯ\r  Додайте до класу Integer і випробуйте різні методи обчислення чисел  Фібоначчі.\r  Запропонуйте власні. Порівняйте їхню ефективність.      \r  Перед випробуванням fibonacci ЗБЕРЕЖІТЬ ІМІДЖ СИСТЕМИ! Він може зайняти Ваш комп на тиждень.  "\r\r3 fibStart: 1 with: 10  "12"\r4 fibo "5"\r12 fibonacci "233"\r\r\r\r\r\r"\r\r\r<fibStart:with:>\rЦе рекурсивний метод, який обчислює n-те число послідовності Фібоначчі, використовуючи два допоміжні параметри — n1 (попереднє значення) і n2 (передпопереднє значення). На кожному кроці рекурсії відбувається виклик:\r(self - 1) fibStart: n1 + n2 with: n1 — таким чином, наступний етап отримує нові значення, де поточне число стає сумою двох попередніх.\rТакий підхід дозволяє виконувати обчислення без повторних підрахунків уже відомих значень, тому алгоритм має лінійну складність O(n). Він працює швидко навіть для великих n і потребує мінімум пам’яті — лише для рекурсивних викликів (глибина дорівнює n).\r\r<fibo>\rЦе допоміжний метод, який просто викликає fibStart:with: із початковими значеннями. Його мета — спростити виклик функції, щоб не потрібно було вручну задавати перші два числа послідовності. Фактично, він працює так само, як і fibStart:with:, але зручніший у використанні, коли потрібно просто отримати n-те число Фібоначчі.\r\r<fibonacci>\rЦей варіант використовує класичне рекурсивне визначення:\rF(n) = F(n - 1) + F(n - 2)\rМетод простий у розумінні, але дуже неефективний для великих n, оскільки він не запам’ятовує вже обчислені значення і багаторазово виконує ті самі обчислення. Через це його складність є експоненційною — приблизно O(2ⁿ). При великих значеннях n така реалізація значно навантажує процесор і стек викликів, тому практично використовується лише для навчальних цілей або демонстрацій.\r"\r\r"------------------------------------------------------------------------------------\r ------ СТВОРЕННЯ, ОПРАЦЮВАННЯ КОЛЕКЦІЙ\r  У текстовому файлі записано інформацію про матрицю цілих чисел: розміри\r  матриці в першому рядку файла, у всіх наступних рядках - рядки матриці.}\r  Прочитати матрицю, знайти максимальні елементи кожного рядка і зберегти\r  їх у файлі. Надрукувати максимальний елемент цілої матриці."\r\r"Наведений нижче код можна виконати безпосередньо в робочому вікні,\r проте,  доцільно зробити його методом власного навчального класу."\r\r| matr fStream fName n m mMatr mLines |\r        "Вибір файла за допомогою діалогу"\r    (fName:=UIManager default\r\t\t\tchooseFullFileNameMatching: nil \r\t\t\tlabel: \'Виберіть файл з числовими даними\' ) isNil\r        ifTrue: [ ^\'Ви не вибрали файла\' ]. \r        fStream := fName asFileReference readStream.\r\t        "Введення даних"\r \t    n := Integer readFrom: fStream.  \r\t    matr := Array new: n.\r\t    m := Integer readFrom: fStream.\r\t    matr := matr collect: [ :x | Array new: m ]. \r\t    1 to: n do: [ :i |  fStream nextLine.\r \t\t     matr at: i put: (\r\t\t\t\t (matr at: i) collect: [ :x |  \r\t\t\t\t\t\tInteger readFrom: fStream. ]\r\t\t\t\t\t )\t ].\r    fStream close. matr inspect.\r        "Обчислення максимальних елементів"\r    mLines:=matr collect: [ :r | r inject: (r at: 1) into: [ :x :y | x max: y] ].\r    mMatr:=mLines at: 1.\r    mLines do: [ :x | x > mMatr ifTrue: [ mMatr := x ] ].\r        "Побудова імені файла результатів, збереження"\r    fName at: fName size - 4 put: $_ .\r    fStream := fName asFileReference writeStream.\r    mLines do: [ :x | x printOn: fStream. fStream cr ].\r    fStream close.\r    ^mMatr .  \r\r" Поясніть код, наведений вище (кожне повідомлення!):\r\r\tУ цьому коді ми працюємо з матрицею чисел, зчитаною з файлу. Спершу оголошуємо локальні змінні для зберігання самої матриці, потоку файлу, імені файлу, кількості рядків і стовпців, а також для проміжних результатів. Далі відкривається діалог для вибору файлу користувачем. Якщо файл не обрано, метод одразу повертає повідомлення про це і подальше виконання коду зупиняється.\r\rПісля цього створюється потік для читання файлу. Перше число з файлу визначає кількість рядків матриці, а друге число — кількість стовпців. У початковій версії матриця реалізується як масив масивів: спершу створюємо масив для рядків, а потім кожен рядок заповнюємо окремим масивом стовпців. Потік закривається після зчитування даних, і відкривається інспектор для перегляду структури матриці.\r\rЩоб знайти максимуми рядків, кожен рядок обробляється за допомогою методу inject, який проходить усі елементи рядка і визначає найбільше значення. Потім, перебираючи всі максимуми рядків, знаходиться загальний максимум усієї матриці. Після обробки результатів ім’я файлу змінюється для збереження результатів у новий файл, відкривається потік на запис, і кожен максимум рядка записується в файл на окремий рядок. Потім потік закривається. Нарешті, метод повертає максимальний елемент усієї матриці.\r\r   Як можна замінити масив масивів на екземпляр класу Matrix?:\r\tЯкщо використовувати клас Matrix, код можна зробити більш компактним і зручним. Клас Matrix зберігає матрицю як єдину структуру n × m, і доступ до елементів відбувається через at: i at: j, що виключає необхідність створювати масив масивів. Спочатку відкриваємо потік для читання файлу і зчитуємо розміри матриці. Потім створюємо об’єкт Matrix відповідного розміру і заповнюємо його числами з файлу. Далі, перебираючи рядки та стовпці, за допомогою вкладених inject визначаємо максимальні значення для кожного рядка та загальний максимум матриці. Результат повертається як вихідний максимум. Такий підхід дозволяє робити код більш структурованим і компактним, позбавляє зайвих проміжних масивів і робить роботу з матрицею наочнішою.\r======================================================"\r\r"------ АДРЕСНА КНИГА\r Приклад створення і використання адресної книги, описаний у одній з лекцій. \r Пригадуєте, спочатку оголошуємо глобальну змінну, що міститиме впорядковану \r колекцію масивів з трьох рядків. Спосіб порівняння описує бінарний блок."\r\r    Smalltalk globals at: #AddressBook\r              put:(SortedCollection sortBlock:[:a :b | (a at:1)<=(b at:1)]).\r\r" * --- Тепер до книги можна додавати записи. "\r\r    AddressBook\r            add: #(\'Ruth\' \'Babe\' \'456 Mudville Flats\');\r            add: #(\'Smith\' \'John\' \'12/5 Park Ave\');\r            add: #(\'Jexon\' \'John\' \'5 Baverli Hills\');\r            add: #(\'Adams\' \'John\' \'1 Hell str\');\r            add: #(\'Taylor\' \'Babe\' \'2a/35 Deribas str\');\r            add: #(\'Greg\' \'Voss\' \'12345 the USA\').\r\r" * --- Додайте власні записи. Видрукуйте вміст книги (код запропоновано нижче).  "\r\r   | s w |  s := WriteStream on: String new.\r    AddressBook do:[:x | x do:\r        [ :y | s nextPutAll: y; tab; tab.].\r        s cr. ].\r  w := Workspace openLabel: \'My Address Book\'.\r  w contents: s contents.\r\r" * ----  Наступне завдання - надрукувати список прізвищ людей з однаковими іменами. \r              Приклад демонструє різні способи перебору та перетворення колекцій."\r\r | firstNames duplicates |\r    firstNames:=Bag new.        "утворимо торбу імен"\r    AddressBook do: [ :entry | firstNames add: (entry at: 2) ].\r        ""виберемо ті імена, які зустрічаються більше одного разу""\r    duplicates:=firstNames select:\r        [ :name | (firstNames occurrencesOf: name)>1 ].\r            ""і впорядкуємо їх""\r    duplicates:=duplicates asSet asSortedCollection.\r        ""друкуємо імена та відповідні їм прізвища""\r    duplicates do: [ :first | first printOn: Transcript. Transcript show:\'==>\'.\r        AddressBook do: [ :entry | (entry at: 2)=first\r            ifTrue: [ Transcript show:\' \'. (entry at: 1) printOn: Transcript ] ].\r        Transcript cr ]. Transcript show:\' \'.\r\r"Поясніть перетворення, що відбуваються в цьому фрагменті. \r   Запропонуйте власні варіанти використання та перетворення колекцій. \r   Оформіть запропоновані вище фрагменти як методи навчального класу."\r\r\r"------ ДОДАВАННЯ АДРЕС\r  Можливо, додавання записів до AddressBook за допомогою явного програмування \r  виглядає не надто привабливо. Використайте з цією метою діалоги "\r\r| a b c | \ra := UIManager default request: \'Input first name\'.\rb := UIManager default request: \'Input second name\'.\rc := UIManager default request: \'Input address\'.\ra isNil | b isNil | c isNil ifFalse: [ AddressBook add: (Array with:a with:b with:c)].\r\r"Додайте до книги декілька нових записів, знову видрукуйте її. "\r                                    \r" Поміркуйте, як зробити зручнішим звертання до діалогу додавання адрес та друку адресної книги. "\r\r\r"Що станеться, якщо виконати наступний код? Випробуйте. "\r    Smalltalk globals removeKey:#AddressBook.\r\r\r "------ ПЕРЕТВОРЕННЯ (ПЕРЕВТІЛЕННЯ) ОБ\'ЄКТІВ\r   Виконайте за допомогою Do It. "\r\r | a b c|\r    a := OrderedCollection new.\r    b := Cylinder  new.\r    c := Array with: a with: b with: b.\r    Transcript show: \'Old Array is = \'.\r    c do: [ :x | Transcript show: \'     \'. x printOn: Transcript ].\r    Transcript cr.\r    a become: b.\r    Transcript show: \'New Array is = \'.\r    c do: [ :x | Transcript show: \'     \'. x printOn: Transcript ].\r    Transcript cr; show:\' \'.\r" Поясніть дію методу become:. Чи можна замість нього користуватися звичайним присвоєнням? Наведіть власні приклади. "\r\r" Він міняє всі посилання на два об’єкти місцями у всій системі.  \r  Не можна замість become використовувати звичайне присвоєння, адже такого ефекту не можливо буде досягнути."\r\r\r\r\r\r\r\r'
}OmEntry {
	#tags : {
		#timestamp : DateAndTime [ '2025-10-05T00:10:31.054+03:00' ],
		#self : OmReference [ '29' ]
	},
	#content : '"--------------------------------------------------------------------------------------\r*                      ЛАБОРОТОРНА РОБОТА 3\r*                 Тема: КЛАСИ ТА МЕТОДИ. КОЛЕКЦІЇ\r*\r*  Завдання до лабораторної роботи:\r*     1. Виконайте наведені нижче приклади, збережіть і поясніть отримані результати.\r*     2. Випробуйте різноманітні способи додавання нових класів до системи.\r*     3. Навчіться доповнювати функціональність класів.\r*     4. Випробуйте методи опрацювання колекцій.\r*\r\r    Виконайте за допомогою <Print it> \r\r ------ ПРИНАЛЕЖНІСТЬ КЛАСОВІ, ІЄРАРХІЯ КЛАСІВ\r"\r    #(Francesca Jackie Marisa Bree) class. "Array"\r    (#(Francesca Jackie Marisa Bree) at:2) class. "ByteSymbol"\r    \'Rakesh Vijay Charles Daniel Tyler\' class. "ByteString"\r    (\'Rakesh Vijay Charles Daniel Tyler\' at:2) class. "Character (a)"\r    World class . "WorldMorph"\r    Magnitude class. "Magnitude class"\r    Magnitude class class. "Metaclass"\r    nil class. "UndefinedObject"\r    5 species. "SmallInteger"\r    123456789000 species. "SmallInteger"\r    #aName species. "ByteString"\r " Яка різниця між повідомленнями class i species ? \r\r    Випробуйте різні способи відкривання браузера класів: за допомогою меню чи програмно \r     Виконайте за допомогою <Do it>\r"\r    ClyFullBrowserMorph open. \r    ClyFullBrowserMorph openOnClass: Date. \r    ClyFullBrowserMorph openOnClass: VolumeShape  selector:  #volume. \r\r" ------ МЕТОДИ КЛАСУ, КОНСТРУКТОРИ\r  Виконайте за допомогою <Print It>. Запропонуйте власні приклади. "\r\r    Array new: 10. "#(nil nil nil nil nil nil nil nil nil nil)"        \r    OrderedCollection  new. "an OrderedCollection()"\r    Date today. "29 September 2025"\r    Time now. "10:28:52.422 am"\r    UIManager default  request:\'How are you?\' initialAnswer:\'I\'\'m fine!\'. "\'I\'\'m fine!\'"\r    Integer readFrom: \'2013  1925\'. "2013"\r    Integer primesUpTo: 100. "#(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97)"\r    Rectangle origin:0@0 corner:200@100. "(0@0) corner: (200@100)"\r    Date nameOfMonth:12. "#December"\r    Date dayOfWeek: #Friday. "6"\r    Date orthodoxEasterDateFor: 2022. "24 April 2022"\r\r\r   \r"Інсталюйте вказані нижче МЕТОДИ КЛАСУ Date:\r  перенесіть копію тексту визначення методу з робочого вікна в браузер класів.\r\r""!Date class methodsFor: \'specific inquiries\' stamp: \'CamilloBruni 8/22/2013 19:47\'!""\r\rorthodoxEasterDateFor: year\r ""  compute the easter date according to the rules of the orthodox calendar.\r    source:       http://www.smart.net/~mmontes/ortheast.html   ""\r     | r1 r2 r3 r4 ra rb r5 rc date |\r\r    r1 := year \\\\ 19.\r    r2 := year \\\\ 4.\r    r3 := year \\\\ 7.\r    ra := 19*r1 + 16.\r    r4 := ra \\\\ 30.\r    rb := r2 + r2 + (4*r3) + (6*r4).\r    r5 := rb \\\\ 7.\r    rc := r4 + r5.\r    date := self year: year month: 4 day: 3.\r    ^date addDays: rc.\r""--------------------------------------------------------------------------------------""\r""!Date class methodsFor: \'specific inquiries\' stamp: \'CamilloBruni 8/22/2013 19:48\'!""\r\reasterDateFor: year\r ""  compute the easter date.\r    source: Physikalisch-Technische Bundesanstalt Braunschweig.\r    Lichtenberg, H.: Zur Interpretation der Gaussschen Osterformel und ihrer Ausnahmeregeln, Historia Mathematica 24 (1997), pp. 441-444\r      http://www.ptb.de/de/org/4/44/441/oste.htm  ""\r\r  | k m s a d r og sz oe day |\r\r  k := year // 100.\r  m := 15 + (3*k + 3//4) - (8*k + 13//25).\r   s := 2 - (3*k + 3// 4).\r  a := year \\\\ 19.\r  d := 19*a + m \\\\ 30.\r  r := d//29 + ((d//28) - (d//29)* (a// 11)).\r\r  og := 21 + d - r.\r  sz := 7 - (year//4 + year + s\\\\7).\r  oe := 7 - (og - sz\\\\7).\r  day := og + oe.\r  ^day <= 31\r    ifTrue: [ Date year: year month: 3 day: day ]\r    ifFalse: [ Date year: year month: 4 day: day - 31 ].\r"\r\r"Знайдіть роки, коли святкування припадають на один день."\r\ryearsWithMatchingEasterFrom: startYear to: endYear\r\r    | matchingYears orthodoxDate catholicDate |\r    matchingYears := OrderedCollection new.\r    (startYear to: endYear) do: [:year |\r        orthodoxDate := self orthodoxEasterDateFor: year.\r        catholicDate := self easterDateFor: year.\r        (orthodoxDate = catholicDate) ifTrue: [\r            matchingYears add: year\r        ].\r    ].\r    ^matchingYears asArray\r\rDate yearsWithMatchingEasterFrom: 2000 to: 2050. "#(2001 2004 2007 2010 2011 2014 2017 2025 2028 2031 2034 2037 2038 2041 2045 2048)"\r\r" ------ РЕКУРСІЯ\r  Додайте до класу Integer і випробуйте різні методи обчислення чисел  Фібоначчі.\r  Запропонуйте власні. Порівняйте їхню ефективність.      \r  Перед випробуванням fibonacci ЗБЕРЕЖІТЬ ІМІДЖ СИСТЕМИ! Він може зайняти Ваш комп на тиждень.  "\r\r3 fibStart: 1 with: 10  "12"\r4 fibo "5"\r12 fibonacci "233"\r\r\r\r\r\r"\r\r\r<fibStart:with:>\rЦе рекурсивний метод, який обчислює n-те число послідовності Фібоначчі, використовуючи два допоміжні параметри — n1 (попереднє значення) і n2 (передпопереднє значення). На кожному кроці рекурсії відбувається виклик:\r(self - 1) fibStart: n1 + n2 with: n1 — таким чином, наступний етап отримує нові значення, де поточне число стає сумою двох попередніх.\rТакий підхід дозволяє виконувати обчислення без повторних підрахунків уже відомих значень, тому алгоритм має лінійну складність O(n). Він працює швидко навіть для великих n і потребує мінімум пам’яті — лише для рекурсивних викликів (глибина дорівнює n).\r\r<fibo>\rЦе допоміжний метод, який просто викликає fibStart:with: із початковими значеннями. Його мета — спростити виклик функції, щоб не потрібно було вручну задавати перші два числа послідовності. Фактично, він працює так само, як і fibStart:with:, але зручніший у використанні, коли потрібно просто отримати n-те число Фібоначчі.\r\r<fibonacci>\rЦей варіант використовує класичне рекурсивне визначення:\rF(n) = F(n - 1) + F(n - 2)\rМетод простий у розумінні, але дуже неефективний для великих n, оскільки він не запам’ятовує вже обчислені значення і багаторазово виконує ті самі обчислення. Через це його складність є експоненційною — приблизно O(2ⁿ). При великих значеннях n така реалізація значно навантажує процесор і стек викликів, тому практично використовується лише для навчальних цілей або демонстрацій.\r"\r\r"------------------------------------------------------------------------------------\r ------ СТВОРЕННЯ, ОПРАЦЮВАННЯ КОЛЕКЦІЙ\r  У текстовому файлі записано інформацію про матрицю цілих чисел: розміри\r  матриці в першому рядку файла, у всіх наступних рядках - рядки матриці.}\r  Прочитати матрицю, знайти максимальні елементи кожного рядка і зберегти\r  їх у файлі. Надрукувати максимальний елемент цілої матриці."\r\r"Наведений нижче код можна виконати безпосередньо в робочому вікні,\r проте,  доцільно зробити його методом власного навчального класу."\r\r| matr fStream fName n m mMatr mLines |\r        "Вибір файла за допомогою діалогу"\r    (fName:=UIManager default\r\t\t\tchooseFullFileNameMatching: nil \r\t\t\tlabel: \'Виберіть файл з числовими даними\' ) isNil\r        ifTrue: [ ^\'Ви не вибрали файла\' ]. \r        fStream := fName asFileReference readStream.\r\t        "Введення даних"\r \t    n := Integer readFrom: fStream.  \r\t    matr := Array new: n.\r\t    m := Integer readFrom: fStream.\r\t    matr := matr collect: [ :x | Array new: m ]. \r\t    1 to: n do: [ :i |  fStream nextLine.\r \t\t     matr at: i put: (\r\t\t\t\t (matr at: i) collect: [ :x |  \r\t\t\t\t\t\tInteger readFrom: fStream. ]\r\t\t\t\t\t )\t ].\r    fStream close. matr inspect.\r        "Обчислення максимальних елементів"\r    mLines:=matr collect: [ :r | r inject: (r at: 1) into: [ :x :y | x max: y] ].\r    mMatr:=mLines at: 1.\r    mLines do: [ :x | x > mMatr ifTrue: [ mMatr := x ] ].\r        "Побудова імені файла результатів, збереження"\r    fName at: fName size - 4 put: $_ .\r    fStream := fName asFileReference writeStream.\r    mLines do: [ :x | x printOn: fStream. fStream cr ].\r    fStream close.\r    ^mMatr .  \r\r" Поясніть код, наведений вище (кожне повідомлення!):\r\r\tУ цьому коді ми працюємо з матрицею чисел, зчитаною з файлу. Спершу оголошуємо локальні змінні для зберігання самої матриці, потоку файлу, імені файлу, кількості рядків і стовпців, а також для проміжних результатів. Далі відкривається діалог для вибору файлу користувачем. Якщо файл не обрано, метод одразу повертає повідомлення про це і подальше виконання коду зупиняється.\r\rПісля цього створюється потік для читання файлу. Перше число з файлу визначає кількість рядків матриці, а друге число — кількість стовпців. У початковій версії матриця реалізується як масив масивів: спершу створюємо масив для рядків, а потім кожен рядок заповнюємо окремим масивом стовпців. Потік закривається після зчитування даних, і відкривається інспектор для перегляду структури матриці.\r\rЩоб знайти максимуми рядків, кожен рядок обробляється за допомогою методу inject, який проходить усі елементи рядка і визначає найбільше значення. Потім, перебираючи всі максимуми рядків, знаходиться загальний максимум усієї матриці. Після обробки результатів ім’я файлу змінюється для збереження результатів у новий файл, відкривається потік на запис, і кожен максимум рядка записується в файл на окремий рядок. Потім потік закривається. Нарешті, метод повертає максимальний елемент усієї матриці.\r\r   Як можна замінити масив масивів на екземпляр класу Matrix?:\r\tЯкщо використовувати клас Matrix, код можна зробити більш компактним і зручним. Клас Matrix зберігає матрицю як єдину структуру n × m, і доступ до елементів відбувається через at: i at: j, що виключає необхідність створювати масив масивів. Спочатку відкриваємо потік для читання файлу і зчитуємо розміри матриці. Потім створюємо об’єкт Matrix відповідного розміру і заповнюємо його числами з файлу. Далі, перебираючи рядки та стовпці, за допомогою вкладених inject визначаємо максимальні значення для кожного рядка та загальний максимум матриці. Результат повертається як вихідний максимум. Такий підхід дозволяє робити код більш структурованим і компактним, позбавляє зайвих проміжних масивів і робить роботу з матрицею наочнішою.\r======================================================"\r\r"------ АДРЕСНА КНИГА\r Приклад створення і використання адресної книги, описаний у одній з лекцій. \r Пригадуєте, спочатку оголошуємо глобальну змінну, що міститиме впорядковану \r колекцію масивів з трьох рядків. Спосіб порівняння описує бінарний блок."\r\r    Smalltalk globals at: #AddressBook\r              put:(SortedCollection sortBlock:[:a :b | (a at:1)<=(b at:1)]).\r\r" * --- Тепер до книги можна додавати записи. "\r\r    AddressBook\r            add: #(\'Ruth\' \'Babe\' \'456 Mudville Flats\');\r            add: #(\'Smith\' \'John\' \'12/5 Park Ave\');\r            add: #(\'Jexon\' \'John\' \'5 Baverli Hills\');\r            add: #(\'Adams\' \'John\' \'1 Hell str\');\r            add: #(\'Taylor\' \'Babe\' \'2a/35 Deribas str\');\r            add: #(\'Greg\' \'Voss\' \'12345 the USA\').\r\r" * --- Додайте власні записи. Видрукуйте вміст книги (код запропоновано нижче).  "\r\r   | s w |  s := WriteStream on: String new.\r    AddressBook do:[:x | x do:\r        [ :y | s nextPutAll: y; tab; tab.].\r        s cr. ].\r  w := Workspace openLabel: \'My Address Book\'.\r  w contents: s contents.\r\r" * ----  Наступне завдання - надрукувати список прізвищ людей з однаковими іменами. \r              Приклад демонструє різні способи перебору та перетворення колекцій."\r\r | firstNames duplicates |\r    firstNames:=Bag new.        "утворимо торбу імен"\r    AddressBook do: [ :entry | firstNames add: (entry at: 2) ].\r        ""виберемо ті імена, які зустрічаються більше одного разу""\r    duplicates:=firstNames select:\r        [ :name | (firstNames occurrencesOf: name)>1 ].\r            ""і впорядкуємо їх""\r    duplicates:=duplicates asSet asSortedCollection.\r        ""друкуємо імена та відповідні їм прізвища""\r    duplicates do: [ :first | first printOn: Transcript. Transcript show:\'==>\'.\r        AddressBook do: [ :entry | (entry at: 2)=first\r            ifTrue: [ Transcript show:\' \'. (entry at: 1) printOn: Transcript ] ].\r        Transcript cr ]. Transcript show:\' \'.\r\r"Поясніть перетворення, що відбуваються в цьому фрагменті. \r   Запропонуйте власні варіанти використання та перетворення колекцій. \r   Оформіть запропоновані вище фрагменти як методи навчального класу."\r\r\r"------ ДОДАВАННЯ АДРЕС\r  Можливо, додавання записів до AddressBook за допомогою явного програмування \r  виглядає не надто привабливо. Використайте з цією метою діалоги "\r\r| a b c | \ra := UIManager default request: \'Input first name\'.\rb := UIManager default request: \'Input second name\'.\rc := UIManager default request: \'Input address\'.\ra isNil | b isNil | c isNil ifFalse: [ AddressBook add: (Array with:a with:b with:c)].\r\r"Додайте до книги декілька нових записів, знову видрукуйте її. "\r                                    \r" Поміркуйте, як зробити зручнішим звертання до діалогу додавання адрес та друку адресної книги. "\r\r\r"Що станеться, якщо виконати наступний код? Випробуйте. "\r    Smalltalk globals removeKey:#AddressBook.\r""\r\r "------ ПЕРЕТВОРЕННЯ (ПЕРЕВТІЛЕННЯ) ОБ\'ЄКТІВ\r   Виконайте за допомогою Do It. "\r\r | a b c|\r    a := OrderedCollection new.\r    b := Cylinder  new.\r    c := Array with: a with: b with: b.\r    Transcript show: \'Old Array is = \'.\r    c do: [ :x | Transcript show: \'     \'. x printOn: Transcript ].\r    Transcript cr.\r    a become: b.\r    Transcript show: \'New Array is = \'.\r    c do: [ :x | Transcript show: \'     \'. x printOn: Transcript ].\r    Transcript cr; show:\' \'. "Unknown variable"\r" Поясніть дію методу become:. Чи можна замість нього користуватися звичайним присвоєнням? Наведіть власні приклади. "\r\r" Він міняє всі посилання на два об’єкти місцями у всій системі.  \r  Не можна замість become використовувати звичайне присвоєння, адже такого ефекту не можливо буде досягнути."\r\r\r\r\r\r\r\r'
}OmEntry {
	#tags : {
		#timestamp : DateAndTime [ '2025-10-05T00:11:39.005+03:00' ],
		#self : OmReference [ '30' ]
	},
	#content : '"--------------------------------------------------------------------------------------\r*                      ЛАБОРОТОРНА РОБОТА 3\r*                 Тема: КЛАСИ ТА МЕТОДИ. КОЛЕКЦІЇ\r*\r*  Завдання до лабораторної роботи:\r*     1. Виконайте наведені нижче приклади, збережіть і поясніть отримані результати.\r*     2. Випробуйте різноманітні способи додавання нових класів до системи.\r*     3. Навчіться доповнювати функціональність класів.\r*     4. Випробуйте методи опрацювання колекцій.\r*\r\r    Виконайте за допомогою <Print it> \r\r ------ ПРИНАЛЕЖНІСТЬ КЛАСОВІ, ІЄРАРХІЯ КЛАСІВ\r"\r    #(Francesca Jackie Marisa Bree) class. "Array"\r    (#(Francesca Jackie Marisa Bree) at:2) class. "ByteSymbol"\r    \'Rakesh Vijay Charles Daniel Tyler\' class. "ByteString"\r    (\'Rakesh Vijay Charles Daniel Tyler\' at:2) class. "Character (a)"\r    World class . "WorldMorph"\r    Magnitude class. "Magnitude class"\r    Magnitude class class. "Metaclass"\r    nil class. "UndefinedObject"\r    5 species. "SmallInteger"\r    123456789000 species. "SmallInteger"\r    #aName species. "ByteString"\r " Яка різниця між повідомленнями class i species ? \r\r    Випробуйте різні способи відкривання браузера класів: за допомогою меню чи програмно \r     Виконайте за допомогою <Do it>\r"\r    ClyFullBrowserMorph open. \r    ClyFullBrowserMorph openOnClass: Date. \r    ClyFullBrowserMorph openOnClass: VolumeShape  selector:  #volume. \r\r" ------ МЕТОДИ КЛАСУ, КОНСТРУКТОРИ\r  Виконайте за допомогою <Print It>. Запропонуйте власні приклади. "\r\r    Array new: 10. "#(nil nil nil nil nil nil nil nil nil nil)"        \r    OrderedCollection  new. "an OrderedCollection()"\r    Date today. "29 September 2025"\r    Time now. "10:28:52.422 am"\r    UIManager default  request:\'How are you?\' initialAnswer:\'I\'\'m fine!\'. "\'I\'\'m fine!\'"\r    Integer readFrom: \'2013  1925\'. "2013"\r    Integer primesUpTo: 100. "#(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97)"\r    Rectangle origin:0@0 corner:200@100. "(0@0) corner: (200@100)"\r    Date nameOfMonth:12. "#December"\r    Date dayOfWeek: #Friday. "6"\r    Date orthodoxEasterDateFor: 2022. "24 April 2022"\r\r\r   \r"Інсталюйте вказані нижче МЕТОДИ КЛАСУ Date:\r  перенесіть копію тексту визначення методу з робочого вікна в браузер класів.\r\r""!Date class methodsFor: \'specific inquiries\' stamp: \'CamilloBruni 8/22/2013 19:47\'!""\r\rorthodoxEasterDateFor: year\r ""  compute the easter date according to the rules of the orthodox calendar.\r    source:       http://www.smart.net/~mmontes/ortheast.html   ""\r     | r1 r2 r3 r4 ra rb r5 rc date |\r\r    r1 := year \\\\ 19.\r    r2 := year \\\\ 4.\r    r3 := year \\\\ 7.\r    ra := 19*r1 + 16.\r    r4 := ra \\\\ 30.\r    rb := r2 + r2 + (4*r3) + (6*r4).\r    r5 := rb \\\\ 7.\r    rc := r4 + r5.\r    date := self year: year month: 4 day: 3.\r    ^date addDays: rc.\r""--------------------------------------------------------------------------------------""\r""!Date class methodsFor: \'specific inquiries\' stamp: \'CamilloBruni 8/22/2013 19:48\'!""\r\reasterDateFor: year\r ""  compute the easter date.\r    source: Physikalisch-Technische Bundesanstalt Braunschweig.\r    Lichtenberg, H.: Zur Interpretation der Gaussschen Osterformel und ihrer Ausnahmeregeln, Historia Mathematica 24 (1997), pp. 441-444\r      http://www.ptb.de/de/org/4/44/441/oste.htm  ""\r\r  | k m s a d r og sz oe day |\r\r  k := year // 100.\r  m := 15 + (3*k + 3//4) - (8*k + 13//25).\r   s := 2 - (3*k + 3// 4).\r  a := year \\\\ 19.\r  d := 19*a + m \\\\ 30.\r  r := d//29 + ((d//28) - (d//29)* (a// 11)).\r\r  og := 21 + d - r.\r  sz := 7 - (year//4 + year + s\\\\7).\r  oe := 7 - (og - sz\\\\7).\r  day := og + oe.\r  ^day <= 31\r    ifTrue: [ Date year: year month: 3 day: day ]\r    ifFalse: [ Date year: year month: 4 day: day - 31 ].\r"\r\r"Знайдіть роки, коли святкування припадають на один день."\r\ryearsWithMatchingEasterFrom: startYear to: endYear\r\r    | matchingYears orthodoxDate catholicDate |\r    matchingYears := OrderedCollection new.\r    (startYear to: endYear) do: [:year |\r        orthodoxDate := self orthodoxEasterDateFor: year.\r        catholicDate := self easterDateFor: year.\r        (orthodoxDate = catholicDate) ifTrue: [\r            matchingYears add: year\r        ].\r    ].\r    ^matchingYears asArray\r\rDate yearsWithMatchingEasterFrom: 2000 to: 2050. "#(2001 2004 2007 2010 2011 2014 2017 2025 2028 2031 2034 2037 2038 2041 2045 2048)"\r\r" ------ РЕКУРСІЯ\r  Додайте до класу Integer і випробуйте різні методи обчислення чисел  Фібоначчі.\r  Запропонуйте власні. Порівняйте їхню ефективність.      \r  Перед випробуванням fibonacci ЗБЕРЕЖІТЬ ІМІДЖ СИСТЕМИ! Він може зайняти Ваш комп на тиждень.  "\r\r3 fibStart: 1 with: 10  "12"\r4 fibo "5"\r12 fibonacci "233"\r\r\r\r\r\r"\r\r\r<fibStart:with:>\rЦе рекурсивний метод, який обчислює n-те число послідовності Фібоначчі, використовуючи два допоміжні параметри — n1 (попереднє значення) і n2 (передпопереднє значення). На кожному кроці рекурсії відбувається виклик:\r(self - 1) fibStart: n1 + n2 with: n1 — таким чином, наступний етап отримує нові значення, де поточне число стає сумою двох попередніх.\rТакий підхід дозволяє виконувати обчислення без повторних підрахунків уже відомих значень, тому алгоритм має лінійну складність O(n). Він працює швидко навіть для великих n і потребує мінімум пам’яті — лише для рекурсивних викликів (глибина дорівнює n).\r\r<fibo>\rЦе допоміжний метод, який просто викликає fibStart:with: із початковими значеннями. Його мета — спростити виклик функції, щоб не потрібно було вручну задавати перші два числа послідовності. Фактично, він працює так само, як і fibStart:with:, але зручніший у використанні, коли потрібно просто отримати n-те число Фібоначчі.\r\r<fibonacci>\rЦей варіант використовує класичне рекурсивне визначення:\rF(n) = F(n - 1) + F(n - 2)\rМетод простий у розумінні, але дуже неефективний для великих n, оскільки він не запам’ятовує вже обчислені значення і багаторазово виконує ті самі обчислення. Через це його складність є експоненційною — приблизно O(2ⁿ). При великих значеннях n така реалізація значно навантажує процесор і стек викликів, тому практично використовується лише для навчальних цілей або демонстрацій.\r"\r\r"------------------------------------------------------------------------------------\r ------ СТВОРЕННЯ, ОПРАЦЮВАННЯ КОЛЕКЦІЙ\r  У текстовому файлі записано інформацію про матрицю цілих чисел: розміри\r  матриці в першому рядку файла, у всіх наступних рядках - рядки матриці.}\r  Прочитати матрицю, знайти максимальні елементи кожного рядка і зберегти\r  їх у файлі. Надрукувати максимальний елемент цілої матриці."\r\r"Наведений нижче код можна виконати безпосередньо в робочому вікні,\r проте,  доцільно зробити його методом власного навчального класу."\r\r| matr fStream fName n m mMatr mLines |\r        "Вибір файла за допомогою діалогу"\r    (fName:=UIManager default\r\t\t\tchooseFullFileNameMatching: nil \r\t\t\tlabel: \'Виберіть файл з числовими даними\' ) isNil\r        ifTrue: [ ^\'Ви не вибрали файла\' ]. \r        fStream := fName asFileReference readStream.\r\t        "Введення даних"\r \t    n := Integer readFrom: fStream.  \r\t    matr := Array new: n.\r\t    m := Integer readFrom: fStream.\r\t    matr := matr collect: [ :x | Array new: m ]. \r\t    1 to: n do: [ :i |  fStream nextLine.\r \t\t     matr at: i put: (\r\t\t\t\t (matr at: i) collect: [ :x |  \r\t\t\t\t\t\tInteger readFrom: fStream. ]\r\t\t\t\t\t )\t ].\r    fStream close. matr inspect.\r        "Обчислення максимальних елементів"\r    mLines:=matr collect: [ :r | r inject: (r at: 1) into: [ :x :y | x max: y] ].\r    mMatr:=mLines at: 1.\r    mLines do: [ :x | x > mMatr ifTrue: [ mMatr := x ] ].\r        "Побудова імені файла результатів, збереження"\r    fName at: fName size - 4 put: $_ .\r    fStream := fName asFileReference writeStream.\r    mLines do: [ :x | x printOn: fStream. fStream cr ].\r    fStream close.\r    ^mMatr .  \r\r" Поясніть код, наведений вище (кожне повідомлення!):\r\r\tУ цьому коді ми працюємо з матрицею чисел, зчитаною з файлу. Спершу оголошуємо локальні змінні для зберігання самої матриці, потоку файлу, імені файлу, кількості рядків і стовпців, а також для проміжних результатів. Далі відкривається діалог для вибору файлу користувачем. Якщо файл не обрано, метод одразу повертає повідомлення про це і подальше виконання коду зупиняється.\r\rПісля цього створюється потік для читання файлу. Перше число з файлу визначає кількість рядків матриці, а друге число — кількість стовпців. У початковій версії матриця реалізується як масив масивів: спершу створюємо масив для рядків, а потім кожен рядок заповнюємо окремим масивом стовпців. Потік закривається після зчитування даних, і відкривається інспектор для перегляду структури матриці.\r\rЩоб знайти максимуми рядків, кожен рядок обробляється за допомогою методу inject, який проходить усі елементи рядка і визначає найбільше значення. Потім, перебираючи всі максимуми рядків, знаходиться загальний максимум усієї матриці. Після обробки результатів ім’я файлу змінюється для збереження результатів у новий файл, відкривається потік на запис, і кожен максимум рядка записується в файл на окремий рядок. Потім потік закривається. Нарешті, метод повертає максимальний елемент усієї матриці.\r\r   Як можна замінити масив масивів на екземпляр класу Matrix?:\r\tЯкщо використовувати клас Matrix, код можна зробити більш компактним і зручним. Клас Matrix зберігає матрицю як єдину структуру n × m, і доступ до елементів відбувається через at: i at: j, що виключає необхідність створювати масив масивів. Спочатку відкриваємо потік для читання файлу і зчитуємо розміри матриці. Потім створюємо об’єкт Matrix відповідного розміру і заповнюємо його числами з файлу. Далі, перебираючи рядки та стовпці, за допомогою вкладених inject визначаємо максимальні значення для кожного рядка та загальний максимум матриці. Результат повертається як вихідний максимум. Такий підхід дозволяє робити код більш структурованим і компактним, позбавляє зайвих проміжних масивів і робить роботу з матрицею наочнішою.\r======================================================"\r\r"------ АДРЕСНА КНИГА\r Приклад створення і використання адресної книги, описаний у одній з лекцій. \r Пригадуєте, спочатку оголошуємо глобальну змінну, що міститиме впорядковану \r колекцію масивів з трьох рядків. Спосіб порівняння описує бінарний блок."\r\r    Smalltalk globals at: #AddressBook\r              put:(SortedCollection sortBlock:[:a :b | (a at:1)<=(b at:1)]).\r\r" * --- Тепер до книги можна додавати записи. "\r\r    AddressBook\r            add: #(\'Ruth\' \'Babe\' \'456 Mudville Flats\');\r            add: #(\'Smith\' \'John\' \'12/5 Park Ave\');\r            add: #(\'Jexon\' \'John\' \'5 Baverli Hills\');\r            add: #(\'Adams\' \'John\' \'1 Hell str\');\r            add: #(\'Taylor\' \'Babe\' \'2a/35 Deribas str\');\r            add: #(\'Greg\' \'Voss\' \'12345 the USA\').\r\r" * --- Додайте власні записи. Видрукуйте вміст книги (код запропоновано нижче).  "\r\r   | s w |  s := WriteStream on: String new.\r    AddressBook do:[:x | x do:\r        [ :y | s nextPutAll: y; tab; tab.].\r        s cr. ].\r  w := Workspace openLabel: \'My Address Book\'.\r  w contents: s contents.\r\r" * ----  Наступне завдання - надрукувати список прізвищ людей з однаковими іменами. \r              Приклад демонструє різні способи перебору та перетворення колекцій."\r\r | firstNames duplicates |\r    firstNames:=Bag new.        "утворимо торбу імен"\r    AddressBook do: [ :entry | firstNames add: (entry at: 2) ].\r        "виберемо ті імена, які зустрічаються більше одного разу"\r    duplicates:=firstNames select:\r        [ :name | (firstNames occurrencesOf: name)>1 ].\r            ""і впорядкуємо їх""\r    duplicates:=duplicates asSet asSortedCollection.\r        "друкуємо імена та відповідні їм прізвища"\r    duplicates do: [ :first | first printOn: Transcript. Transcript show:\'==>\'.\r        AddressBook do: [ :entry | (entry at: 2)=first\r            ifTrue: [ Transcript show:\' \'. (entry at: 1) printOn: Transcript ] ].\r        Transcript cr ]. Transcript show:\' \'.\r\r"Поясніть перетворення, що відбуваються в цьому фрагменті. \r   Запропонуйте власні варіанти використання та перетворення колекцій. \r   Оформіть запропоновані вище фрагменти як методи навчального класу."\r\r\r"------ ДОДАВАННЯ АДРЕС\r  Можливо, додавання записів до AddressBook за допомогою явного програмування \r  виглядає не надто привабливо. Використайте з цією метою діалоги "\r\r| a b c | \ra := UIManager default request: \'Input first name\'.\rb := UIManager default request: \'Input second name\'.\rc := UIManager default request: \'Input address\'.\ra isNil | b isNil | c isNil ifFalse: [ AddressBook add: (Array with:a with:b with:c)].\r\r"Додайте до книги декілька нових записів, знову видрукуйте її. "\r                                    \r" Поміркуйте, як зробити зручнішим звертання до діалогу додавання адрес та друку адресної книги. "\r\r\r"Що станеться, якщо виконати наступний код? Випробуйте. "\r    Smalltalk globals removeKey:#AddressBook.\r\r"Видалиться ключ #AddressBook."\r\r "------ ПЕРЕТВОРЕННЯ (ПЕРЕВТІЛЕННЯ) ОБ\'ЄКТІВ\r   Виконайте за допомогою Do It. "\r\r | a b c|\r    a := OrderedCollection new.\r    b := Cylinder  new.\r    c := Array with: a with: b with: b.\r    Transcript show: \'Old Array is = \'.\r    c do: [ :x | Transcript show: \'     \'. x printOn: Transcript ].\r    Transcript cr.\r    a become: b.\r    Transcript show: \'New Array is = \'.\r    c do: [ :x | Transcript show: \'     \'. x printOn: Transcript ].\r    Transcript cr; show:\' \'. "Unknown variable"\r" Поясніть дію методу become:. Чи можна замість нього користуватися звичайним присвоєнням? Наведіть власні приклади. "\r\r" Він міняє всі посилання на два об’єкти місцями у всій системі.  \r  Не можна замість become використовувати звичайне присвоєння, адже такого ефекту не можливо буде досягнути."\r\r\r\r\r\r\r\r'
}OmEntry {
	#tags : {
		#timestamp : DateAndTime [ '2025-10-05T00:14:30.278+03:00' ],
		#self : OmReference [ '31' ]
	},
	#content : '"--------------------------------------------------------------------------------------\r*                      ЛАБОРОТОРНА РОБОТА 3\r*                 Тема: КЛАСИ ТА МЕТОДИ. КОЛЕКЦІЇ\r*\r*  Завдання до лабораторної роботи:\r*     1. Виконайте наведені нижче приклади, збережіть і поясніть отримані результати.\r*     2. Випробуйте різноманітні способи додавання нових класів до системи.\r*     3. Навчіться доповнювати функціональність класів.\r*     4. Випробуйте методи опрацювання колекцій.\r*\r\r    Виконайте за допомогою <Print it> \r\r ------ ПРИНАЛЕЖНІСТЬ КЛАСОВІ, ІЄРАРХІЯ КЛАСІВ\r"\r    #(Francesca Jackie Marisa Bree) class. "Array"\r    (#(Francesca Jackie Marisa Bree) at:2) class. "ByteSymbol"\r    \'Rakesh Vijay Charles Daniel Tyler\' class. "ByteString"\r    (\'Rakesh Vijay Charles Daniel Tyler\' at:2) class. "Character (a)"\r    World class . "WorldMorph"\r    Magnitude class. "Magnitude class"\r    Magnitude class class. "Metaclass"\r    nil class. "UndefinedObject"\r    5 species. "SmallInteger"\r    123456789000 species. "SmallInteger"\r    #aName species. "ByteString"\r " Яка різниця між повідомленнями class i species ? \r\r    Випробуйте різні способи відкривання браузера класів: за допомогою меню чи програмно \r     Виконайте за допомогою <Do it>\r"\r    ClyFullBrowserMorph open. \r    ClyFullBrowserMorph openOnClass: Date. \r    ClyFullBrowserMorph openOnClass: VolumeShape  selector:  #volume. \r\r" ------ МЕТОДИ КЛАСУ, КОНСТРУКТОРИ\r  Виконайте за допомогою <Print It>. Запропонуйте власні приклади. "\r\r    Array new: 10. "#(nil nil nil nil nil nil nil nil nil nil)"        \r    OrderedCollection  new. "an OrderedCollection()"\r    Date today. "29 September 2025"\r    Time now. "10:28:52.422 am"\r    UIManager default  request:\'How are you?\' initialAnswer:\'I\'\'m fine!\'. "\'I\'\'m fine!\'"\r    Integer readFrom: \'2013  1925\'. "2013"\r    Integer primesUpTo: 100. "#(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97)"\r    Rectangle origin:0@0 corner:200@100. "(0@0) corner: (200@100)"\r    Date nameOfMonth:12. "#December"\r    Date dayOfWeek: #Friday. "6"\r    Date orthodoxEasterDateFor: 2022. "24 April 2022"\r\r\r   \r"Інсталюйте вказані нижче МЕТОДИ КЛАСУ Date:\r  перенесіть копію тексту визначення методу з робочого вікна в браузер класів.\r\r""!Date class methodsFor: \'specific inquiries\' stamp: \'CamilloBruni 8/22/2013 19:47\'!""\r\rorthodoxEasterDateFor: year\r ""  compute the easter date according to the rules of the orthodox calendar.\r    source:       http://www.smart.net/~mmontes/ortheast.html   ""\r     | r1 r2 r3 r4 ra rb r5 rc date |\r\r    r1 := year \\\\ 19.\r    r2 := year \\\\ 4.\r    r3 := year \\\\ 7.\r    ra := 19*r1 + 16.\r    r4 := ra \\\\ 30.\r    rb := r2 + r2 + (4*r3) + (6*r4).\r    r5 := rb \\\\ 7.\r    rc := r4 + r5.\r    date := self year: year month: 4 day: 3.\r    ^date addDays: rc.\r""--------------------------------------------------------------------------------------""\r""!Date class methodsFor: \'specific inquiries\' stamp: \'CamilloBruni 8/22/2013 19:48\'!""\r\reasterDateFor: year\r ""  compute the easter date.\r    source: Physikalisch-Technische Bundesanstalt Braunschweig.\r    Lichtenberg, H.: Zur Interpretation der Gaussschen Osterformel und ihrer Ausnahmeregeln, Historia Mathematica 24 (1997), pp. 441-444\r      http://www.ptb.de/de/org/4/44/441/oste.htm  ""\r\r  | k m s a d r og sz oe day |\r\r  k := year // 100.\r  m := 15 + (3*k + 3//4) - (8*k + 13//25).\r   s := 2 - (3*k + 3// 4).\r  a := year \\\\ 19.\r  d := 19*a + m \\\\ 30.\r  r := d//29 + ((d//28) - (d//29)* (a// 11)).\r\r  og := 21 + d - r.\r  sz := 7 - (year//4 + year + s\\\\7).\r  oe := 7 - (og - sz\\\\7).\r  day := og + oe.\r  ^day <= 31\r    ifTrue: [ Date year: year month: 3 day: day ]\r    ifFalse: [ Date year: year month: 4 day: day - 31 ].\r"\r\r"Знайдіть роки, коли святкування припадають на один день."\r\ryearsWithMatchingEasterFrom: startYear to: endYear\r\r    | matchingYears orthodoxDate catholicDate |\r    matchingYears := OrderedCollection new.\r    (startYear to: endYear) do: [:year |\r        orthodoxDate := self orthodoxEasterDateFor: year.\r        catholicDate := self easterDateFor: year.\r        (orthodoxDate = catholicDate) ifTrue: [\r            matchingYears add: year\r        ].\r    ].\r    ^matchingYears asArray\r\rDate yearsWithMatchingEasterFrom: 2000 to: 2050. "#(2001 2004 2007 2010 2011 2014 2017 2025 2028 2031 2034 2037 2038 2041 2045 2048)"\r\r" ------ РЕКУРСІЯ\r  Додайте до класу Integer і випробуйте різні методи обчислення чисел  Фібоначчі.\r  Запропонуйте власні. Порівняйте їхню ефективність.      \r  Перед випробуванням fibonacci ЗБЕРЕЖІТЬ ІМІДЖ СИСТЕМИ! Він може зайняти Ваш комп на тиждень.  "\r\r3 fibStart: 1 with: 10  "12"\r4 fibo "5"\r12 fibonacci "233"\r\r\r\r\r\r"\r\r\r<fibStart:with:>\rЦе рекурсивний метод, який обчислює n-те число послідовності Фібоначчі, використовуючи два допоміжні параметри — n1 (попереднє значення) і n2 (передпопереднє значення). На кожному кроці рекурсії відбувається виклик:\r(self - 1) fibStart: n1 + n2 with: n1 — таким чином, наступний етап отримує нові значення, де поточне число стає сумою двох попередніх.\rТакий підхід дозволяє виконувати обчислення без повторних підрахунків уже відомих значень, тому алгоритм має лінійну складність O(n). Він працює швидко навіть для великих n і потребує мінімум пам’яті — лише для рекурсивних викликів (глибина дорівнює n).\r\r<fibo>\rЦе допоміжний метод, який просто викликає fibStart:with: із початковими значеннями. Його мета — спростити виклик функції, щоб не потрібно було вручну задавати перші два числа послідовності. Фактично, він працює так само, як і fibStart:with:, але зручніший у використанні, коли потрібно просто отримати n-те число Фібоначчі.\r\r<fibonacci>\rЦей варіант використовує класичне рекурсивне визначення:\rF(n) = F(n - 1) + F(n - 2)\rМетод простий у розумінні, але дуже неефективний для великих n, оскільки він не запам’ятовує вже обчислені значення і багаторазово виконує ті самі обчислення. Через це його складність є експоненційною — приблизно O(2ⁿ). При великих значеннях n така реалізація значно навантажує процесор і стек викликів, тому практично використовується лише для навчальних цілей або демонстрацій.\r"\r\r"------------------------------------------------------------------------------------\r ------ СТВОРЕННЯ, ОПРАЦЮВАННЯ КОЛЕКЦІЙ\r  У текстовому файлі записано інформацію про матрицю цілих чисел: розміри\r  матриці в першому рядку файла, у всіх наступних рядках - рядки матриці.}\r  Прочитати матрицю, знайти максимальні елементи кожного рядка і зберегти\r  їх у файлі. Надрукувати максимальний елемент цілої матриці."\r\r"Наведений нижче код можна виконати безпосередньо в робочому вікні,\r проте,  доцільно зробити його методом власного навчального класу."\r\r| matr fStream fName n m mMatr mLines |\r        "Вибір файла за допомогою діалогу"\r    (fName:=UIManager default\r\t\t\tchooseFullFileNameMatching: nil \r\t\t\tlabel: \'Виберіть файл з числовими даними\' ) isNil\r        ifTrue: [ ^\'Ви не вибрали файла\' ]. \r        fStream := fName asFileReference readStream.\r\t        "Введення даних"\r \t    n := Integer readFrom: fStream.  \r\t    matr := Array new: n.\r\t    m := Integer readFrom: fStream.\r\t    matr := matr collect: [ :x | Array new: m ]. \r\t    1 to: n do: [ :i |  fStream nextLine.\r \t\t     matr at: i put: (\r\t\t\t\t (matr at: i) collect: [ :x |  \r\t\t\t\t\t\tInteger readFrom: fStream. ]\r\t\t\t\t\t )\t ].\r    fStream close. matr inspect.\r        "Обчислення максимальних елементів"\r    mLines:=matr collect: [ :r | r inject: (r at: 1) into: [ :x :y | x max: y] ].\r    mMatr:=mLines at: 1.\r    mLines do: [ :x | x > mMatr ifTrue: [ mMatr := x ] ].\r        "Побудова імені файла результатів, збереження"\r    fName at: fName size - 4 put: $_ .\r    fStream := fName asFileReference writeStream.\r    mLines do: [ :x | x printOn: fStream. fStream cr ].\r    fStream close.\r    ^mMatr .  \r\r" Поясніть код, наведений вище (кожне повідомлення!):\r\r\tУ цьому коді ми працюємо з матрицею чисел, зчитаною з файлу. Спершу оголошуємо локальні змінні для зберігання самої матриці, потоку файлу, імені файлу, кількості рядків і стовпців, а також для проміжних результатів. Далі відкривається діалог для вибору файлу користувачем. Якщо файл не обрано, метод одразу повертає повідомлення про це і подальше виконання коду зупиняється.\r\rПісля цього створюється потік для читання файлу. Перше число з файлу визначає кількість рядків матриці, а друге число — кількість стовпців. У початковій версії матриця реалізується як масив масивів: спершу створюємо масив для рядків, а потім кожен рядок заповнюємо окремим масивом стовпців. Потік закривається після зчитування даних, і відкривається інспектор для перегляду структури матриці.\r\rЩоб знайти максимуми рядків, кожен рядок обробляється за допомогою методу inject, який проходить усі елементи рядка і визначає найбільше значення. Потім, перебираючи всі максимуми рядків, знаходиться загальний максимум усієї матриці. Після обробки результатів ім’я файлу змінюється для збереження результатів у новий файл, відкривається потік на запис, і кожен максимум рядка записується в файл на окремий рядок. Потім потік закривається. Нарешті, метод повертає максимальний елемент усієї матриці.\r\r   Як можна замінити масив масивів на екземпляр класу Matrix?:\r\tЯкщо використовувати клас Matrix, код можна зробити більш компактним і зручним. Клас Matrix зберігає матрицю як єдину структуру n × m, і доступ до елементів відбувається через at: i at: j, що виключає необхідність створювати масив масивів. Спочатку відкриваємо потік для читання файлу і зчитуємо розміри матриці. Потім створюємо об’єкт Matrix відповідного розміру і заповнюємо його числами з файлу. Далі, перебираючи рядки та стовпці, за допомогою вкладених inject визначаємо максимальні значення для кожного рядка та загальний максимум матриці. Результат повертається як вихідний максимум. Такий підхід дозволяє робити код більш структурованим і компактним, позбавляє зайвих проміжних масивів і робить роботу з матрицею наочнішою.\r======================================================"\r\r"------ АДРЕСНА КНИГА\r Приклад створення і використання адресної книги, описаний у одній з лекцій. \r Пригадуєте, спочатку оголошуємо глобальну змінну, що міститиме впорядковану \r колекцію масивів з трьох рядків. Спосіб порівняння описує бінарний блок."\r\r    Smalltalk globals at: #AddressBook\r              put:(SortedCollection sortBlock:[:a :b | (a at:1)<=(b at:1)]).\r\r" * --- Тепер до книги можна додавати записи. "\r\r    AddressBook\r            add: #(\'Ruth\' \'Babe\' \'456 Mudville Flats\');\r            add: #(\'Smith\' \'John\' \'12/5 Park Ave\');\r            add: #(\'Jexon\' \'John\' \'5 Baverli Hills\');\r            add: #(\'Adams\' \'John\' \'1 Hell str\');\r            add: #(\'Taylor\' \'Babe\' \'2a/35 Deribas str\');\r            add: #(\'Greg\' \'Voss\' \'12345 the USA\').\r\r" * --- Додайте власні записи. Видрукуйте вміст книги (код запропоновано нижче).  "\r\r   | s w |  s := WriteStream on: String new.\r    AddressBook do:[:x | x do:\r        [ :y | s nextPutAll: y; tab; tab.].\r        s cr. ].\r  w := Workspace openLabel: \'My Address Book\'.\r  w contents: s contents.\r\r" * ----  Наступне завдання - надрукувати список прізвищ людей з однаковими іменами. \r              Приклад демонструє різні способи перебору та перетворення колекцій."\r\r | firstNames duplicates |\r    firstNames:=Bag new.        "утворимо торбу імен"\r    AddressBook do: [ :entry | firstNames add: (entry at: 2) ].\r        "виберемо ті імена, які зустрічаються більше одного разу"\r    duplicates:=firstNames select:\r        [ :name | (firstNames occurrencesOf: name)>1 ].\r            "і впорядкуємо їх"\r    duplicates:=duplicates asSet asSortedCollection.\r        "друкуємо імена та відповідні їм прізвища"\r    duplicates do: [ :first | first printOn: Transcript. Transcript show:\'==>\'.\r        AddressBook do: [ :entry | (entry at: 2)=first\r            ifTrue: [ Transcript show:\' \'. (entry at: 1) printOn: Transcript ] ].\r        Transcript cr ]. Transcript show:\' \'.\r\r"Поясніть перетворення, що відбуваються в цьому фрагменті. \r   Запропонуйте власні варіанти використання та перетворення колекцій. \r   Оформіть запропоновані вище фрагменти як методи навчального класу."\r\r\r"------ ДОДАВАННЯ АДРЕС\r  Можливо, додавання записів до AddressBook за допомогою явного програмування \r  виглядає не надто привабливо. Використайте з цією метою діалоги "\r\r| a b c | \ra := UIManager default request: \'Input first name\'.\rb := UIManager default request: \'Input second name\'.\rc := UIManager default request: \'Input address\'.\ra isNil | b isNil | c isNil ifFalse: [ AddressBook add: (Array with:a with:b with:c)].\r\r"Додайте до книги декілька нових записів, знову видрукуйте її. "\r                                    \r" Поміркуйте, як зробити зручнішим звертання до діалогу додавання адрес та друку адресної книги. "\r\r\r"Що станеться, якщо виконати наступний код? Випробуйте. "\r    Smalltalk globals removeKey:#AddressBook.\r\r"Видалиться ключ #AddressBook."\r\r "------ ПЕРЕТВОРЕННЯ (ПЕРЕВТІЛЕННЯ) ОБ\'ЄКТІВ\r   Виконайте за допомогою Do It. "\r\r | a b c|\r    a := OrderedCollection new.\r    b := Cylinder  new.\r    c := Array with: a with: b with: b.\r    Transcript show: \'Old Array is = \'.\r    c do: [ :x | Transcript show: \'     \'. x printOn: Transcript ].\r    Transcript cr.\r    a become: b.\r    Transcript show: \'New Array is = \'.\r    c do: [ :x | Transcript show: \'     \'. x printOn: Transcript ].\r    Transcript cr; show:\' \'. "Unknown variable"\r" Поясніть дію методу become:. Чи можна замість нього користуватися звичайним присвоєнням? Наведіть власні приклади. "\r\r" Він міняє всі посилання на два об’єкти місцями у всій системі.  \r  Не можна замість become використовувати звичайне присвоєння, адже такого ефекту не можливо буде досягнути."\r\r\r\r\r\r\r\r'
}OmEntry {
	#tags : {
		#timestamp : DateAndTime [ '2025-10-05T00:17:47.806+03:00' ],
		#self : OmReference [ '32' ]
	},
	#content : '"--------------------------------------------------------------------------------------\r*                      ЛАБОРОТОРНА РОБОТА 3\r*                 Тема: КЛАСИ ТА МЕТОДИ. КОЛЕКЦІЇ\r*\r*  Завдання до лабораторної роботи:\r*     1. Виконайте наведені нижче приклади, збережіть і поясніть отримані результати.\r*     2. Випробуйте різноманітні способи додавання нових класів до системи.\r*     3. Навчіться доповнювати функціональність класів.\r*     4. Випробуйте методи опрацювання колекцій.\r*\r\r    Виконайте за допомогою <Print it> \r\r ------ ПРИНАЛЕЖНІСТЬ КЛАСОВІ, ІЄРАРХІЯ КЛАСІВ\r"\r    #(Francesca Jackie Marisa Bree) class. "Array"\r    (#(Francesca Jackie Marisa Bree) at:2) class. "ByteSymbol"\r    \'Rakesh Vijay Charles Daniel Tyler\' class. "ByteString"\r    (\'Rakesh Vijay Charles Daniel Tyler\' at:2) class. "Character (a)"\r    World class . "WorldMorph"\r    Magnitude class. "Magnitude class"\r    Magnitude class class. "Metaclass"\r    nil class. "UndefinedObject"\r    5 species. "SmallInteger"\r    123456789000 species. "SmallInteger"\r    #aName species. "ByteString"\r " Яка різниця між повідомленнями class i species ? \r\r    Випробуйте різні способи відкривання браузера класів: за допомогою меню чи програмно \r     Виконайте за допомогою <Do it>\r"\r    ClyFullBrowserMorph open. \r    ClyFullBrowserMorph openOnClass: Date. \r    ClyFullBrowserMorph openOnClass: VolumeShape  selector:  #volume. \r\r" ------ МЕТОДИ КЛАСУ, КОНСТРУКТОРИ\r  Виконайте за допомогою <Print It>. Запропонуйте власні приклади. "\r\r    Array new: 10. "#(nil nil nil nil nil nil nil nil nil nil)"        \r    OrderedCollection  new. "an OrderedCollection()"\r    Date today. "29 September 2025"\r    Time now. "10:28:52.422 am"\r    UIManager default  request:\'How are you?\' initialAnswer:\'I\'\'m fine!\'. "\'I\'\'m fine!\'"\r    Integer readFrom: \'2013  1925\'. "2013"\r    Integer primesUpTo: 100. "#(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97)"\r    Rectangle origin:0@0 corner:200@100. "(0@0) corner: (200@100)"\r    Date nameOfMonth:12. "#December"\r    Date dayOfWeek: #Friday. "6"\r    Date orthodoxEasterDateFor: 2022. "24 April 2022"\r\r\r   \r"Інсталюйте вказані нижче МЕТОДИ КЛАСУ Date:\r  перенесіть копію тексту визначення методу з робочого вікна в браузер класів.\r\r""!Date class methodsFor: \'specific inquiries\' stamp: \'CamilloBruni 8/22/2013 19:47\'!""\r\rorthodoxEasterDateFor: year\r ""  compute the easter date according to the rules of the orthodox calendar.\r    source:       http://www.smart.net/~mmontes/ortheast.html   ""\r     | r1 r2 r3 r4 ra rb r5 rc date |\r\r    r1 := year \\\\ 19.\r    r2 := year \\\\ 4.\r    r3 := year \\\\ 7.\r    ra := 19*r1 + 16.\r    r4 := ra \\\\ 30.\r    rb := r2 + r2 + (4*r3) + (6*r4).\r    r5 := rb \\\\ 7.\r    rc := r4 + r5.\r    date := self year: year month: 4 day: 3.\r    ^date addDays: rc.\r""--------------------------------------------------------------------------------------""\r""!Date class methodsFor: \'specific inquiries\' stamp: \'CamilloBruni 8/22/2013 19:48\'!""\r\reasterDateFor: year\r ""  compute the easter date.\r    source: Physikalisch-Technische Bundesanstalt Braunschweig.\r    Lichtenberg, H.: Zur Interpretation der Gaussschen Osterformel und ihrer Ausnahmeregeln, Historia Mathematica 24 (1997), pp. 441-444\r      http://www.ptb.de/de/org/4/44/441/oste.htm  ""\r\r  | k m s a d r og sz oe day |\r\r  k := year // 100.\r  m := 15 + (3*k + 3//4) - (8*k + 13//25).\r   s := 2 - (3*k + 3// 4).\r  a := year \\\\ 19.\r  d := 19*a + m \\\\ 30.\r  r := d//29 + ((d//28) - (d//29)* (a// 11)).\r\r  og := 21 + d - r.\r  sz := 7 - (year//4 + year + s\\\\7).\r  oe := 7 - (og - sz\\\\7).\r  day := og + oe.\r  ^day <= 31\r    ifTrue: [ Date year: year month: 3 day: day ]\r    ifFalse: [ Date year: year month: 4 day: day - 31 ].\r"\r\r"Знайдіть роки, коли святкування припадають на один день."\r\ryearsWithMatchingEasterFrom: startYear to: endYear\r\r    | matchingYears orthodoxDate catholicDate |\r    matchingYears := OrderedCollection new.\r    (startYear to: endYear) do: [:year |\r        orthodoxDate := self orthodoxEasterDateFor: year.\r        catholicDate := self easterDateFor: year.\r        (orthodoxDate = catholicDate) ifTrue: [\r            matchingYears add: year\r        ].\r    ].\r    ^matchingYears asArray\r\rDate yearsWithMatchingEasterFrom: 2000 to: 2050. "#(2001 2004 2007 2010 2011 2014 2017 2025 2028 2031 2034 2037 2038 2041 2045 2048)"\r\r" ------ РЕКУРСІЯ\r  Додайте до класу Integer і випробуйте різні методи обчислення чисел  Фібоначчі.\r  Запропонуйте власні. Порівняйте їхню ефективність.      \r  Перед випробуванням fibonacci ЗБЕРЕЖІТЬ ІМІДЖ СИСТЕМИ! Він може зайняти Ваш комп на тиждень.  "\r\r" * ------- "\rfibonacci\r        "Answer the nth fibonacci number, where n is the receiver."\r    ^self < 2\r        ifTrue: [1]\r        ifFalse:[(self - 1) fibonacci + (self - 2) fibonacci]\r" * ------- "\rfibo\r        "Frontend function to call fibStart: with: .\r         Answer the nth fibonacci number, where n is the receiver."\r    ^self fibStart:1 with:1\r" * ------- "\rfibStart: n1 with: n2\r        "Private - Calculate the n-th Fibonacci number, where\r         n is the receiver, n1 is previous Fibonacci number\r         and n2 - the preprevious one."\r ^ (self < 2)\r        ifTrue: [ n1 ]\r        ifFalse:[ (self - 1) fibStart: n1+n2 with:n1 ]\r\r3 fibStart: 1 with: 10  "12"\r4 fibo "5"\r12 fibonacci "233"\r\r\r\r\r\r"\r\r\r<fibStart:with:>\rЦе рекурсивний метод, який обчислює n-те число послідовності Фібоначчі, використовуючи два допоміжні параметри — n1 (попереднє значення) і n2 (передпопереднє значення). На кожному кроці рекурсії відбувається виклик:\r(self - 1) fibStart: n1 + n2 with: n1 — таким чином, наступний етап отримує нові значення, де поточне число стає сумою двох попередніх.\rТакий підхід дозволяє виконувати обчислення без повторних підрахунків уже відомих значень, тому алгоритм має лінійну складність O(n). Він працює швидко навіть для великих n і потребує мінімум пам’яті — лише для рекурсивних викликів (глибина дорівнює n).\r\r<fibo>\rЦе допоміжний метод, який просто викликає fibStart:with: із початковими значеннями. Його мета — спростити виклик функції, щоб не потрібно було вручну задавати перші два числа послідовності. Фактично, він працює так само, як і fibStart:with:, але зручніший у використанні, коли потрібно просто отримати n-те число Фібоначчі.\r\r<fibonacci>\rЦей варіант використовує класичне рекурсивне визначення:\rF(n) = F(n - 1) + F(n - 2)\rМетод простий у розумінні, але дуже неефективний для великих n, оскільки він не запам’ятовує вже обчислені значення і багаторазово виконує ті самі обчислення. Через це його складність є експоненційною — приблизно O(2ⁿ). При великих значеннях n така реалізація значно навантажує процесор і стек викликів, тому практично використовується лише для навчальних цілей або демонстрацій.\r"\r\r"------------------------------------------------------------------------------------\r ------ СТВОРЕННЯ, ОПРАЦЮВАННЯ КОЛЕКЦІЙ\r  У текстовому файлі записано інформацію про матрицю цілих чисел: розміри\r  матриці в першому рядку файла, у всіх наступних рядках - рядки матриці.}\r  Прочитати матрицю, знайти максимальні елементи кожного рядка і зберегти\r  їх у файлі. Надрукувати максимальний елемент цілої матриці."\r\r"Наведений нижче код можна виконати безпосередньо в робочому вікні,\r проте,  доцільно зробити його методом власного навчального класу."\r\r| matr fStream fName n m mMatr mLines |\r        "Вибір файла за допомогою діалогу"\r    (fName:=UIManager default\r\t\t\tchooseFullFileNameMatching: nil \r\t\t\tlabel: \'Виберіть файл з числовими даними\' ) isNil\r        ifTrue: [ ^\'Ви не вибрали файла\' ]. \r        fStream := fName asFileReference readStream.\r\t        "Введення даних"\r \t    n := Integer readFrom: fStream.  \r\t    matr := Array new: n.\r\t    m := Integer readFrom: fStream.\r\t    matr := matr collect: [ :x | Array new: m ]. \r\t    1 to: n do: [ :i |  fStream nextLine.\r \t\t     matr at: i put: (\r\t\t\t\t (matr at: i) collect: [ :x |  \r\t\t\t\t\t\tInteger readFrom: fStream. ]\r\t\t\t\t\t )\t ].\r    fStream close. matr inspect.\r        "Обчислення максимальних елементів"\r    mLines:=matr collect: [ :r | r inject: (r at: 1) into: [ :x :y | x max: y] ].\r    mMatr:=mLines at: 1.\r    mLines do: [ :x | x > mMatr ifTrue: [ mMatr := x ] ].\r        "Побудова імені файла результатів, збереження"\r    fName at: fName size - 4 put: $_ .\r    fStream := fName asFileReference writeStream.\r    mLines do: [ :x | x printOn: fStream. fStream cr ].\r    fStream close.\r    ^mMatr .  \r\r" Поясніть код, наведений вище (кожне повідомлення!):\r\r\tУ цьому коді ми працюємо з матрицею чисел, зчитаною з файлу. Спершу оголошуємо локальні змінні для зберігання самої матриці, потоку файлу, імені файлу, кількості рядків і стовпців, а також для проміжних результатів. Далі відкривається діалог для вибору файлу користувачем. Якщо файл не обрано, метод одразу повертає повідомлення про це і подальше виконання коду зупиняється.\r\rПісля цього створюється потік для читання файлу. Перше число з файлу визначає кількість рядків матриці, а друге число — кількість стовпців. У початковій версії матриця реалізується як масив масивів: спершу створюємо масив для рядків, а потім кожен рядок заповнюємо окремим масивом стовпців. Потік закривається після зчитування даних, і відкривається інспектор для перегляду структури матриці.\r\rЩоб знайти максимуми рядків, кожен рядок обробляється за допомогою методу inject, який проходить усі елементи рядка і визначає найбільше значення. Потім, перебираючи всі максимуми рядків, знаходиться загальний максимум усієї матриці. Після обробки результатів ім’я файлу змінюється для збереження результатів у новий файл, відкривається потік на запис, і кожен максимум рядка записується в файл на окремий рядок. Потім потік закривається. Нарешті, метод повертає максимальний елемент усієї матриці.\r\r   Як можна замінити масив масивів на екземпляр класу Matrix?:\r\tЯкщо використовувати клас Matrix, код можна зробити більш компактним і зручним. Клас Matrix зберігає матрицю як єдину структуру n × m, і доступ до елементів відбувається через at: i at: j, що виключає необхідність створювати масив масивів. Спочатку відкриваємо потік для читання файлу і зчитуємо розміри матриці. Потім створюємо об’єкт Matrix відповідного розміру і заповнюємо його числами з файлу. Далі, перебираючи рядки та стовпці, за допомогою вкладених inject визначаємо максимальні значення для кожного рядка та загальний максимум матриці. Результат повертається як вихідний максимум. Такий підхід дозволяє робити код більш структурованим і компактним, позбавляє зайвих проміжних масивів і робить роботу з матрицею наочнішою.\r======================================================"\r\r"------ АДРЕСНА КНИГА\r Приклад створення і використання адресної книги, описаний у одній з лекцій. \r Пригадуєте, спочатку оголошуємо глобальну змінну, що міститиме впорядковану \r колекцію масивів з трьох рядків. Спосіб порівняння описує бінарний блок."\r\r    Smalltalk globals at: #AddressBook\r              put:(SortedCollection sortBlock:[:a :b | (a at:1)<=(b at:1)]).\r\r" * --- Тепер до книги можна додавати записи. "\r\r    AddressBook\r            add: #(\'Ruth\' \'Babe\' \'456 Mudville Flats\');\r            add: #(\'Smith\' \'John\' \'12/5 Park Ave\');\r            add: #(\'Jexon\' \'John\' \'5 Baverli Hills\');\r            add: #(\'Adams\' \'John\' \'1 Hell str\');\r            add: #(\'Taylor\' \'Babe\' \'2a/35 Deribas str\');\r            add: #(\'Greg\' \'Voss\' \'12345 the USA\').\r\r" * --- Додайте власні записи. Видрукуйте вміст книги (код запропоновано нижче).  "\r\r   | s w |  s := WriteStream on: String new.\r    AddressBook do:[:x | x do:\r        [ :y | s nextPutAll: y; tab; tab.].\r        s cr. ].\r  w := Workspace openLabel: \'My Address Book\'.\r  w contents: s contents.\r\r" * ----  Наступне завдання - надрукувати список прізвищ людей з однаковими іменами. \r              Приклад демонструє різні способи перебору та перетворення колекцій."\r\r | firstNames duplicates |\r    firstNames:=Bag new.        "утворимо торбу імен"\r    AddressBook do: [ :entry | firstNames add: (entry at: 2) ].\r        "виберемо ті імена, які зустрічаються більше одного разу"\r    duplicates:=firstNames select:\r        [ :name | (firstNames occurrencesOf: name)>1 ].\r            "і впорядкуємо їх"\r    duplicates:=duplicates asSet asSortedCollection.\r        "друкуємо імена та відповідні їм прізвища"\r    duplicates do: [ :first | first printOn: Transcript. Transcript show:\'==>\'.\r        AddressBook do: [ :entry | (entry at: 2)=first\r            ifTrue: [ Transcript show:\' \'. (entry at: 1) printOn: Transcript ] ].\r        Transcript cr ]. Transcript show:\' \'.\r\r"Поясніть перетворення, що відбуваються в цьому фрагменті. \r   Запропонуйте власні варіанти використання та перетворення колекцій. \r   Оформіть запропоновані вище фрагменти як методи навчального класу."\r\r\r"------ ДОДАВАННЯ АДРЕС\r  Можливо, додавання записів до AddressBook за допомогою явного програмування \r  виглядає не надто привабливо. Використайте з цією метою діалоги "\r\r| a b c | \ra := UIManager default request: \'Input first name\'.\rb := UIManager default request: \'Input second name\'.\rc := UIManager default request: \'Input address\'.\ra isNil | b isNil | c isNil ifFalse: [ AddressBook add: (Array with:a with:b with:c)].\r\r"Додайте до книги декілька нових записів, знову видрукуйте її. "\r                                    \r" Поміркуйте, як зробити зручнішим звертання до діалогу додавання адрес та друку адресної книги. "\r\r\r"Що станеться, якщо виконати наступний код? Випробуйте. "\r    Smalltalk globals removeKey:#AddressBook.\r\r"Видалиться ключ #AddressBook."\r\r "------ ПЕРЕТВОРЕННЯ (ПЕРЕВТІЛЕННЯ) ОБ\'ЄКТІВ\r   Виконайте за допомогою Do It. "\r\r | a b c|\r    a := OrderedCollection new.\r    b := Cylinder  new.\r    c := Array with: a with: b with: b.\r    Transcript show: \'Old Array is = \'.\r    c do: [ :x | Transcript show: \'     \'. x printOn: Transcript ].\r    Transcript cr.\r    a become: b.\r    Transcript show: \'New Array is = \'.\r    c do: [ :x | Transcript show: \'     \'. x printOn: Transcript ].\r    Transcript cr; show:\' \'. "Unknown variable"\r" Поясніть дію методу become:. Чи можна замість нього користуватися звичайним присвоєнням? Наведіть власні приклади. "\r\r" Він міняє всі посилання на два об’єкти місцями у всій системі.  \r  Не можна замість become використовувати звичайне присвоєння, адже такого ефекту не можливо буде досягнути."\r\r\r\r\r\r\r\r'
}OmEntry {
	#tags : {
		#timestamp : DateAndTime [ '2025-10-05T00:20:35.285+03:00' ],
		#self : OmReference [ '33' ]
	},
	#content : '"--------------------------------------------------------------------------------------\r*                      ЛАБОРОТОРНА РОБОТА 3\r*                 Тема: КЛАСИ ТА МЕТОДИ. КОЛЕКЦІЇ\r*\r*  Завдання до лабораторної роботи:\r*     1. Виконайте наведені нижче приклади, збережіть і поясніть отримані результати.\r*     2. Випробуйте різноманітні способи додавання нових класів до системи.\r*     3. Навчіться доповнювати функціональність класів.\r*     4. Випробуйте методи опрацювання колекцій.\r*\r\r    Виконайте за допомогою <Print it> \r\r ------ ПРИНАЛЕЖНІСТЬ КЛАСОВІ, ІЄРАРХІЯ КЛАСІВ\r"\r    #(Francesca Jackie Marisa Bree) class. "Array"\r    (#(Francesca Jackie Marisa Bree) at:2) class. "ByteSymbol"\r    \'Rakesh Vijay Charles Daniel Tyler\' class. "ByteString"\r    (\'Rakesh Vijay Charles Daniel Tyler\' at:2) class. "Character (a)"\r    World class . "WorldMorph"\r    Magnitude class. "Magnitude class"\r    Magnitude class class. "Metaclass"\r    nil class. "UndefinedObject"\r    5 species. "SmallInteger"\r    123456789000 species. "SmallInteger"\r    #aName species. "ByteString"\r " Яка різниця між повідомленнями class i species ? \r\r    Випробуйте різні способи відкривання браузера класів: за допомогою меню чи програмно \r     Виконайте за допомогою <Do it>\r"\r    ClyFullBrowserMorph open. \r    ClyFullBrowserMorph openOnClass: Date. \r    ClyFullBrowserMorph openOnClass: VolumeShape  selector:  #volume. \r\r" ------ МЕТОДИ КЛАСУ, КОНСТРУКТОРИ\r  Виконайте за допомогою <Print It>. Запропонуйте власні приклади. "\r\r    Array new: 10. "#(nil nil nil nil nil nil nil nil nil nil)"        \r    OrderedCollection  new. "an OrderedCollection()"\r    Date today. "29 September 2025"\r    Time now. "10:28:52.422 am"\r    UIManager default  request:\'How are you?\' initialAnswer:\'I\'\'m fine!\'. "\'I\'\'m fine!\'"\r    Integer readFrom: \'2013  1925\'. "2013"\r    Integer primesUpTo: 100. "#(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97)"\r    Rectangle origin:0@0 corner:200@100. "(0@0) corner: (200@100)"\r    Date nameOfMonth:12. "#December"\r    Date dayOfWeek: #Friday. "6"\r    Date orthodoxEasterDateFor: 2022. "24 April 2022"\r\r\r   \r"Інсталюйте вказані нижче МЕТОДИ КЛАСУ Date:\r  перенесіть копію тексту визначення методу з робочого вікна в браузер класів.\r\r""!Date class methodsFor: \'specific inquiries\' stamp: \'CamilloBruni 8/22/2013 19:47\'!""\r\rorthodoxEasterDateFor: year\r ""  compute the easter date according to the rules of the orthodox calendar.\r    source:       http://www.smart.net/~mmontes/ortheast.html   ""\r     | r1 r2 r3 r4 ra rb r5 rc date |\r\r    r1 := year \\\\ 19.\r    r2 := year \\\\ 4.\r    r3 := year \\\\ 7.\r    ra := 19*r1 + 16.\r    r4 := ra \\\\ 30.\r    rb := r2 + r2 + (4*r3) + (6*r4).\r    r5 := rb \\\\ 7.\r    rc := r4 + r5.\r    date := self year: year month: 4 day: 3.\r    ^date addDays: rc.\r""--------------------------------------------------------------------------------------""\r""!Date class methodsFor: \'specific inquiries\' stamp: \'CamilloBruni 8/22/2013 19:48\'!""\r\reasterDateFor: year\r ""  compute the easter date.\r    source: Physikalisch-Technische Bundesanstalt Braunschweig.\r    Lichtenberg, H.: Zur Interpretation der Gaussschen Osterformel und ihrer Ausnahmeregeln, Historia Mathematica 24 (1997), pp. 441-444\r      http://www.ptb.de/de/org/4/44/441/oste.htm  ""\r\r  | k m s a d r og sz oe day |\r\r  k := year // 100.\r  m := 15 + (3*k + 3//4) - (8*k + 13//25).\r   s := 2 - (3*k + 3// 4).\r  a := year \\\\ 19.\r  d := 19*a + m \\\\ 30.\r  r := d//29 + ((d//28) - (d//29)* (a// 11)).\r\r  og := 21 + d - r.\r  sz := 7 - (year//4 + year + s\\\\7).\r  oe := 7 - (og - sz\\\\7).\r  day := og + oe.\r  ^day <= 31\r    ifTrue: [ Date year: year month: 3 day: day ]\r    ifFalse: [ Date year: year month: 4 day: day - 31 ].\r"\r\r"Знайдіть роки, коли святкування припадають на один день."\r\ryearsWithMatchingEasterFrom: startYear to: endYear\r\r    | matchingYears orthodoxDate catholicDate |\r    matchingYears := OrderedCollection new.\r    (startYear to: endYear) do: [:year |\r        orthodoxDate := self orthodoxEasterDateFor: year.\r        catholicDate := self easterDateFor: year.\r        (orthodoxDate = catholicDate) ifTrue: [\r            matchingYears add: year\r        ].\r    ].\r    ^matchingYears asArray\r\rDate yearsWithMatchingEasterFrom: 2000 to: 2050. "#(2001 2004 2007 2010 2011 2014 2017 2025 2028 2031 2034 2037 2038 2041 2045 2048)"\r\r" ------ РЕКУРСІЯ\r  Додайте до класу Integer і випробуйте різні методи обчислення чисел  Фібоначчі.\r  Запропонуйте власні. Порівняйте їхню ефективність.      \r  Перед випробуванням fibonacci ЗБЕРЕЖІТЬ ІМІДЖ СИСТЕМИ! Він може зайняти Ваш комп на тиждень.  "\r\r" * ------- "\rfibonacci\r        "Answer the nth fibonacci number, where n is the receiver."\r    ^self < 2\r        ifTrue: [1]\r        ifFalse:[(self - 1) fibonacci + (self - 2) fibonacci]\r" * ------- "\rfibo\r        "Frontend function to call fibStart: with: .\r         Answer the nth fibonacci number, where n is the receiver."\r    ^self fibStart:1 with:1\r" * ------- "\rfibStart: n1 with: n2\r        "Private - Calculate the n-th Fibonacci number, where\r         n is the receiver, n1 is previous Fibonacci number\r         and n2 - the preprevious one."\r ^ (self < 2)\r        ifTrue: [ n1 ]\r        ifFalse:[ (self - 1) fibStart: n1+n2 with:n1 ]\r\r3 fibStart: 1 with: 10  "12"\r4 fibo "5"\r12 fibonacci "233"\r\r\r"\r\r\r<fibStart:with:>\rЦе рекурсивний метод, який обчислює n-те число послідовності Фібоначчі, використовуючи два допоміжні параметри — n1 (попереднє значення) і n2 (передпопереднє значення). На кожному кроці рекурсії відбувається виклик:\r(self - 1) fibStart: n1 + n2 with: n1 — таким чином, наступний етап отримує нові значення, де поточне число стає сумою двох попередніх.\rТакий підхід дозволяє виконувати обчислення без повторних підрахунків уже відомих значень, тому алгоритм має лінійну складність O(n). Він працює швидко навіть для великих n і потребує мінімум пам’яті — лише для рекурсивних викликів (глибина дорівнює n).\r\r<fibo>\rЦе допоміжний метод, який просто викликає fibStart:with: із початковими значеннями. Його мета — спростити виклик функції, щоб не потрібно було вручну задавати перші два числа послідовності. Фактично, він працює так само, як і fibStart:with:, але зручніший у використанні, коли потрібно просто отримати n-те число Фібоначчі.\r\r<fibonacci>\rЦей варіант використовує класичне рекурсивне визначення:\rF(n) = F(n - 1) + F(n - 2)\rМетод простий у розумінні, але дуже неефективний для великих n, оскільки він не запам’ятовує вже обчислені значення і багаторазово виконує ті самі обчислення. Через це його складність є експоненційною — приблизно O(2ⁿ). При великих значеннях n така реалізація значно навантажує процесор і стек викликів, тому практично використовується лише для навчальних цілей або демонстрацій.\r"\r\r"------------------------------------------------------------------------------------\r ------ СТВОРЕННЯ, ОПРАЦЮВАННЯ КОЛЕКЦІЙ\r  У текстовому файлі записано інформацію про матрицю цілих чисел: розміри\r  матриці в першому рядку файла, у всіх наступних рядках - рядки матриці.}\r  Прочитати матрицю, знайти максимальні елементи кожного рядка і зберегти\r  їх у файлі. Надрукувати максимальний елемент цілої матриці."\r\r"Наведений нижче код можна виконати безпосередньо в робочому вікні,\r проте,  доцільно зробити його методом власного навчального класу."\r\r| matr fStream fName n m mMatr mLines |\r        "Вибір файла за допомогою діалогу"\r    (fName:=UIManager default\r\t\t\tchooseFullFileNameMatching: nil \r\t\t\tlabel: \'Виберіть файл з числовими даними\' ) isNil\r        ifTrue: [ ^\'Ви не вибрали файла\' ]. \r        fStream := fName asFileReference readStream.\r\t        "Введення даних"\r \t    n := Integer readFrom: fStream.  \r\t    matr := Array new: n.\r\t    m := Integer readFrom: fStream.\r\t    matr := matr collect: [ :x | Array new: m ]. \r\t    1 to: n do: [ :i |  fStream nextLine.\r \t\t     matr at: i put: (\r\t\t\t\t (matr at: i) collect: [ :x |  \r\t\t\t\t\t\tInteger readFrom: fStream. ]\r\t\t\t\t\t )\t ].\r    fStream close. matr inspect.\r        "Обчислення максимальних елементів"\r    mLines:=matr collect: [ :r | r inject: (r at: 1) into: [ :x :y | x max: y] ].\r    mMatr:=mLines at: 1.\r    mLines do: [ :x | x > mMatr ifTrue: [ mMatr := x ] ].\r        "Побудова імені файла результатів, збереження"\r    fName at: fName size - 4 put: $_ .\r    fStream := fName asFileReference writeStream.\r    mLines do: [ :x | x printOn: fStream. fStream cr ].\r    fStream close.\r    ^mMatr .  \r\r" Поясніть код, наведений вище (кожне повідомлення!):\r\r\tУ цьому коді ми працюємо з матрицею чисел, зчитаною з файлу. Спершу оголошуємо локальні змінні для зберігання самої матриці, потоку файлу, імені файлу, кількості рядків і стовпців, а також для проміжних результатів. Далі відкривається діалог для вибору файлу користувачем. Якщо файл не обрано, метод одразу повертає повідомлення про це і подальше виконання коду зупиняється.\r\rПісля цього створюється потік для читання файлу. Перше число з файлу визначає кількість рядків матриці, а друге число — кількість стовпців. У початковій версії матриця реалізується як масив масивів: спершу створюємо масив для рядків, а потім кожен рядок заповнюємо окремим масивом стовпців. Потік закривається після зчитування даних, і відкривається інспектор для перегляду структури матриці.\r\rЩоб знайти максимуми рядків, кожен рядок обробляється за допомогою методу inject, який проходить усі елементи рядка і визначає найбільше значення. Потім, перебираючи всі максимуми рядків, знаходиться загальний максимум усієї матриці. Після обробки результатів ім’я файлу змінюється для збереження результатів у новий файл, відкривається потік на запис, і кожен максимум рядка записується в файл на окремий рядок. Потім потік закривається. Нарешті, метод повертає максимальний елемент усієї матриці.\r\r   Як можна замінити масив масивів на екземпляр класу Matrix?:\r\tЯкщо використовувати клас Matrix, код можна зробити більш компактним і зручним. Клас Matrix зберігає матрицю як єдину структуру n × m, і доступ до елементів відбувається через at: i at: j, що виключає необхідність створювати масив масивів. Спочатку відкриваємо потік для читання файлу і зчитуємо розміри матриці. Потім створюємо об’єкт Matrix відповідного розміру і заповнюємо його числами з файлу. Далі, перебираючи рядки та стовпці, за допомогою вкладених inject визначаємо максимальні значення для кожного рядка та загальний максимум матриці. Результат повертається як вихідний максимум. Такий підхід дозволяє робити код більш структурованим і компактним, позбавляє зайвих проміжних масивів і робить роботу з матрицею наочнішою.\r======================================================"\r\r"------ АДРЕСНА КНИГА\r Приклад створення і використання адресної книги, описаний у одній з лекцій. \r Пригадуєте, спочатку оголошуємо глобальну змінну, що міститиме впорядковану \r колекцію масивів з трьох рядків. Спосіб порівняння описує бінарний блок."\r\r    Smalltalk globals at: #AddressBook\r              put:(SortedCollection sortBlock:[:a :b | (a at:1)<=(b at:1)]).\r\r" * --- Тепер до книги можна додавати записи. "\r\r    AddressBook\r            add: #(\'Ruth\' \'Babe\' \'456 Mudville Flats\');\r            add: #(\'Smith\' \'John\' \'12/5 Park Ave\');\r            add: #(\'Jexon\' \'John\' \'5 Baverli Hills\');\r            add: #(\'Adams\' \'John\' \'1 Hell str\');\r            add: #(\'Taylor\' \'Babe\' \'2a/35 Deribas str\');\r            add: #(\'Greg\' \'Voss\' \'12345 the USA\').\r\r" * --- Додайте власні записи. Видрукуйте вміст книги (код запропоновано нижче).  "\r\r   | s w |  s := WriteStream on: String new.\r    AddressBook do:[:x | x do:\r        [ :y | s nextPutAll: y; tab; tab.].\r        s cr. ].\r  w := Workspace openLabel: \'My Address Book\'.\r  w contents: s contents.\r\r" * ----  Наступне завдання - надрукувати список прізвищ людей з однаковими іменами. \r              Приклад демонструє різні способи перебору та перетворення колекцій."\r\r | firstNames duplicates |\r    firstNames:=Bag new.        "утворимо торбу імен"\r    AddressBook do: [ :entry | firstNames add: (entry at: 2) ].\r        "виберемо ті імена, які зустрічаються більше одного разу"\r    duplicates:=firstNames select:\r        [ :name | (firstNames occurrencesOf: name)>1 ].\r            "і впорядкуємо їх"\r    duplicates:=duplicates asSet asSortedCollection.\r        "друкуємо імена та відповідні їм прізвища"\r    duplicates do: [ :first | first printOn: Transcript. Transcript show:\'==>\'.\r        AddressBook do: [ :entry | (entry at: 2)=first\r            ifTrue: [ Transcript show:\' \'. (entry at: 1) printOn: Transcript ] ].\r        Transcript cr ]. Transcript show:\' \'.\r\r"Поясніть перетворення, що відбуваються в цьому фрагменті. \r   Запропонуйте власні варіанти використання та перетворення колекцій. \r   Оформіть запропоновані вище фрагменти як методи навчального класу."\r\r\r"------ ДОДАВАННЯ АДРЕС\r  Можливо, додавання записів до AddressBook за допомогою явного програмування \r  виглядає не надто привабливо. Використайте з цією метою діалоги "\r\r| a b c | \ra := UIManager default request: \'Input first name\'.\rb := UIManager default request: \'Input second name\'.\rc := UIManager default request: \'Input address\'.\ra isNil | b isNil | c isNil ifFalse: [ AddressBook add: (Array with:a with:b with:c)].\r\r"Додайте до книги декілька нових записів, знову видрукуйте її. "\r                                    \r" Поміркуйте, як зробити зручнішим звертання до діалогу додавання адрес та друку адресної книги. "\r\r\r"Що станеться, якщо виконати наступний код? Випробуйте. "\r    Smalltalk globals removeKey:#AddressBook.\r\r"Видалиться ключ #AddressBook."\r\r "------ ПЕРЕТВОРЕННЯ (ПЕРЕВТІЛЕННЯ) ОБ\'ЄКТІВ\r   Виконайте за допомогою Do It. "\r\r | a b c|\r    a := OrderedCollection new.\r    b := Cylinder  new.\r    c := Array with: a with: b with: b.\r    Transcript show: \'Old Array is = \'.\r    c do: [ :x | Transcript show: \'     \'. x printOn: Transcript ].\r    Transcript cr.\r    a become: b.\r    Transcript show: \'New Array is = \'.\r    c do: [ :x | Transcript show: \'     \'. x printOn: Transcript ].\r    Transcript cr; show:\' \'. "Unknown variable"\r" Поясніть дію методу become:. Чи можна замість нього користуватися звичайним присвоєнням? Наведіть власні приклади. "\r\r" Він міняє всі посилання на два об’єкти місцями у всій системі.  \r  Не можна замість become використовувати звичайне присвоєння, адже такого ефекту не можливо буде досягнути."\r\r\r\r\r\r\r\r'
}